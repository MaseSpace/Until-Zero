const TERRITORIES = {
  "Alpine States": ["Balkans", "France", "Germany", "Italy", "Poland-Baltic", "Ukraine"],
  "Arabia": ["East Africa", "Egypt", "Iran", "Turkey"],
  "Argentina North": ["Argentina South", "Bolivia", "Brazil South", "Chile", "La Plata"],
  "Argentina South": ["Argentina North", "Chile", "Southern Africa"],
  "Australia East": ["Australia West", "New Zealand", "Papua"],
  "Australia West": ["Australia East", "Maritime SEA"],
  "Balkans": ["Alpine States", "Germany", "Italy", "Poland-Baltic", "Turkey", "Ukraine"],
  "Benelux": ["British Isles", "France", "Germany"],
  "Bolivia": ["Argentina North", "Brazil North", "Brazil South", "Chile", "La Plata", "Peru"],
  "Brazil North": ["Bolivia", "Brazil South", "Colombia", "France", "Gulf of Guinea", "Peru", "Venezuela"],
  "Brazil South": ["Argentina North", "Bolivia", "Brazil North", "La Plata"],
  "British Isles": ["Benelux", "France", "Greenland", "US Northeast"],
  "Canada Central": ["Canada East", "Canada West", "US Midwest", "US Rockies"],
  "Canada East": ["Canada Central", "Greenland", "US Midwest", "US Northeast"],
  "Canada West": ["Canada Central", "US Midwest", "US Northwest", "US Rockies"],
  "Caucasus": ["Iran", "Russia West", "Turkey"],
  "Central Africa": ["East Africa", "Nigeria", "Sahel", "Southern Africa"],
  "Central America": ["Colombia", "Mexico"],
  "Central Asia": ["China West", "Iran", "Mongolia", "Pakistan", "Russia East", "Russia West"],
  "Chile": ["Argentina North", "Argentina South", "Bolivia", "Peru"],
  "China Central": ["China East", "China West", "India North", "Mainland SEA", "Mongolia"],
  "China East": ["China Central", "Korea", "Mainland SEA", "Mongolia", "Russia East"],
  "China West": ["Central Asia", "China Central", "India North", "Mongolia", "Pakistan", "Russia East"],
  "Colombia": ["Brazil North", "Central America", "Peru", "Venezuela"],
  "Cuba": ["Hispaniola", "US Southeast"],
  "East Africa": ["Arabia", "Central Africa", "Madagascar", "Sahel", "Southern Africa"],
  "Egypt": ["Arabia", "Maghreb", "Sahel"],
  "France": ["Alpine States", "Benelux", "Brazil North", "British Isles", "Germany", "Iberia", "Italy"],
  "Germany": ["Alpine States", "Balkans", "Benelux", "France", "Italy", "Poland-Baltic", "Scandinavia"],
  "Greenland": ["British Isles", "Canada East"],
  "Gulf of Guinea": ["Brazil North", "Nigeria", "Sahel"],
  "Hispaniola": ["Cuba", "Venezuela"],
  "Iberia": ["France", "Maghreb", "US Southeast"],
  "India North": ["China Central", "China West", "India South", "Mainland SEA", "Pakistan"],
  "India South": ["India North", "Pakistan"],
  "Iran": ["Arabia", "Caucasus", "Central Asia", "Pakistan", "Turkey"],
  "Italy": ["Alpine States", "Balkans", "France", "Germany"],
  "Japan North": ["Japan South", "Russia East"],
  "Japan South": ["Japan North", "Korea"],
  "Korea": ["China East", "Japan South", "Russia East"],
  "La Plata": ["Argentina North", "Bolivia", "Brazil South"],
  "Madagascar": ["East Africa", "Southern Africa"],
  "Maghreb": ["Egypt", "Iberia", "Sahel"],
  "Mainland SEA": ["China Central", "China East", "India North", "Maritime SEA"],
  "Maritime SEA": ["Australia West", "Mainland SEA", "Papua"],
  "Mexico": ["Central America", "US Pacific", "US South", "US Southwest"],
  "Mongolia": ["Central Asia", "China Central", "China East", "China West", "Russia East"],
  "New Zealand": ["Australia East", "Papua"],
  "Nigeria": ["Central Africa", "Gulf of Guinea", "Sahel"],
  "Pakistan": ["Central Asia", "China West", "India North", "India South", "Iran"],
  "Papua": ["Australia East", "Maritime SEA", "New Zealand"],
  "Peru": ["Bolivia", "Brazil North", "Chile", "Colombia"],
  "Poland-Baltic": ["Alpine States", "Balkans", "Germany", "Russia West", "Scandinavia", "Ukraine"],
  "Russia East": ["Central Asia", "China East", "China West", "Japan North", "Korea", "Mongolia", "Russia West", "US Northwest"],
  "Russia West": ["Caucasus", "Central Asia", "Poland-Baltic", "Russia East", "Scandinavia", "Ukraine"],
  "Sahel": ["Central Africa", "East Africa", "Egypt", "Gulf of Guinea", "Maghreb", "Nigeria"],
  "Scandinavia": ["Germany", "Poland-Baltic", "Russia West"],
  "Southern Africa": ["Argentina South", "Central Africa", "East Africa", "Madagascar"],
  "Turkey": ["Arabia", "Balkans", "Caucasus", "Iran"],
  "US Midwest": ["Canada Central", "Canada East", "Canada West", "US Northeast", "US Rockies", "US South", "US Southeast", "US Southwest"],
  "US Northeast": ["British Isles", "Canada East", "US Midwest", "US South", "US Southeast"],
  "US Northwest": ["Canada West", "Russia East", "US Pacific", "US Rockies", "US Southwest"],
  "US Pacific": ["Mexico", "US Northwest", "US Rockies", "US Southwest"],
  "US Rockies": ["Canada Central", "Canada West", "US Midwest", "US Northwest", "US Pacific", "US South", "US Southwest"],
  "US South": ["Mexico", "US Midwest", "US Northeast", "US Rockies", "US Southeast", "US Southwest"],
  "US Southeast": ["Cuba", "Iberia", "US Midwest", "US Northeast", "US South"],
  "US Southwest": ["Mexico", "US Midwest", "US Northwest", "US Pacific", "US Rockies", "US South"],
  "Ukraine": ["Alpine States", "Balkans", "Poland-Baltic", "Russia West"],
  "Venezuela": ["Brazil North", "Colombia", "Hispaniola"]
};

const GEO_LAYOUT = {
  "Alpine States": {
    polygon: [[10.3634, 46.4836], [9.1829, 46.4402], [8.9663, 46.0369], [8.3166, 46.1636], [7.2739, 45.7769], [6.5001, 46.4297], [6.0226, 46.273], [6.7366, 47.5418], [8.5226, 47.8308], [10.4021, 47.3025], [10.5445, 47.5664], [12.1414, 47.7031], [12.9326, 47.4676], [12.8841, 48.2891], [13.5959, 48.8772], [12.521, 49.5474], [12.2401, 50.2663], [14.307, 51.1173], [16.2386, 50.6977], [16.1763, 50.4226], [16.7195, 50.2157], [16.8688, 50.474], [17.5546, 50.3621], [18.9096, 49.4358], [19.3207, 49.5716], [19.825, 49.2171], [21.6078, 49.4701], [22.5581, 49.0857], [22.0856, 48.4223], [22.7105, 47.8822], [22.0998, 47.6724], [21.022, 46.3161], [20.2202, 46.1275], [18.4561, 45.7595], [16.3705, 46.8413], [14.6325, 46.4318], [12.3765, 46.7676], [12.1531, 47.1154], [10.4427, 46.8935], [10.3634, 46.4836]],
    label: [17.7927, 48.6238],
    token: [17.7927, 48.6238]
  },
  "Arabia": {
    polygon: [[48.8076, 27.6896], [50.1524, 26.6897], [50.1133, 25.944], [50.8101, 24.7547], [51.0134, 26.007], [51.5891, 25.8011], [51.3896, 24.6274], [51.7944, 24.0198], [54.008, 24.1218], [56.362, 26.3959], [56.3968, 24.9247], [56.8451, 24.2417], [58.7292, 23.5657], [59.8061, 22.3105], [58.488, 20.429], [57.8264, 20.243], [57.6944, 18.9447], [56.6097, 18.5743], [56.2835, 17.8761], [55.2699, 17.6323], [55.2749, 17.2284], [52.3852, 16.3824], [52.1682, 15.5974], [49.5746, 14.7088], [48.6792, 14.0032], [45.6251, 13.2909], [44.9895, 12.6996], [43.483, 12.6368], [42.6049, 15.2133], [42.7793, 16.3479], [42.2709, 17.4747], [41.7544, 17.833], [40.9393, 19.4865], [39.1394, 21.2919], [39.0663, 22.5797], [38.4928, 23.6885], [37.4836, 24.2855], [36.9316, 25.603], [35.1302, 28.0634], [34.6323, 28.0585], [34.956, 29.3566], [34.2654, 31.2194], [36.7395, 36.8175], [39.5226, 36.7161], [42.7791, 37.3853], [44.7727, 37.1704], [45.4206, 35.9775], [46.0763, 35.6774], [46.1518, 35.0933], [45.6485, 34.7481], [45.4167, 33.9678], [46.1094, 33.0173], [47.3347, 32.4692], [47.8492, 31.7092], [47.6853, 30.9849], [48.0047, 30.9851], [48.0146, 30.4525], [48.568, 29.9268], [47.9745, 29.9758], [48.8076, 27.6896]],
    label: [43.9317, 24.9623],
    token: [43.9317, 24.9623]
  },
  "Argentina North": {
    polygon: [[-57.8749, -31.0166], [-58.4954, -34.4315], [-57.2258, -35.288], [-57.3624, -35.9774], [-56.7375, -36.4131], [-57.7492, -38.1839], [-59.2319, -38.7202], [-62.336, -38.8277], [-62.2833, -40.0], [-71.7248, -40.0], [-71.4135, -38.916], [-70.8147, -38.553], [-71.1219, -36.6581], [-70.3648, -36.0051], [-70.388, -35.1697], [-69.8173, -34.1936], [-69.8148, -33.2739], [-70.5351, -31.365], [-69.919, -30.3363], [-70.0135, -29.3679], [-69.6561, -28.4591], [-68.2955, -26.8993], [-68.5948, -26.5069], [-68.4177, -24.5186], [-67.3284, -24.0253], [-67.1067, -22.7359], [-66.2733, -21.8323], [-64.9649, -22.0759], [-64.377, -22.7981], [-63.9868, -21.9936], [-62.8465, -22.035], [-60.8466, -23.8807], [-57.7772, -25.1623], [-57.6337, -25.6037], [-58.6182, -27.1237], [-56.4867, -27.5485], [-55.6958, -27.3878], [-54.7888, -26.6218], [-54.6253, -25.7393], [-54.13, -25.5476], [-53.6283, -26.1249], [-53.6487, -26.9235], [-56.2909, -28.8528], [-57.6251, -30.2163], [-57.8749, -31.0166]],
    label: [-63.9457, -30.6764],
    token: [-63.9457, -30.6764]
  },
  "Argentina South": {
    polygon: [[-62.3305, -40.1726], [-62.146, -40.6769], [-62.7458, -41.0288], [-63.7705, -41.1668], [-64.7321, -40.8027], [-65.118, -41.0643], [-64.9786, -42.058], [-64.3034, -42.359], [-63.7559, -42.0437], [-63.4581, -42.5631], [-65.1818, -43.4954], [-65.5653, -45.0368], [-66.51, -45.0396], [-67.2938, -45.5519], [-67.5805, -46.3018], [-66.5971, -47.0339], [-65.641, -47.2361], [-65.9851, -48.1333], [-67.1662, -48.6973], [-67.8161, -49.8697], [-69.1385, -50.7325], [-68.8156, -51.7711], [-68.15, -52.35], [-71.9148, -52.009], [-72.3294, -51.426], [-72.31, -50.677], [-72.9757, -50.7415], [-73.3281, -50.3788], [-73.4154, -49.3184], [-72.6482, -48.8786], [-72.3312, -48.2442], [-72.4474, -47.7385], [-71.552, -45.5607], [-71.6593, -44.9737], [-71.2228, -44.7842], [-71.7936, -44.2072], [-71.4641, -43.7876], [-71.9154, -43.4086], [-72.1489, -42.2549], [-71.7468, -42.0514], [-71.7248, -40.0], [-62.3305, -40.1726]],
    label: [-69.5465, -45.9313],
    token: [-69.5465, -45.9313]
  },
  "Australia East": {
    polygon: [[134.3931, -12.0424], [135.2985, -12.2486], [136.4925, -11.8572], [136.9516, -12.352], [135.9618, -13.3245], [135.5002, -14.9977], [140.2152, -17.7108], [140.8755, -17.3691], [141.2741, -16.3889], [141.7022, -15.0449], [141.687, -12.4076], [142.5153, -10.6682], [143.9221, -14.5483], [144.5637, -14.1712], [145.3747, -14.985], [146.3875, -18.9583], [148.8484, -20.3912], [149.6783, -22.3425], [150.0774, -22.1228], [150.4829, -22.5561], [150.7273, -22.4024], [150.8996, -23.4622], [152.8552, -25.2675], [153.0929, -27.2603], [153.5695, -28.1101], [153.0896, -30.9236], [152.45, -32.55], [151.7091, -33.0413], [150.3282, -35.6719], [149.9973, -37.4253], [149.4239, -37.7727], [148.3046, -37.8091], [146.3179, -39.0358], [144.877, -38.4174], [145.0322, -37.8962], [143.61, -38.8095], [140.6386, -38.0193], [139.9922, -37.4029], [139.5741, -36.1384], [138.1207, -35.6123], [138.4495, -35.1273], [138.2076, -34.3847], [137.7192, -35.0768], [136.8294, -35.2605], [137.8901, -33.6405], [137.8103, -32.9], [136.3721, -34.0948], [135.989, -34.8901], [135.2082, -34.4787], [135.2392, -33.948], [134.0859, -32.8481], [134.0, -11.923], [134.3931, -12.0424]],
    label: [143.2322, -24.8627],
    token: [143.2322, -24.8627]
  },
  "Australia West": {
    polygon: [[125.0886, -32.7288], [124.2216, -32.9595], [123.6597, -33.8902], [119.8937, -33.9761], [118.025, -35.0647], [116.6251, -35.0251], [115.0268, -34.1965], [115.0486, -33.6234], [115.7147, -33.2596], [115.8016, -32.2051], [115.04, -29.4611], [113.339, -26.1165], [113.7784, -26.549], [113.441, -25.6213], [114.2329, -26.2984], [113.3935, -24.3848], [113.7366, -22.4755], [114.1498, -21.7559], [114.2253, -22.5175], [114.6478, -21.8295], [116.7116, -20.7017], [120.8562, -19.6837], [122.2417, -18.1976], [122.3128, -17.255], [123.0126, -16.4052], [123.4338, -17.2686], [123.8593, -17.069], [123.5032, -16.5965], [123.8171, -16.1113], [124.2583, -16.3279], [124.3797, -15.5671], [125.6858, -14.2307], [126.1251, -14.3473], [127.0659, -13.818], [128.3597, -14.8692], [129.6215, -14.9698], [129.4096, -14.4207], [130.6178, -12.5364], [132.5753, -12.114], [132.5572, -11.603], [131.8247, -11.2738], [132.3572, -11.1285], [134.0, -11.923], [134.0, -32.4879], [131.3263, -31.4958], [126.1487, -32.216], [125.0886, -32.7288]],
    label: [123.8876, -23.3101],
    token: [123.8876, -23.3101]
  },
  "Balkans": {
    polygon: [[19.98, 39.695], [19.4061, 40.2508], [19.3718, 41.8776], [16.0154, 43.5072], [15.1745, 44.2432], [14.9016, 45.0761], [14.2587, 45.2338], [13.9523, 44.8021], [13.657, 45.1369], [13.9376, 45.591], [13.8065, 46.5093], [16.3705, 46.8413], [18.4561, 45.7595], [21.022, 46.3161], [22.0998, 47.6724], [23.1422, 48.0963], [24.8663, 47.7375], [27.5225, 48.4671], [29.1227, 47.8491], [29.0509, 47.5102], [30.0247, 46.4239], [28.863, 46.4379], [28.2336, 45.4883], [29.1497, 45.4649], [29.6265, 45.0354], [28.8379, 44.9139], [28.5581, 43.7075], [27.6739, 42.5779], [27.9967, 42.0074], [26.117, 41.8269], [26.6042, 41.5621], [26.0569, 40.8241], [23.7148, 40.6871], [24.408, 40.125], [23.343, 39.961], [22.814, 40.476], [22.6263, 40.2566], [23.35, 39.19], [22.9731, 38.9709], [24.025, 38.22], [24.04, 37.655], [23.115, 37.92], [23.41, 37.41], [22.775, 37.305], [23.1542, 36.4225], [21.67, 36.845], [21.12, 38.3103], [19.98, 39.695]],
    label: [24.6946, 42.3797],
    token: [24.6946, 42.3797]
  },
  "Benelux": {
    polygon: [[6.2428, 49.9022], [5.8978, 49.4427], [4.286, 49.9075], [2.5136, 51.1485], [3.8303, 51.6205], [4.706, 53.0918], [6.9051, 53.4822], [6.8429, 52.2284], [6.5894, 51.852], [5.9887, 51.8516], [6.2428, 49.9022]],
    label: [4.8102, 51.4832],
    token: [4.8102, 51.4832]
  },
  "Bolivia": {
    polygon: [[-69.5297, -10.9517], [-68.2713, -11.0145], [-66.6469, -9.9313], [-65.3384, -9.762], [-65.4023, -11.5663], [-64.3164, -12.462], [-60.5033, -13.776], [-60.2511, -15.0772], [-60.543, -15.0939], [-60.1584, -16.2583], [-58.2412, -16.2996], [-58.2808, -17.2717], [-57.7346, -17.5525], [-57.4984, -18.1742], [-57.8538, -19.97], [-58.1664, -20.1767], [-58.1835, -19.8684], [-59.115, -19.3569], [-61.7863, -19.6337], [-62.6851, -22.249], [-63.9868, -21.9936], [-64.377, -22.7981], [-64.9649, -22.0759], [-66.2733, -21.8323], [-67.1067, -22.7359], [-67.8282, -22.8729], [-68.7572, -20.3727], [-68.4422, -19.4051], [-69.5904, -17.58], [-68.9596, -16.5007], [-69.3395, -14.9532], [-68.9489, -14.4536], [-68.6651, -12.5613], [-69.5297, -10.9517]],
    label: [-63.6389, -16.4001],
    token: [-63.6389, -16.4001]
  },
  "Brazil North": {
    polygon: [[-60.5033, -13.776], [-64.3164, -12.462], [-65.4023, -11.5663], [-65.3384, -9.762], [-66.6469, -9.9313], [-68.2713, -11.0145], [-70.5487, -11.0091], [-70.4819, -9.4901], [-71.3024, -10.0794], [-72.1849, -10.0536], [-72.563, -9.5202], [-73.2267, -9.4622], [-73.0154, -9.0328], [-73.9872, -7.5238], [-73.7245, -6.9186], [-73.12, -6.6299], [-72.8919, -5.2746], [-70.7948, -4.2513], [-69.8936, -4.2982], [-69.4205, -1.1226], [-70.0207, -0.1852], [-70.0156, 0.5414], [-69.2524, 0.6027], [-69.2186, 0.9857], [-69.8046, 1.0891], [-69.817, 1.7148], [-67.8686, 1.6925], [-67.5378, 2.0372], [-67.065, 1.1301], [-66.3258, 0.7245], [-65.5483, 0.7893], [-63.3688, 2.2009], [-64.27, 2.497], [-64.6287, 4.1485], [-63.0932, 3.7706], [-60.9669, 4.5365], [-60.7336, 5.2003], [-60.2137, 5.2445], [-60.111, 4.575], [-59.538, 3.9588], [-59.9745, 2.7552], [-59.646, 1.7869], [-58.54, 1.2681], [-57.3358, 1.9485], [-55.9957, 1.8177], [-55.9733, 2.5104], [-52.9397, 2.1249], [-51.6578, 4.1562], [-51.3171, 4.2035], [-50.5089, 1.9016], [-49.9741, 1.7365], [-49.9471, 1.0462], [-50.6993, 0.223], [-50.3882, -0.0784], [-48.6206, -0.2355], [-48.5845, -1.2378], [-47.825, -0.5816], [-44.9057, -1.5517], [-44.4176, -2.1378], [-44.5816, -2.6913], [-43.4188, -2.3831], [-41.4727, -2.912], [-39.9787, -2.8731], [-37.2233, -4.8209], [-35.2354, -5.4649], [-34.73, -7.3432], [-35.1282, -8.9964], [-38.6739, -13.0577], [-38.9454, -14.0], [-60.4862, -14.0], [-60.5033, -13.776]],
    label: [-54.3215, -4.3499],
    token: [-54.3215, -4.3499]
  },
  "Brazil South": {
    polygon: [[-53.6505, -33.202], [-53.2096, -32.7277], [-53.788, -32.0472], [-56.976, -30.1097], [-57.6251, -30.2163], [-55.1623, -27.8819], [-53.6487, -26.9235], [-53.6283, -26.1249], [-54.13, -25.5476], [-54.6253, -25.7393], [-54.293, -24.021], [-55.4007, -23.9569], [-55.798, -22.3569], [-57.9372, -22.0902], [-57.8707, -20.7327], [-58.1664, -20.1767], [-57.8538, -19.97], [-57.4984, -18.1742], [-57.7346, -17.5525], [-58.2808, -17.2717], [-58.2412, -16.2996], [-60.1584, -16.2583], [-60.4862, -14.0], [-38.9454, -14.0], [-39.2673, -17.8677], [-39.7608, -19.5991], [-40.7747, -20.9045], [-40.9448, -21.9373], [-41.7542, -22.3707], [-41.9883, -22.9701], [-44.6478, -23.352], [-47.649, -24.8852], [-48.4955, -25.877], [-48.8885, -28.6741], [-50.6969, -30.9845], [-52.2561, -32.2454], [-52.7121, -33.1966], [-53.3737, -33.7684], [-53.6505, -33.202]],
    label: [-50.1387, -23.8983],
    token: [-50.1387, -23.8983]
  },
  "British Isles": {
    polygon: [[-2.945, 53.985], [-3.63, 54.615], [-4.8442, 54.791], [-5.0825, 55.0616], [-4.7191, 55.5085], [-5.048, 55.784], [-5.5864, 55.3111], [-5.645, 56.275], [-6.15, 56.785], [-5.7868, 57.8188], [-5.01, 58.63], [-3.005, 58.635], [-4.0738, 57.553], [-1.9593, 57.6848], [-2.22, 56.87], [-3.119, 55.9738], [-2.085, 55.91], [-1.115, 54.625], [-0.4305, 54.4644], [0.47, 52.93], [1.6815, 52.7395], [1.56, 52.1], [1.0506, 51.8068], [1.4499, 51.2894], [0.5503, 50.7657], [-2.9563, 50.6969], [-3.6174, 50.2284], [-5.7766, 50.1597], [-4.31, 51.21], [-3.4149, 51.426], [-4.9844, 51.5935], [-5.2673, 51.9914], [-4.2223, 52.3014], [-4.77, 52.84], [-4.58, 53.495], [-3.0921, 53.4044], [-2.945, 53.985]],
    label: [-7.8067, 53.5104],
    token: [-7.8067, 53.5104]
  },
  "Canada Central": {
    polygon: [[-99.9019, 67.8057], [-98.4432, 67.7816], [-98.5586, 68.4039], [-97.6695, 68.5786], [-96.1199, 68.2394], [-96.1259, 67.2934], [-95.4894, 68.0907], [-94.685, 68.0638], [-94.2328, 69.069], [-96.4713, 70.0898], [-96.3911, 71.1948], [-95.2088, 71.9205], [-92.8782, 71.3187], [-91.5196, 70.1913], [-92.4069, 69.7], [-90.5471, 69.4977], [-90.5515, 68.475], [-89.2151, 69.2587], [-88.0197, 68.6151], [-88.3175, 67.8734], [-87.3502, 67.1987], [-85.5766, 68.7846], [-85.522, 69.8821], [-82.6226, 69.6583], [-82.0, 69.4281], [-82.0, 66.8917], [-83.3446, 66.4115], [-84.7354, 66.2573], [-85.7694, 66.5583], [-87.3232, 64.7756], [-88.483, 64.099], [-89.9144, 64.0327], [-90.704, 63.6102], [-90.77, 62.9602], [-91.9334, 62.8351], [-94.2415, 60.8987], [-94.6846, 58.9488], [-93.215, 58.7821], [-92.297, 57.0871], [-90.8977, 57.2847], [-85.0118, 55.3026], [-82.2729, 55.1483], [-82.4362, 54.2823], [-82.125, 53.277], [-82.0, 53.0838], [-82.0, 41.8938], [-82.6901, 41.6751], [-83.12, 42.08], [-82.1376, 43.5711], [-82.5509, 45.3475], [-83.5929, 45.8169], [-84.1421, 46.5122], [-84.6049, 46.4396], [-84.8761, 46.9001], [-88.3781, 48.3029], [-89.6, 48.01], [-94.3291, 48.6707], [-94.8176, 49.389], [-95.1561, 49.3843], [-95.1591, 49.0], [-100.0, 49.0001], [-99.9019, 67.8057]],
    label: [-92.0017, 57.8975],
    token: [-92.0017, 57.8975]
  },
  "Canada East": {
    polygon: [[-82.0, 69.4281], [-81.2804, 69.162], [-81.2202, 68.6657], [-81.9644, 68.1325], [-81.2593, 67.5972], [-81.3865, 67.1108], [-82.0, 66.8917], [-82.0, 53.0838], [-81.4008, 52.1579], [-79.9129, 51.2084], [-79.143, 51.5339], [-78.6019, 52.5621], [-79.1242, 54.1414], [-79.8296, 54.6677], [-78.2287, 55.1365], [-76.5414, 56.5342], [-76.6232, 57.2026], [-77.3023, 58.0521], [-78.5169, 58.8046], [-77.3368, 59.8526], [-78.1069, 62.3196], [-77.4107, 62.5505], [-74.6682, 62.1811], [-73.8399, 62.4438], [-71.3737, 61.1372], [-69.5904, 61.0614], [-69.2879, 58.9574], [-68.3745, 58.8011], [-67.6498, 58.2121], [-66.2018, 58.7673], [-64.5835, 60.3356], [-61.3965, 56.9674], [-61.7987, 56.3394], [-59.5696, 55.2041], [-57.3332, 54.6265], [-56.9369, 53.7803], [-55.7563, 53.2704], [-55.6834, 52.1466], [-58.7748, 51.0643], [-60.0331, 50.2428], [-66.3991, 50.229], [-67.2363, 49.5116], [-68.5111, 49.0684], [-71.1046, 46.8217], [-70.2552, 46.9861], [-68.65, 48.3], [-66.5524, 49.1331], [-65.0563, 49.2328], [-64.171, 48.7425], [-65.1154, 48.0709], [-64.4722, 46.2385], [-63.1733, 45.739], [-61.5207, 45.8838], [-60.5181, 47.0079], [-60.4486, 46.2826], [-59.8029, 45.9204], [-64.2466, 44.2655], [-65.3641, 43.5452], [-66.1234, 43.6187], [-66.1617, 44.4651], [-64.4255, 45.292], [-67.1374, 45.1375], [-67.7913, 45.7028], [-67.7905, 47.0664], [-69.2372, 47.4478], [-70.66, 45.46], [-71.5051, 45.0082], [-74.867, 45.0005], [-76.82, 43.6288], [-78.7203, 43.6251], [-79.1717, 43.4663], [-78.9394, 42.8636], [-82.0, 41.8938], [-82.0, 69.4281]],
    label: [-71.0643, 52.3942],
    token: [-71.0643, 52.3942]
  },
  "Canada West": {
    polygon: [[-122.9742, 49.0025], [-125.6246, 50.4166], [-127.4356, 50.8306], [-127.9928, 51.7158], [-127.8503, 52.3296], [-129.1298, 52.7554], [-129.3052, 53.5616], [-130.515, 54.2876], [-130.0078, 55.9158], [-131.7078, 56.5521], [-133.3556, 58.4103], [-135.4758, 59.7878], [-137.4525, 58.905], [-139.039, 60.0], [-140.9978, 60.3064], [-140.986, 69.712], [-136.5036, 68.898], [-134.4146, 69.6274], [-132.9292, 69.5053], [-129.7947, 70.1937], [-129.1077, 69.7793], [-128.3616, 70.0129], [-128.1382, 70.4838], [-125.7563, 69.4806], [-124.4248, 70.1584], [-124.2897, 69.3997], [-122.6835, 69.8555], [-121.4723, 69.7978], [-117.6027, 69.0113], [-115.2469, 68.9059], [-113.8979, 68.3989], [-115.3049, 67.9026], [-113.4973, 67.6881], [-109.9462, 67.981], [-108.8802, 67.3814], [-107.7924, 67.8874], [-108.813, 68.3116], [-108.1672, 68.6539], [-106.15, 68.8], [-104.3379, 68.018], [-103.2211, 68.0978], [-101.4543, 67.6469], [-100.0, 67.7956], [-100.0, 49.0001], [-122.9742, 49.0025]],
    label: [-117.68, 59.6749],
    token: [-117.68, 59.6749]
  },
  "Caucasus": {
    polygon: [[44.9527, 39.3358], [44.4, 40.005], [43.6564, 40.2536], [43.5827, 41.0921], [42.6195, 41.5832], [41.5541, 41.5357], [41.4535, 42.6451], [39.955, 43.435], [45.4703, 42.5028], [47.3733, 41.2197], [47.8157, 41.1514], [48.5844, 41.8089], [49.6189, 40.5729], [50.3928, 40.2566], [49.5692, 40.1761], [48.6344, 38.2704], [48.0107, 38.794], [48.3555, 39.2888], [48.0601, 39.5822], [46.1436, 38.7412], [44.9527, 39.3358]],
    label: [46.5202, 40.9162],
    token: [46.5202, 40.9162]
  },
  "Central Africa": {
    polygon: [[29.42, -5.94], [30.74, -8.34], [28.7349, -8.5266], [28.3723, -11.7936], [29.3415, -12.3607], [29.616, -12.1789], [29.6996, -13.2572], [28.9343, -13.249], [28.1551, -12.2725], [27.3888, -12.1327], [27.1644, -11.6087], [26.5531, -11.9244], [25.7523, -11.785], [25.4181, -11.3309], [24.3145, -11.2628], [24.2572, -10.952], [22.1553, -11.0848], [21.7281, -7.2909], [20.5147, -7.2996], [20.6018, -6.9393], [20.0916, -6.9431], [19.4175, -7.1554], [19.0168, -7.9882], [17.473, -8.0686], [16.3265, -5.8775], [12.3224, -6.1001], [12.1823, -5.7899], [12.9955, -4.7811], [12.6208, -4.438], [11.915, -5.038], [8.798, -1.1113], [9.7952, 3.0734], [8.5003, 4.772], [9.2332, 6.4445], [10.1183, 7.0388], [11.0588, 6.6444], [11.7458, 6.9814], [13.573, 10.7986], [14.4154, 11.5724], [14.5772, 12.0854], [14.2135, 12.802], [14.4958, 12.8594], [14.8934, 12.219], [14.9236, 10.8913], [15.4679, 9.9823], [14.1715, 10.0214], [13.9542, 9.5495], [14.98, 8.7961], [15.2795, 7.4219], [17.9649, 7.8909], [18.911, 8.6309], [18.812, 8.9829], [20.0597, 9.0127], [21.0009, 9.476], [21.7238, 10.5671], [22.8642, 11.1424], [23.5543, 10.0893], [23.459, 8.9543], [25.1149, 7.8251], [27.98, 4.4084], [29.716, 4.6008], [30.8339, 3.5092], [30.7733, 2.3399], [31.1741, 2.2045], [29.8758, 0.5974], [29.0249, -2.8393], [29.42, -5.94]],
    label: [19.5242, 0.0317],
    token: [19.5242, 0.0317]
  },
  "Central America": {
    polygon: [[-77.2426, 7.9353], [-77.7534, 7.7098], [-77.8816, 7.2238], [-78.4292, 8.052], [-78.1821, 8.3192], [-79.1203, 8.9961], [-79.5579, 8.9324], [-80.4807, 8.0903], [-80.0037, 7.5475], [-80.8864, 7.2205], [-81.0595, 7.8179], [-81.5195, 7.7066], [-81.7213, 8.109], [-82.851, 8.0738], [-83.5084, 8.4469], [-83.6326, 9.0514], [-84.7134, 9.9081], [-84.9757, 10.0867], [-85.1109, 9.557], [-85.6608, 9.9333], [-85.6593, 10.7543], [-85.9417, 10.8953], [-85.7125, 11.0884], [-87.6685, 12.9099], [-87.3167, 12.9847], [-87.4894, 13.2975], [-88.4833, 13.164], [-91.2324, 13.9278], [-92.2278, 14.5388], [-91.748, 16.0666], [-90.4645, 16.0696], [-90.4389, 16.4101], [-91.4539, 17.2522], [-91.0023, 17.2547], [-91.0015, 17.8176], [-88.8483, 17.8832], [-88.3, 18.5], [-88.3554, 16.5308], [-88.9306, 15.8873], [-88.1212, 15.6887], [-84.9837, 15.9959], [-83.1472, 14.9958], [-83.8555, 11.3733], [-82.2076, 8.9956], [-80.9473, 8.8585], [-79.5733, 9.6116], [-79.0212, 9.5529], [-77.3534, 8.6705], [-77.2426, 7.9353]],
    label: [-85.4412, 12.6638],
    token: [-85.4412, 12.6638]
  },
  "Central Asia": {
    polygon: [[73.9289, 38.5058], [74.8648, 38.3788], [75.158, 37.133], [71.8463, 36.5099], [71.2623, 36.0744], [71.6131, 35.1532], [70.8818, 33.9889], [69.9305, 34.0201], [70.3236, 33.3585], [69.2625, 32.5019], [69.3178, 31.9014], [66.9389, 31.3049], [66.3815, 30.7389], [66.3465, 29.8879], [62.5499, 29.3186], [60.8742, 29.8292], [61.7812, 30.7358], [61.6993, 31.3795], [60.9419, 31.5481], [60.5361, 32.9813], [60.9637, 33.5288], [60.5284, 33.6764], [61.2108, 35.6501], [61.1231, 36.4916], [60.3776, 36.5274], [59.2348, 37.413], [56.6194, 38.1214], [53.9216, 37.1989], [53.8809, 38.9521], [53.101, 39.2906], [53.3578, 39.9753], [52.694, 40.0336], [52.9153, 40.8765], [53.8581, 40.631], [54.7368, 40.951], [53.7217, 42.1232], [52.9168, 41.8681], [52.8147, 41.1354], [52.5014, 42.7923], [51.3424, 43.133], [50.3056, 44.6098], [51.2785, 44.5149], [51.3169, 45.246], [53.0409, 45.259], [53.0427, 46.853], [51.1919, 47.0487], [49.1012, 46.3993], [48.5932, 46.561], [48.6947, 47.0756], [48.0573, 47.7438], [47.3152, 47.7159], [46.4664, 48.3942], [47.0437, 49.152], [46.7516, 49.356], [47.5495, 50.4547], [48.5778, 49.8748], [48.7024, 50.6051], [50.7666, 51.6928], [52.3287, 51.7187], [55.7169, 50.6217], [56.778, 51.0436], [58.3633, 51.0636], [59.6423, 50.5454], [59.9328, 50.8422], [61.3374, 50.7991], [61.588, 51.2727], [59.9675, 51.9604], [60.9273, 52.4475], [60.74, 52.72], [61.7, 52.98], [60.9781, 53.665], [61.4366, 54.0063], [65.1785, 54.3542], [69.0682, 55.3852], [70.8653, 55.1697], [71.1801, 54.1333], [72.2241, 54.3767], [73.5085, 54.0356], [73.4257, 53.4898], [76.8911, 54.4905], [76.5252, 54.177], [77.8009, 53.4044], [80.0356, 50.8648], [80.5684, 51.3883], [81.946, 50.8122], [83.383, 51.0692], [85.5413, 49.6929], [86.8294, 49.8267], [87.36, 49.215], [86.5988, 48.5492], [85.7682, 48.4558], [85.7205, 47.453], [85.1643, 47.001], [83.1805, 47.33], [82.4589, 45.5397], [79.9661, 44.9175], [80.8662, 43.1804], [80.1801, 42.9201], [80.1194, 42.1239], [78.1872, 41.1853], [76.9045, 41.0665], [76.5264, 40.4279], [75.4678, 40.5621], [73.8222, 39.894], [73.9289, 38.5058]],
    label: [66.4589, 42.3969],
    token: [66.4589, 42.3969]
  },
  "Chile": {
    polygon: [[-69.5904, -17.58], [-68.4422, -19.4051], [-68.7572, -20.3727], [-67.8282, -22.8729], [-67.1067, -22.7359], [-66.9852, -22.9863], [-67.3284, -24.0253], [-68.4177, -24.5186], [-68.5948, -26.5069], [-68.2955, -26.8993], [-69.6561, -28.4591], [-70.0135, -29.3679], [-69.919, -30.3363], [-70.5351, -31.365], [-69.8148, -33.2739], [-69.8173, -34.1936], [-70.388, -35.1697], [-70.3648, -36.0051], [-71.1219, -36.6581], [-70.8147, -38.553], [-71.4135, -38.916], [-71.9157, -40.8323], [-71.7468, -42.0514], [-72.1489, -42.2549], [-71.9154, -43.4086], [-71.4641, -43.7876], [-71.7936, -44.2072], [-71.2228, -44.7842], [-71.6593, -44.9737], [-71.552, -45.5607], [-72.4474, -47.7385], [-72.3312, -48.2442], [-72.6482, -48.8786], [-73.4154, -49.3184], [-73.3281, -50.3788], [-72.9757, -50.7415], [-72.31, -50.677], [-72.3294, -51.426], [-71.9148, -52.009], [-68.5715, -52.2994], [-69.4613, -52.292], [-70.8451, -52.8992], [-71.0063, -53.8333], [-71.4298, -53.8565], [-74.9468, -52.2628], [-75.608, -48.6738], [-75.1828, -47.7119], [-74.1266, -46.9393], [-75.6444, -46.6476], [-74.6922, -45.764], [-74.3517, -44.103], [-73.2404, -44.455], [-72.7178, -42.3834], [-73.3889, -42.1175], [-73.7013, -43.3658], [-74.3319, -43.225], [-73.6771, -39.9422], [-73.2176, -39.2587], [-73.5881, -37.1563], [-73.1667, -37.1238], [-71.4385, -32.4189], [-71.4899, -28.8614], [-70.9051, -27.6404], [-70.0912, -21.3933], [-70.3726, -18.348], [-69.5904, -17.58]],
    label: [-69.8378, -54.0159],
    token: [-69.8378, -54.0159]
  },
  "China Central": {
    polygon: [[95.3069, 44.2413], [96.3494, 42.7256], [100.8459, 42.6638], [104.965, 41.5974], [106.1293, 42.1343], [109.0, 42.5133], [109.0, 21.6013], [107.0434, 21.8119], [106.5673, 22.2182], [106.7254, 22.7943], [105.3292, 23.3521], [104.4769, 22.8192], [101.652, 22.3182], [101.8031, 21.1744], [101.27, 21.2017], [101.15, 21.85], [100.4165, 21.5588], [99.2409, 22.1183], [99.532, 22.949], [98.8987, 23.1427], [98.6603, 24.0633], [97.6047, 23.8974], [97.7246, 25.0836], [98.6718, 25.9187], [98.6827, 27.5088], [97.912, 28.3359], [96.2488, 28.411], [96.5866, 28.831], [96.1177, 29.4528], [95.4048, 29.0317], [95.0, 29.1503], [95.0, 44.2965], [95.3069, 44.2413]],
    label: [102.0, 35.5251],
    token: [102.0, 35.5251]
  },
  "China East": {
    polygon: [[109.2436, 42.5194], [111.8296, 43.7431], [111.3484, 44.4574], [111.8733, 45.1021], [113.4639, 44.8089], [115.9851, 45.7272], [117.4217, 46.6727], [119.6633, 46.6927], [119.7728, 47.0481], [118.0641, 48.0667], [117.2955, 47.6977], [115.7428, 47.7265], [115.4853, 48.1354], [116.6788, 49.8885], [117.8792, 49.511], [119.2885, 50.1429], [119.2794, 50.5829], [120.7382, 51.9641], [120.7258, 52.5162], [120.1771, 52.7539], [121.0031, 53.2514], [123.5715, 53.4588], [125.9463, 52.7928], [127.6574, 49.7603], [129.3978, 49.4406], [130.5823, 48.7297], [130.9873, 47.7901], [132.5067, 47.789], [135.0263, 48.4782], [133.0971, 45.1441], [131.8835, 45.3212], [131.0252, 44.968], [131.1447, 42.93], [130.6339, 42.903], [130.64, 42.395], [129.9943, 42.9854], [129.5967, 42.425], [128.0522, 41.9943], [128.2084, 41.4668], [126.8691, 41.8166], [124.2656, 39.9285], [121.0546, 38.8975], [121.586, 39.3609], [121.3768, 39.7503], [122.1686, 40.4224], [121.6404, 40.9464], [119.0235, 39.2523], [118.0427, 39.2043], [117.5327, 38.7376], [118.0597, 38.0615], [118.8782, 37.8973], [118.9116, 37.4485], [119.7028, 37.1564], [120.8235, 37.8704], [122.3579, 37.4545], [122.52, 36.9306], [121.1042, 36.6513], [119.1512, 34.9099], [120.2275, 34.3603], [121.9081, 31.6922], [121.8919, 30.9494], [121.2643, 30.6763], [122.0921, 29.8325], [121.6844, 28.2255], [121.1257, 28.1357], [118.6569, 24.5474], [115.8907, 22.7829], [114.7638, 22.6681], [114.1525, 22.2238], [113.8068, 22.5483], [113.2411, 22.0514], [110.7855, 21.3971], [110.444, 20.341], [109.8899, 20.2825], [109.6277, 21.0082], [109.8645, 21.3951], [109.0, 21.6013], [109.0, 42.5133], [109.2436, 42.5194]],
    label: [115.406, 36.791],
    token: [115.406, 36.791]
  },
  "China West": {
    polygon: [[80.1801, 42.9201], [80.8662, 43.1804], [79.9661, 44.9175], [82.4589, 45.5397], [83.1805, 47.33], [85.1643, 47.001], [85.7205, 47.453], [85.7682, 48.4558], [86.5988, 48.5492], [87.7513, 49.2972], [88.0138, 48.5995], [90.2808, 47.6935], [90.9708, 46.8881], [90.5858, 45.7197], [90.9455, 45.2861], [93.4807, 44.9755], [95.0, 44.2965], [95.0, 29.1503], [94.566, 29.2774], [92.5031, 27.8969], [91.6967, 27.7717], [90.0158, 28.2964], [88.8142, 27.2993], [88.7303, 28.0869], [88.1204, 27.8765], [85.8233, 28.2036], [82.3275, 30.1153], [81.5258, 30.4227], [81.1113, 30.1835], [78.7389, 31.5159], [78.4584, 32.6182], [79.1761, 32.4838], [79.2089, 32.9944], [78.8111, 33.5062], [78.9123, 34.3219], [77.8375, 35.494], [76.1928, 35.8984], [75.8969, 36.6668], [74.98, 37.42], [74.8648, 38.3788], [73.9289, 38.5058], [73.6754, 39.4312], [73.8222, 39.894], [74.7769, 40.3664], [76.5264, 40.4279], [76.9045, 41.0665], [78.1872, 41.1853], [80.1194, 42.1239], [80.1801, 42.9201]],
    label: [84.9237, 38.1844],
    token: [84.9237, 38.1844]
  },
  "Colombia": {
    polygon: [[-66.8763, 1.2534], [-67.065, 1.1301], [-67.5378, 2.0372], [-67.8686, 1.6925], [-69.817, 1.7148], [-69.8046, 1.0891], [-69.2186, 0.9857], [-69.2524, 0.6027], [-70.0156, 0.5414], [-70.0207, -0.1852], [-69.4205, -1.1226], [-69.8936, -4.2982], [-70.6927, -3.7429], [-70.0477, -2.7252], [-70.8135, -2.2569], [-73.0704, -2.309], [-73.6595, -1.2605], [-75.1066, -0.0572], [-76.2923, 0.416], [-77.425, 0.3957], [-78.9909, 1.6914], [-78.6178, 1.7664], [-78.4276, 2.6296], [-77.9315, 2.6966], [-77.1277, 3.8496], [-77.4963, 4.0876], [-77.3188, 5.8454], [-77.8816, 7.2238], [-77.7534, 7.7098], [-77.2426, 7.9353], [-77.4747, 8.5243], [-75.6746, 9.4432], [-75.4804, 10.619], [-74.9069, 11.083], [-73.4148, 11.227], [-71.7541, 12.4373], [-71.3998, 12.376], [-71.1375, 12.113], [-71.3316, 11.7763], [-71.9739, 11.6087], [-72.9053, 10.4503], [-73.305, 9.152], [-72.7887, 9.085], [-72.4445, 7.4238], [-71.9602, 6.9916], [-70.0933, 6.9604], [-69.3895, 6.0999], [-67.3414, 6.0955], [-67.823, 4.5039], [-67.3032, 3.3185], [-67.8099, 2.8207], [-67.1813, 2.2506], [-66.8763, 1.2534]],
    label: [-72.4865, 3.9686],
    token: [-72.4865, 3.9686]
  },
  "Cuba": {
    polygon: [[-82.2682, 23.1886], [-80.6188, 23.106], [-79.2815, 22.3992], [-78.3474, 22.5122], [-76.5238, 21.2068], [-75.5982, 21.0166], [-75.6711, 20.7351], [-74.178, 20.2846], [-74.9616, 19.9234], [-77.7555, 19.8555], [-77.0851, 20.4134], [-78.1373, 20.7399], [-78.7199, 21.5981], [-82.17, 22.3871], [-81.795, 22.637], [-82.7759, 22.6882], [-84.0522, 21.9106], [-84.9749, 21.896], [-83.7782, 22.7881], [-82.2682, 23.1886]],
    label: [-77.7048, 21.3899],
    token: [-77.7048, 21.3899]
  },
  "East Africa": {
    polygon: [[38.7998, -6.4757], [39.44, -6.84], [39.1865, -8.4855], [40.3166, -10.3171], [37.4713, -11.5688], [34.56, -11.52], [34.28, -10.16], [33.7397, -9.4171], [30.74, -8.34], [29.42, -5.94], [29.0249, -2.8393], [29.8758, 0.5974], [31.1741, 2.2045], [30.7733, 2.3399], [30.8339, 3.5092], [29.716, 4.6008], [27.98, 4.4084], [25.1149, 7.8251], [23.887, 8.6197], [24.5374, 8.9175], [25.0696, 10.2738], [25.7906, 10.4111], [26.752, 9.4669], [28.9666, 9.3982], [29.9966, 10.2909], [30.8378, 9.7072], [31.3529, 9.8102], [32.4001, 11.0806], [32.0739, 11.9733], [32.7434, 12.248], [33.2069, 12.1793], [33.2069, 10.7201], [33.722, 10.3253], [33.9634, 9.4643], [34.2574, 10.6301], [34.7311, 10.9102], [36.2702, 13.5633], [36.8525, 16.9566], [38.4101, 17.9983], [39.2661, 15.9227], [43.3179, 12.3901], [43.2864, 11.9749], [42.7159, 11.7356], [43.1453, 11.462], [42.5588, 10.5726], [43.6788, 9.1836], [46.9483, 7.9969], [47.7894, 8.003], [48.9381, 9.4517], [48.9482, 11.4106], [50.732, 12.0219], [51.1339, 11.7482], [50.5524, 9.1987], [48.5945, 5.3391], [46.5648, 2.8553], [43.136, 0.2922], [41.5851, -1.6832], [40.263, -2.5731], [39.2022, -4.6768], [38.7998, -6.4757]],
    label: [38.8318, 3.1822],
    token: [38.8318, 3.1822]
  },
  "Egypt": {
    polygon: [[36.8662, 22.0], [25.0, 22.0], [25.0, 29.2387], [24.7001, 30.0442], [25.1648, 31.5692], [26.4953, 31.5857], [28.9135, 30.87], [30.9769, 31.5559], [31.688, 31.4296], [31.9604, 30.9336], [32.1925, 31.2603], [33.7734, 30.9675], [34.2654, 31.2194], [34.9226, 29.5013], [34.1545, 27.8233], [33.9214, 27.6487], [33.1368, 28.4176], [32.3205, 29.7604], [34.1046, 26.1423], [35.6924, 23.9267], [35.526, 23.1024], [36.8662, 22.0]],
    label: [29.3695, 26.8955],
    token: [29.3695, 26.8955]
  },
  "France": {
    polygon: [[6.1863, 49.4638], [8.0993, 49.0178], [7.4668, 47.6206], [6.7366, 47.5418], [6.0374, 46.7258], [6.0226, 46.273], [6.5001, 46.4297], [6.8436, 45.9911], [7.0967, 45.3331], [6.75, 45.0285], [7.0076, 44.2548], [7.5496, 44.1279], [7.4352, 43.6938], [6.5292, 43.1289], [4.557, 43.3997], [3.1004, 43.0752], [2.986, 42.473], [1.8268, 42.3434], [-1.5028, 43.034], [-1.9014, 43.4228], [-1.3842, 44.0226], [-1.1938, 46.0149], [-2.9633, 47.5703], [-4.4916, 47.955], [-4.5923, 48.6842], [-3.2958, 48.9017], [-1.6165, 48.6444], [-1.9335, 49.7763], [-0.9895, 49.3474], [1.3388, 50.1272], [1.639, 50.9466], [2.5136, 51.1485], [4.286, 49.9075], [6.1863, 49.4638]],
    label: [2.0992, 46.8951],
    token: [2.0992, 46.8951]
  },
  "Germany": {
    polygon: [[14.1197, 53.757], [14.3533, 53.2482], [14.0745, 52.9813], [15.017, 51.1067], [12.2401, 50.2663], [12.521, 49.5474], [13.5959, 48.8772], [12.8841, 48.2891], [12.9326, 47.4676], [12.1414, 47.7031], [10.5445, 47.5664], [10.4021, 47.3025], [8.5226, 47.8308], [7.4668, 47.6206], [8.0993, 49.0178], [6.6582, 49.202], [6.1863, 49.4638], [6.0431, 50.1281], [5.9887, 51.8516], [6.5894, 51.852], [6.8429, 52.2284], [7.1004, 53.6939], [8.1217, 53.5278], [8.8007, 54.0208], [8.5262, 54.9627], [9.9219, 54.9831], [9.9396, 54.5966], [10.9501, 54.3636], [10.9395, 54.0087], [12.5184, 54.4704], [14.1197, 53.757]],
    label: [10.4324, 51.4312],
    token: [10.4324, 51.4312]
  },
  "Greenland": {
    polygon: [[-46.7638, 82.628], [-43.4064, 83.2252], [-39.8975, 83.1802], [-38.6221, 83.549], [-27.1005, 83.5197], [-20.8454, 82.7267], [-22.6918, 82.3417], [-31.9, 82.2], [-24.8445, 81.787], [-22.9033, 82.0932], [-22.0718, 81.7345], [-23.1696, 81.1527], [-15.7682, 81.9125], [-12.7702, 81.7189], [-12.2086, 81.2915], [-16.85, 80.35], [-20.0462, 80.1771], [-17.7304, 80.1291], [-19.705, 78.7513], [-19.6735, 77.6386], [-18.4729, 76.9857], [-21.6794, 76.6279], [-19.8341, 76.0981], [-19.599, 75.2484], [-20.6682, 75.1559], [-19.3728, 74.2956], [-21.5942, 74.2238], [-20.4345, 73.8171], [-20.7623, 73.4644], [-23.5659, 73.3066], [-22.3131, 72.6293], [-22.2995, 72.1841], [-24.2783, 72.5979], [-24.793, 72.3302], [-22.1328, 71.469], [-21.7536, 70.6637], [-23.536, 70.471], [-25.5434, 71.4309], [-25.2014, 70.7523], [-26.3628, 70.2265], [-22.349, 70.1295], [-27.7474, 68.4705], [-31.7767, 68.1208], [-34.202, 66.6797], [-36.3528, 65.9789], [-39.8122, 65.4585], [-40.669, 64.84], [-40.6828, 64.139], [-41.1887, 63.4825], [-42.8194, 62.6823], [-42.4167, 61.9009], [-43.3784, 60.0977], [-44.7875, 60.0368], [-46.2636, 60.8533], [-48.2629, 60.8584], [-51.6332, 63.6269], [-52.2766, 65.1767], [-53.6617, 66.0996], [-53.3016, 66.8365], [-53.9691, 67.189], [-52.9804, 68.3576], [-51.4754, 68.7296], [-50.8712, 69.9291], [-53.4563, 69.2836], [-54.6834, 69.61], [-54.75, 70.2893], [-54.3588, 70.8213], [-51.3901, 70.5698], [-54.0042, 71.5472], [-55.8347, 71.6544], [-54.7182, 72.5863], [-57.3236, 74.7103], [-58.5968, 75.0986], [-58.5852, 75.5173], [-61.2686, 76.1024], [-68.5044, 76.0614], [-71.4026, 77.0086], [-66.764, 77.376], [-73.297, 78.0442], [-73.1594, 78.4327], [-65.7107, 79.3944], [-65.3239, 79.7581], [-68.023, 80.1172], [-62.2344, 81.3211], [-62.6512, 81.7704], [-57.2074, 82.1907], [-54.1344, 82.1996], [-53.0433, 81.8883], [-50.3906, 82.4388], [-44.523, 81.6607], [-46.9007, 82.1998], [-46.7638, 82.628]],
    label: [-39.2831, 71.8673],
    token: [-39.2831, 71.8673]
  },
  "Gulf of Guinea": {
    polygon: [[-7.9741, 4.3558], [-12.4281, 7.2629], [-12.949, 7.7986], [-13.2465, 8.903], [-14.8396, 10.8766], [-16.6138, 12.1709], [-16.7137, 13.595], [-17.625, 14.7295], [-16.1207, 16.4557], [-14.5773, 16.5983], [-13.4357, 16.0394], [-12.1707, 14.6168], [-11.4562, 12.0768], [-10.1652, 11.8441], [-9.1275, 12.3081], [-8.3763, 11.3936], [-8.6203, 10.8109], [-8.2824, 10.7926], [-8.0299, 10.2065], [-6.8505, 10.139], [-6.2052, 10.5241], [-6.0505, 10.0964], [-5.4043, 10.3707], [-5.2209, 11.7139], [-4.4272, 12.5426], [-4.2804, 13.2284], [-3.1037, 13.5413], [-2.001, 14.559], [-0.5159, 15.1162], [0.3749, 14.9289], [0.4299, 13.9887], [1.0241, 12.8518], [2.1771, 12.625], [2.1545, 11.9401], [2.8486, 12.2356], [3.6112, 11.6602], [3.7054, 10.0632], [2.7238, 8.5068], [2.6917, 6.2588], [-1.9647, 4.7105], [-4.6499, 5.1683], [-7.9741, 4.3558]],
    label: [-0.8754, 10.4628],
    token: [-0.8754, 10.4628]
  },
  "Hispaniola": {
    polygon: [[-71.5873, 19.8849], [-69.9508, 19.648], [-68.3179, 18.6122], [-68.6893, 18.2051], [-69.9529, 18.4283], [-70.5171, 18.1843], [-70.6693, 18.4269], [-71.4002, 17.5986], [-72.3725, 18.215], [-73.9224, 18.031], [-74.458, 18.3425], [-74.3699, 18.6649], [-72.6949, 18.4458], [-72.3349, 18.6684], [-72.7841, 19.4836], [-73.415, 19.6396], [-73.1898, 19.9157], [-71.5873, 19.8849]],
    label: [-70.55, 18.8237],
    token: [-70.55, 18.8237]
  },
  "Iberia": {
    polygon: [[-7.8556, 36.8383], [-8.8989, 36.8688], [-8.84, 38.2662], [-9.5266, 38.7374], [-8.7687, 40.7606], [-8.9844, 42.5928], [-9.3929, 43.0266], [-7.9782, 43.7483], [-1.9014, 43.4228], [-1.5028, 43.034], [0.338, 42.5795], [0.7016, 42.7957], [1.8268, 42.3434], [2.986, 42.473], [3.0395, 41.8921], [2.0918, 41.2261], [0.8105, 41.0147], [-0.2787, 39.31], [0.1113, 38.7385], [-0.6834, 37.6424], [-1.4384, 37.4431], [-2.1465, 36.6741], [-4.3689, 36.6778], [-5.3772, 35.9468], [-5.8664, 36.0298], [-6.5202, 36.9429], [-7.4537, 37.0978], [-7.8556, 36.8383]],
    label: [-4.4983, 39.9395],
    token: [-4.4983, 39.9395]
  },
  "India North": {
    polygon: [[97.4026, 27.8825], [97.052, 27.6991], [97.134, 27.0838], [96.4194, 27.2646], [95.1248, 26.5736], [95.1552, 26.0013], [94.1067, 23.8507], [93.3252, 24.0786], [93.1661, 22.2785], [92.6727, 22.0412], [92.146, 23.6275], [91.8699, 23.6243], [91.7065, 22.9853], [91.159, 23.5035], [92.3762, 24.9767], [89.9207, 25.2697], [89.8325, 25.9651], [88.563, 26.4465], [88.2098, 25.7681], [88.9316, 25.2387], [88.0844, 24.5017], [88.6999, 24.2337], [88.5298, 23.6311], [89.0101, 22.0], [69.2604, 22.0], [69.6449, 22.4508], [68.1766, 23.692], [68.8426, 24.3591], [71.0432, 24.3565], [70.1689, 26.4919], [69.5144, 26.941], [70.6165, 27.9892], [71.7777, 27.9132], [74.4214, 30.9798], [74.4059, 31.6926], [75.2586, 32.2711], [74.4516, 32.7649], [73.7499, 34.3177], [74.2402, 34.7489], [76.8717, 34.6535], [77.8375, 35.494], [78.9123, 34.3219], [78.8111, 33.5062], [79.2089, 32.9944], [79.1761, 32.4838], [78.4584, 32.6182], [78.7389, 31.5159], [81.1113, 30.1835], [80.4767, 29.7299], [80.0884, 28.7945], [83.3042, 27.3645], [84.675, 27.2349], [85.2518, 26.7262], [88.0602, 26.4146], [88.1204, 27.8765], [88.7303, 28.0869], [88.8356, 27.099], [89.7445, 26.7194], [92.0335, 26.8383], [92.1037, 27.4526], [91.6967, 27.7717], [92.5031, 27.8969], [94.566, 29.2774], [95.4048, 29.0317], [96.1177, 29.4528], [96.5866, 28.831], [96.2488, 28.411], [97.3271, 28.2616], [97.4026, 27.8825]],
    label: [76.4328, 28.7175],
    token: [76.4328, 28.7175]
  },
  "India South": {
    polygon: [[88.8888, 21.6906], [86.9757, 21.4956], [87.0332, 20.7433], [86.4994, 20.1516], [85.0603, 19.4786], [82.1928, 17.0166], [82.1912, 16.5567], [80.3249, 15.8992], [80.0251, 15.1364], [80.2863, 13.0063], [79.8625, 12.0562], [79.858, 10.3573], [79.3405, 10.3089], [78.8853, 9.5461], [79.1897, 9.2165], [78.2779, 8.933], [77.5399, 7.9655], [76.593, 8.8993], [74.8648, 12.7419], [74.4439, 14.6172], [73.5342, 15.9907], [72.6305, 21.356], [71.1753, 20.7574], [70.4705, 20.8773], [69.2604, 22.0], [89.0101, 22.0], [88.8888, 21.6906]],
    label: [77.1693, 14.8768],
    token: [77.1693, 14.8768]
  },
  "Iran": {
    polygon: [[48.568, 29.9268], [48.0146, 30.4525], [48.0047, 30.9851], [47.6853, 30.9849], [47.8492, 31.7092], [47.3347, 32.4692], [46.1094, 33.0173], [45.4167, 33.9678], [45.6485, 34.7481], [46.1518, 35.0933], [46.0763, 35.6774], [45.4206, 35.9775], [44.2258, 37.9716], [44.1092, 39.4281], [44.794, 39.713], [45.4577, 38.8741], [46.1436, 38.7412], [48.0601, 39.5822], [48.3555, 39.2888], [48.0107, 38.794], [48.8832, 38.3202], [49.1996, 37.5829], [50.8424, 36.8728], [53.8258, 36.965], [55.5116, 37.9641], [56.6194, 38.1214], [59.2348, 37.413], [60.3776, 36.5274], [61.1231, 36.4916], [61.2108, 35.6501], [60.5284, 33.6764], [60.9637, 33.5288], [60.5361, 32.9813], [60.9419, 31.5481], [61.6993, 31.3795], [61.7812, 30.7358], [60.8742, 29.8292], [61.7719, 28.6993], [62.7278, 28.2596], [62.7554, 27.3789], [63.2339, 27.217], [63.3166, 26.7565], [61.8742, 26.24], [61.4974, 25.0782], [57.3973, 25.7399], [56.9708, 26.9661], [56.4921, 27.1433], [54.7151, 26.4807], [53.4931, 26.8124], [51.5208, 27.8657], [50.115, 30.1478], [49.5769, 29.9857], [48.9413, 30.3171], [48.568, 29.9268]],
    label: [54.1182, 32.326],
    token: [54.1182, 32.326]
  },
  "Italy": {
    polygon: [[10.4427, 46.8935], [12.1531, 47.1154], [12.3765, 46.7676], [13.8065, 46.5093], [13.9376, 45.591], [13.1416, 45.7367], [12.3286, 45.3818], [12.2615, 44.6005], [12.5892, 44.0914], [15.1426, 41.9551], [15.9262, 41.9613], [16.1699, 41.7403], [15.8893, 41.5411], [18.3767, 40.3556], [18.2934, 39.8108], [16.8696, 40.4422], [16.4487, 39.7954], [17.1715, 39.4247], [17.0528, 38.9029], [15.6841, 37.9088], [16.1093, 38.9645], [15.4136, 40.0484], [11.1919, 42.3554], [10.5119, 42.9315], [10.2, 43.92], [8.8889, 44.3663], [7.4352, 43.6938], [7.5496, 44.1279], [7.0076, 44.2548], [6.75, 45.0285], [7.0967, 45.3331], [6.8436, 45.9911], [7.2739, 45.7769], [8.3166, 46.1636], [8.9663, 46.0369], [9.1829, 46.4402], [10.3634, 46.4836], [10.4427, 46.8935]],
    label: [12.6312, 42.5582],
    token: [12.6312, 42.5582]
  },
  "Japan North": {
    polygon: [[145.3208, 44.3847], [145.5431, 43.2621], [144.0597, 42.9884], [143.1839, 41.9952], [141.6115, 42.6788], [141.0673, 41.5846], [139.9551, 41.5696], [139.8175, 42.5638], [140.3121, 43.3333], [141.3805, 43.3888], [141.9676, 45.5515], [143.9102, 44.1741], [144.6134, 43.9609], [145.3208, 44.3847]],
    label: [143.4511, 43.6749],
    token: [143.4511, 43.6749]
  },
  "Japan South": {
    polygon: [[140.9764, 37.1421], [140.5998, 36.344], [140.7741, 35.8429], [140.2533, 35.1381], [138.9755, 34.6676], [137.2176, 34.6063], [135.793, 33.4648], [135.121, 33.8491], [135.0794, 34.5965], [130.9861, 33.8858], [132.0, 33.15], [131.3328, 31.4504], [130.6863, 31.0296], [130.2024, 31.4182], [130.4477, 32.3195], [129.8147, 32.6103], [129.4085, 33.2961], [130.3539, 33.6042], [132.6177, 35.4334], [134.6083, 35.7316], [135.6775, 35.5271], [136.7238, 37.305], [137.3906, 36.8274], [139.1102, 38.0], [140.9623, 38.0], [140.9764, 37.1421]],
    label: [132.7908, 34.4862],
    token: [132.7908, 34.4862]
  },
  "Korea": {
    polygon: [[129.2129, 37.4324], [129.4683, 35.6321], [129.0914, 35.0825], [126.4857, 34.39], [126.5592, 35.6845], [126.1174, 36.7255], [126.8601, 36.8939], [126.1748, 37.7497], [125.6891, 37.94], [125.2753, 37.6691], [124.7122, 38.1083], [125.3866, 39.388], [124.2656, 39.9285], [126.8691, 41.8166], [128.2084, 41.4668], [128.0522, 41.9943], [129.5967, 42.425], [129.9943, 42.9854], [130.78, 42.22], [129.9659, 41.9414], [129.7052, 40.8828], [127.5334, 39.7569], [127.3854, 39.2135], [128.3497, 38.6122], [129.2129, 37.4324]],
    label: [126.67, 38.7572],
    token: [126.67, 38.7572]
  },
  "La Plata": {
    polygon: [[-57.8707, -20.7327], [-57.9372, -22.0902], [-55.798, -22.3569], [-55.4007, -23.9569], [-54.293, -24.021], [-54.7888, -26.6218], [-55.6958, -27.3878], [-56.4867, -27.5485], [-58.6182, -27.1237], [-57.6337, -25.6037], [-57.7772, -25.1623], [-60.8466, -23.8807], [-62.6851, -22.249], [-61.7863, -19.6337], [-59.115, -19.3569], [-58.1835, -19.8684], [-57.8707, -20.7327]],
    label: [-58.6374, -23.1138],
    token: [-58.6374, -23.1138]
  },
  "Madagascar": {
    polygon: [[49.5435, -12.4698], [50.0565, -13.5558], [50.3771, -15.7061], [50.2003, -16.0003], [49.8606, -15.4143], [49.6726, -15.7102], [49.7746, -16.875], [47.0958, -24.9416], [45.4095, -25.6014], [44.0397, -24.9883], [43.3457, -22.7769], [43.4333, -21.3365], [43.8937, -21.1633], [44.4644, -19.4355], [43.9631, -17.4099], [44.4465, -16.2162], [46.3122, -15.78], [47.7051, -14.5943], [47.869, -13.6639], [48.2938, -13.7841], [49.1947, -12.0406], [49.5435, -12.4698]],
    label: [46.6695, -18.6467],
    token: [46.6695, -18.6467]
  },
  "Maghreb": {
    polygon: [[-8.6873, 25.8811], [-11.9694, 25.9334], [-11.9372, 23.3746], [-12.8742, 23.2848], [-13.1188, 22.7712], [-12.9291, 21.3271], [-16.8452, 21.3333], [-17.0634, 20.9998], [-16.9732, 21.8857], [-16.2619, 22.6793], [-15.9826, 23.7234], [-15.0893, 24.5203], [-14.4399, 26.2544], [-12.6188, 28.0382], [-11.6889, 28.1486], [-9.5648, 29.9336], [-9.8147, 31.1777], [-9.3007, 32.5647], [-6.9125, 34.1105], [-5.93, 35.76], [-2.1699, 35.1684], [1.4669, 36.6056], [5.3201, 36.7165], [6.2618, 37.1107], [8.421, 36.9464], [9.51, 37.35], [10.21, 37.23], [10.1806, 36.724], [11.1, 36.9], [10.6, 36.41], [10.9395, 35.699], [10.8078, 34.8335], [10.1496, 34.3308], [10.3397, 33.7857], [10.8568, 33.7687], [11.4888, 33.137], [15.2456, 32.2651], [15.7139, 31.3763], [19.0864, 30.2664], [20.0533, 30.9858], [19.8203, 31.7518], [20.134, 32.2382], [21.543, 32.8432], [22.8958, 32.6386], [23.2368, 32.1915], [24.9211, 31.8994], [25.1648, 31.5692], [24.7001, 30.0442], [25.0, 29.2387], [25.0, 20.003], [23.85, 20.0], [23.8377, 19.5805], [15.8608, 23.4097], [14.1439, 22.4913], [13.5814, 23.0405], [11.9995, 23.4717], [5.6776, 19.6012], [3.1581, 19.0574], [3.1467, 19.6936], [-8.6844, 27.3957], [-8.6873, 25.8811]],
    label: [6.8525, 28.4904],
    token: [6.8525, 28.4904]
  },
  "Mainland SEA": {
    polygon: [[102.3711, 6.1282], [103.3812, 4.855], [103.5024, 2.791], [104.2288, 1.293], [103.5197, 1.2263], [101.3906, 2.7608], [100.1967, 5.3125], [100.0858, 6.4645], [98.5038, 8.3823], [98.3397, 7.7945], [98.15, 8.35], [98.7645, 11.4413], [98.4283, 12.033], [98.5096, 13.1224], [97.1645, 16.9287], [95.3694, 15.7144], [94.1888, 16.0379], [94.5335, 17.2772], [94.3248, 18.2135], [93.541, 19.3665], [93.6633, 19.727], [93.0783, 19.8551], [92.3686, 20.6709], [92.3032, 21.4755], [92.6523, 21.324], [92.6727, 22.0412], [93.1661, 22.2785], [93.3252, 24.0786], [94.1067, 23.8507], [95.1552, 26.0013], [95.1248, 26.5736], [96.4194, 27.2646], [97.134, 27.0838], [97.3271, 28.2616], [97.912, 28.3359], [98.6827, 27.5088], [98.6718, 25.9187], [97.7246, 25.0836], [97.6047, 23.8974], [98.6603, 24.0633], [98.8987, 23.1427], [99.532, 22.949], [99.2409, 22.1183], [100.4165, 21.5588], [101.15, 21.85], [101.27, 21.2017], [101.8031, 21.1744], [101.652, 22.3182], [104.4769, 22.8192], [105.3292, 23.3521], [106.7254, 22.7943], [106.5673, 22.2182], [107.0434, 21.8119], [108.0502, 21.5524], [106.7151, 20.6969], [105.662, 19.0582], [107.362, 16.6975], [108.8771, 15.2767], [109.3353, 13.426], [109.2001, 11.6669], [105.1583, 8.5998], [104.7952, 9.241], [105.0762, 9.9185], [103.4973, 10.6326], [102.5849, 12.1866], [101.6872, 12.6457], [100.8318, 12.6271], [100.9785, 13.4127], [100.0978, 13.4069], [99.2224, 9.2393], [99.8738, 9.2079], [100.4593, 7.4296], [102.3711, 6.1282]],
    label: [103.5374, 14.2389],
    token: [103.5374, 14.2389]
  },
  "Maritime SEA": {
    polygon: [[117.8119, 0.7842], [117.5216, -0.8037], [116.56, -1.4877], [116.1481, -4.0127], [116.0009, -3.657], [114.8648, -4.107], [114.4687, -3.4957], [113.257, -3.1188], [112.0681, -3.4784], [111.7033, -2.9944], [110.2238, -2.934], [110.0709, -1.5929], [109.0919, -0.4595], [108.9527, 0.4154], [109.0691, 1.3419], [109.6633, 2.0065], [109.8302, 1.3381], [110.5141, 0.7731], [111.7975, 0.9044], [112.8598, 1.4978], [113.8059, 1.2175], [114.6214, 1.4307], [115.8655, 4.3066], [117.882, 4.1376], [117.3132, 3.2344], [118.0483, 2.2877], [117.8756, 1.8276], [118.9967, 0.9022], [117.8119, 0.7842]],
    label: [113.2695, -0.1785],
    token: [113.2695, -0.1785]
  },
  "Mexico": {
    polygon: [[-117.1278, 32.5353], [-114.7214, 32.7208], [-111.0236, 31.3347], [-108.2419, 31.3422], [-108.24, 31.7549], [-106.5076, 31.7545], [-105.0374, 30.644], [-103.94, 29.27], [-103.11, 28.97], [-102.48, 29.76], [-101.6624, 29.7793], [-100.9576, 29.3807], [-99.52, 27.54], [-99.02, 26.37], [-97.14, 25.87], [-97.8724, 22.4442], [-97.1893, 20.6354], [-95.9009, 18.828], [-94.4257, 18.1444], [-91.4079, 18.8761], [-90.7719, 19.2841], [-90.2786, 20.9999], [-87.0519, 21.5435], [-86.8459, 20.8499], [-87.6211, 19.6466], [-87.8372, 18.2598], [-88.4901, 18.4868], [-88.8483, 17.8832], [-91.0015, 17.8176], [-91.0023, 17.2547], [-91.4539, 17.2522], [-90.4389, 16.4101], [-90.4645, 16.0696], [-91.748, 16.0666], [-92.2278, 14.5388], [-93.8752, 15.9402], [-94.6917, 16.201], [-96.5574, 15.6535], [-103.501, 18.2923], [-105.493, 19.9468], [-105.7314, 20.4341], [-105.3978, 20.5317], [-105.2658, 21.4221], [-106.0287, 22.7738], [-108.4019, 25.1723], [-109.2602, 25.5806], [-109.2916, 26.4429], [-110.3917, 27.1621], [-110.641, 27.8599], [-111.1789, 27.9412], [-112.2282, 28.9544], [-113.1487, 31.171], [-114.7765, 31.7995], [-114.9367, 31.3935], [-114.6739, 30.1627], [-111.6165, 26.6628], [-110.655, 24.2986], [-110.1729, 24.2655], [-109.4091, 23.3647], [-109.8542, 22.8183], [-112.182, 24.7384], [-112.3007, 26.012], [-115.0551, 27.7227], [-114.5704, 27.7415], [-114.162, 28.5661], [-115.5187, 29.5564], [-117.1278, 32.5353]],
    label: [-102.2502, 23.5994],
    token: [-102.2502, 23.5994]
  },
  "Mongolia": {
    polygon: [[87.7513, 49.2972], [92.2347, 50.8022], [94.1476, 50.4805], [94.8159, 50.0134], [97.2598, 49.7261], [98.2318, 50.4224], [97.8257, 51.011], [98.8615, 52.0474], [102.0652, 51.2599], [102.2559, 50.5106], [103.6765, 50.09], [106.8888, 50.2743], [108.4752, 49.2825], [110.662, 49.1301], [112.8977, 49.5436], [114.3625, 50.2483], [115.4857, 49.8052], [116.6788, 49.8885], [115.4853, 48.1354], [115.7428, 47.7265], [117.2955, 47.6977], [118.0641, 48.0667], [119.7728, 47.0481], [119.6633, 46.6927], [117.4217, 46.6727], [115.9851, 45.7272], [113.4639, 44.8089], [111.8733, 45.1021], [111.3484, 44.4574], [111.8296, 43.7431], [110.4121, 42.8712], [106.1293, 42.1343], [104.965, 41.5974], [100.8459, 42.6638], [96.3494, 42.7256], [95.3069, 44.2413], [93.4807, 44.9755], [90.9455, 45.2861], [90.5858, 45.7197], [90.9708, 46.8881], [90.2808, 47.6935], [88.0138, 48.5995], [87.7513, 49.2972]],
    label: [105.334, 46.8468],
    token: [105.334, 46.8468]
  },
  "New Zealand": {
    polygon: [[169.6678, -43.5553], [171.1251, -42.5128], [172.0972, -40.9561], [172.7986, -40.494], [173.2472, -41.332], [173.9584, -40.9267], [174.2476, -41.3492], [174.2485, -41.77], [172.7112, -43.3723], [173.0801, -43.8533], [171.4529, -44.2425], [170.6167, -45.9089], [169.3323, -46.6412], [166.6769, -46.2199], [166.5091, -45.8527], [167.0464, -45.1109], [169.6678, -43.5553]],
    label: [176.5166, -38.3053],
    token: [176.5166, -38.3053]
  },
  "Nigeria": {
    polygon: [[2.6917, 6.2588], [2.7238, 8.5068], [3.7054, 10.0632], [3.6806, 12.5529], [4.3683, 13.7475], [5.4431, 13.8659], [6.8204, 13.1151], [7.8047, 13.3435], [9.0149, 12.8267], [10.9896, 13.3873], [12.3021, 13.0372], [13.084, 13.5961], [14.5772, 12.0854], [13.573, 10.7986], [11.7458, 6.9814], [11.0588, 6.6444], [10.1183, 7.0388], [9.2332, 6.4445], [8.5003, 4.772], [5.8982, 4.2625], [4.3256, 6.2707], [2.6917, 6.2588]],
    label: [7.8319, 8.9277],
    token: [7.8319, 8.9277]
  },
  "Pakistan": {
    polygon: [[77.8375, 35.494], [76.8717, 34.6535], [74.2402, 34.7489], [73.7499, 34.3177], [74.4516, 32.7649], [75.2586, 32.2711], [74.4059, 31.6926], [74.4214, 30.9798], [71.7777, 27.9132], [70.6165, 27.9892], [69.5144, 26.941], [70.1689, 26.4919], [71.0432, 24.3565], [68.8426, 24.3591], [68.1766, 23.692], [67.4437, 23.9448], [66.3728, 25.4251], [61.4974, 25.0782], [61.8742, 26.24], [63.3166, 26.7565], [63.2339, 27.217], [62.7554, 27.3789], [62.7278, 28.2596], [61.7719, 28.6993], [60.8742, 29.8292], [62.5499, 29.3186], [66.3465, 29.8879], [66.3815, 30.7389], [66.9389, 31.3049], [69.3178, 31.9014], [69.2625, 32.5019], [70.3236, 33.3585], [69.9305, 34.0201], [70.8818, 33.9889], [71.6131, 35.1532], [71.2623, 36.0744], [71.8463, 36.5099], [75.158, 37.133], [75.8969, 36.6668], [76.1928, 35.8984], [77.8375, 35.494]],
    label: [70.0926, 30.3577],
    token: [70.0926, 30.3577]
  },
  "Papua": {
    polygon: [[141.0002, -2.6002], [144.584, -3.8614], [145.8298, -4.8765], [145.9819, -5.4656], [147.6481, -6.0837], [147.8911, -6.614], [146.9709, -6.7217], [147.1919, -7.388], [148.0846, -8.0441], [148.7341, -9.1047], [149.3068, -9.0714], [149.2666, -9.5144], [150.8016, -10.2937], [150.6906, -10.5827], [147.913, -10.1304], [146.0485, -8.0674], [144.7442, -7.6301], [143.2864, -8.2455], [143.4139, -8.9831], [142.6284, -9.3268], [141.0339, -9.1179], [141.0002, -2.6002]],
    label: [144.2261, -6.6678],
    token: [144.2261, -6.6678]
  },
  "Peru": {
    polygon: [[-69.8936, -4.2982], [-70.7948, -4.2513], [-72.8919, -5.2746], [-73.12, -6.6299], [-73.7245, -6.9186], [-73.9872, -7.5238], [-73.0154, -9.0328], [-73.2267, -9.4622], [-72.563, -9.5202], [-72.1849, -10.0536], [-71.3024, -10.0794], [-70.4819, -9.4901], [-70.5487, -11.0091], [-69.5297, -10.9517], [-68.6651, -12.5613], [-68.9489, -14.4536], [-69.3395, -14.9532], [-68.9596, -16.5007], [-69.8584, -18.0927], [-70.3726, -18.348], [-71.3752, -17.7738], [-71.462, -17.3635], [-76.0092, -14.6493], [-76.4235, -13.8232], [-76.2592, -13.535], [-79.7606, -7.1943], [-81.25, -6.1368], [-80.9263, -5.6906], [-81.4109, -4.7368], [-80.3026, -3.4049], [-80.4422, -4.4257], [-79.625, -4.4542], [-79.2053, -4.9591], [-78.6399, -4.5478], [-77.8379, -3.003], [-76.6354, -2.6087], [-75.545, -1.5616], [-75.2337, -0.9114], [-75.3732, -0.152], [-75.1066, -0.0572], [-73.6595, -1.2605], [-73.0704, -2.309], [-70.8135, -2.2569], [-70.0477, -2.7252], [-70.6927, -3.7429], [-69.8936, -4.2982]],
    label: [-75.8747, -9.2475],
    token: [-75.8747, -9.2475]
  },
  "Poland-Baltic": {
    polygon: [[23.9228, 50.4249], [22.5185, 49.4768], [22.7764, 49.0274], [21.6078, 49.4701], [19.825, 49.2171], [19.3207, 49.5716], [18.9096, 49.4358], [17.5546, 50.3621], [16.8688, 50.474], [16.7195, 50.2157], [15.017, 51.1067], [14.0745, 52.9813], [14.3533, 53.2482], [14.1197, 53.757], [17.6228, 54.8515], [18.6963, 54.4387], [22.7311, 54.3275], [22.7578, 54.8566], [21.2684, 55.1905], [21.0904, 56.7839], [21.5819, 57.4119], [22.5243, 57.7534], [23.3185, 57.0062], [24.1207, 57.0257], [24.4289, 58.3834], [23.4266, 58.6128], [23.3398, 59.1872], [25.8642, 59.6111], [27.9811, 59.4754], [28.1317, 59.3008], [27.4201, 58.7246], [27.7167, 57.7919], [27.2882, 57.4745], [27.77, 57.2443], [28.1767, 56.1691], [30.8739, 55.551], [30.7575, 54.8118], [31.7313, 53.794], [32.6936, 53.3514], [31.3052, 53.074], [31.786, 52.1017], [30.9275, 52.0424], [30.5551, 51.3195], [24.5531, 51.8885], [23.5271, 51.5785], [23.9228, 50.4249]],
    label: [26.52, 54.32],
    token: [26.52, 54.32]
  },
  "Russia East": {
    polygon: [[72.423, 66.1727], [73.921, 66.7895], [75.052, 67.7605], [74.4693, 68.329], [74.9358, 68.9892], [73.8424, 69.0715], [73.6019, 69.6276], [74.3998, 70.6317], [73.1011, 71.4472], [74.8908, 72.1212], [74.6593, 72.8323], [75.158, 72.855], [75.6835, 72.3006], [75.289, 71.3356], [76.3591, 71.1529], [75.9031, 71.874], [77.5767, 72.2672], [79.652, 72.3201], [81.5, 71.75], [80.6107, 72.5828], [80.5111, 73.6482], [86.8223, 73.9369], [86.0096, 74.4597], [87.1668, 75.1164], [92.9006, 75.7733], [93.2342, 76.0472], [96.6782, 75.9155], [98.9225, 76.4469], [100.7597, 76.4303], [101.9908, 77.2875], [104.3516, 77.6979], [106.0666, 77.3739], [104.705, 77.1274], [106.9701, 76.9742], [107.24, 76.48], [111.0773, 76.71], [114.1342, 75.8476], [113.8854, 75.3278], [109.4, 74.18], [112.1192, 73.7877], [113.0195, 73.9769], [113.5296, 73.335], [115.5678, 73.7528], [118.7763, 73.5877], [119.02, 73.12], [123.2007, 72.9712], [123.2578, 73.735], [126.9764, 73.5655], [128.5913, 73.0387], [129.0516, 72.3987], [128.46, 71.98], [129.716, 71.193], [131.2886, 70.787], [132.2535, 71.8363], [133.8577, 71.3864], [135.5619, 71.6552], [137.4975, 71.3476], [138.2341, 71.628], [139.8698, 71.4878], [139.1479, 72.4162], [140.4682, 72.8494], [149.5, 72.2], [150.3512, 71.6064], [152.9689, 70.8422], [158.9978, 70.8667], [159.8303, 70.4532], [159.7087, 69.722], [160.9405, 69.4373], [167.8357, 69.5827], [169.5776, 68.6938], [170.8169, 69.0136], [170.0082, 69.6528], [170.4535, 70.097], [175.724, 69.8773], [180.0, 68.9636], [180.0, 64.9797], [178.7072, 64.5349], [177.4113, 64.6082], [179.3703, 62.9826], [179.2283, 62.3041], [177.3643, 62.5219], [173.6801, 61.6526], [170.6985, 60.3362], [170.3308, 59.8818], [168.9005, 60.5735], [166.295, 59.7886], [165.84, 60.16], [164.8767, 59.7316], [163.5393, 59.8687], [162.0173, 58.2433], [162.053, 57.8391], [163.1919, 57.615], [163.0579, 56.1592], [162.1296, 56.1222], [161.7015, 55.2857], [162.1175, 54.8551], [160.3688, 54.3443], [160.0217, 53.2026], [158.5309, 52.9587], [158.2312, 51.9427], [156.7898, 51.011], [155.4337, 55.381], [155.9144, 56.7679], [156.7582, 57.3647], [156.8103, 57.832], [158.3643, 58.0558], [163.6697, 61.1409], [164.4735, 62.5506], [163.2584, 62.4663], [162.6579, 61.6425], [160.1215, 60.5442], [159.3023, 61.774], [156.7207, 61.4344], [154.2181, 59.7582], [155.0437, 59.145], [151.2657, 58.7809], [151.3382, 59.504], [149.7837, 59.6557], [148.5448, 59.1645], [145.4872, 59.3364], [142.1978, 59.04], [135.1262, 54.7296], [136.7017, 54.6035], [137.1934, 53.9773], [138.1647, 53.755], [138.8046, 54.2546], [139.9015, 54.1897], [141.3453, 53.0896], [141.3792, 52.2388], [140.5974, 51.2397], [140.0619, 48.4467], [138.2197, 46.3079], [134.8694, 43.3982], [133.5369, 42.8115], [132.9063, 42.7985], [132.2781, 43.2846], [130.78, 42.22], [130.6339, 42.903], [131.1447, 42.93], [131.2886, 44.1115], [131.0252, 44.968], [131.8835, 45.3212], [133.0971, 45.1441], [135.0263, 48.4782], [132.5067, 47.789], [130.9873, 47.7901], [130.5823, 48.7297], [129.3978, 49.4406], [127.6574, 49.7603], [125.9463, 52.7928], [123.5715, 53.4588], [121.0031, 53.2514], [120.1771, 52.7539], [120.7258, 52.5162], [120.7382, 51.9641], [119.2794, 50.5829], [119.2885, 50.1429], [117.8792, 49.511], [114.3625, 50.2483], [112.8977, 49.5436], [110.662, 49.1301], [108.4752, 49.2825], [106.8888, 50.2743], [103.6765, 50.09], [102.2559, 50.5106], [102.0652, 51.2599], [98.8615, 52.0474], [97.8257, 51.011], [98.2318, 50.4224], [97.2598, 49.7261], [94.8159, 50.0134], [94.1476, 50.4805], [92.2347, 50.8022], [87.36, 49.215], [86.8294, 49.8267], [85.5413, 49.6929], [83.383, 51.0692], [81.946, 50.8122], [80.5684, 51.3883], [80.0356, 50.8648], [77.8009, 53.4044], [76.5252, 54.177], [76.8911, 54.4905], [73.4257, 53.4898], [73.5085, 54.0356], [72.0, 54.3244], [72.0, 66.2272], [72.423, 66.1727]],
    label: [113.3051, 60.0209],
    token: [113.3051, 60.0209]
  },
  "Russia West": {
    polygon: [[48.6454, 45.8063], [47.6759, 45.6415], [46.682, 44.6092], [47.5909, 43.6602], [47.4925, 42.9866], [48.5844, 41.8089], [47.8157, 41.1514], [45.4703, 42.5028], [39.955, 43.435], [36.6755, 45.2447], [37.4032, 45.4045], [38.233, 46.2409], [37.6737, 46.6366], [39.1477, 47.0448], [38.2235, 47.1022], [38.2551, 47.5464], [39.7383, 47.8989], [39.6746, 48.7838], [40.069, 49.6011], [38.0106, 49.9157], [37.3935, 50.384], [36.6262, 50.2256], [35.3561, 50.5772], [35.0222, 51.2076], [34.2248, 51.256], [34.3917, 51.7689], [33.7527, 52.3351], [31.786, 52.1017], [31.3052, 53.074], [32.6936, 53.3514], [31.7313, 53.794], [30.7575, 54.8118], [30.8739, 55.551], [28.1767, 56.1691], [27.77, 57.2443], [27.2882, 57.4745], [27.7167, 57.7919], [27.4201, 58.7246], [28.1317, 59.3008], [27.9811, 59.4754], [29.1177, 60.0281], [28.07, 60.5035], [31.5161, 62.8677], [30.0359, 63.5528], [30.4447, 64.2045], [29.5444, 64.9487], [30.2176, 65.806], [29.0546, 66.9443], [29.9774, 67.6983], [28.4459, 68.3646], [28.5919, 69.0648], [32.1327, 69.906], [33.7755, 69.3014], [36.514, 69.0634], [41.0599, 67.4571], [41.126, 66.7916], [38.383, 65.9995], [33.1844, 66.6325], [34.8148, 65.9001], [34.9439, 64.4144], [37.0127, 63.8498], [37.142, 64.3347], [36.5396, 64.7645], [37.176, 65.1432], [39.5934, 64.5208], [40.4356, 64.7645], [39.7626, 65.4968], [42.0931, 66.4762], [43.9498, 66.0691], [44.5323, 66.7563], [43.6984, 67.3525], [44.188, 67.9505], [43.4528, 68.5708], [46.25, 68.25], [46.8213, 67.69], [45.5552, 67.5665], [45.562, 67.0101], [46.3492, 66.6677], [47.8942, 66.8846], [48.1388, 67.5224], [53.7174, 68.8574], [54.4717, 68.8081], [53.4858, 68.2013], [54.7263, 68.097], [58.802, 68.8808], [59.9414, 68.2784], [61.0778, 68.9407], [60.03, 69.52], [60.55, 69.85], [63.504, 69.5474], [68.5122, 68.0923], [69.1807, 68.6156], [68.1352, 69.3565], [66.9301, 69.4546], [67.2598, 69.9287], [66.6947, 71.029], [68.5401, 71.9345], [69.1964, 72.8434], [72.0, 72.8348], [72.0, 66.8421], [71.28, 66.32], [72.0, 66.2272], [72.0, 54.3244], [71.1801, 54.1333], [70.8653, 55.1697], [69.0682, 55.3852], [65.1785, 54.3542], [61.4366, 54.0063], [60.9781, 53.665], [61.7, 52.98], [60.74, 52.72], [60.9273, 52.4475], [59.9675, 51.9604], [61.588, 51.2727], [61.3374, 50.7991], [59.9328, 50.8422], [59.6423, 50.5454], [58.3633, 51.0636], [56.778, 51.0436], [55.7169, 50.6217], [52.3287, 51.7187], [50.7666, 51.6928], [48.7024, 50.6051], [48.5778, 49.8748], [47.5495, 50.4547], [46.7516, 49.356], [47.0437, 49.152], [46.4664, 48.3942], [47.3152, 47.7159], [48.0573, 47.7438], [48.6947, 47.0756], [48.5932, 46.561], [49.1012, 46.3993], [48.6454, 45.8063]],
    label: [49.9063, 57.0018],
    token: [49.9063, 57.0018]
  },
  "Sahel": {
    polygon: [[23.5543, 10.0893], [22.8642, 11.1424], [22.2311, 10.9719], [21.0009, 9.476], [20.0597, 9.0127], [18.812, 8.9829], [18.911, 8.6309], [17.9649, 7.8909], [15.2795, 7.4219], [14.98, 8.7961], [13.9542, 9.5495], [14.1715, 10.0214], [15.4679, 9.9823], [14.9236, 10.8913], [14.8934, 12.219], [14.4958, 12.8594], [13.9954, 12.4616], [13.3187, 13.5564], [12.3021, 13.0372], [10.9896, 13.3873], [9.0149, 12.8267], [7.8047, 13.3435], [6.8204, 13.1151], [5.4431, 13.8659], [4.3683, 13.7475], [3.6806, 12.5529], [3.6112, 11.6602], [2.8486, 12.2356], [2.1545, 11.9401], [2.1771, 12.625], [1.0241, 12.8518], [0.4299, 13.9887], [0.3749, 14.9289], [-0.5159, 15.1162], [-2.001, 14.559], [-3.1037, 13.5413], [-4.2804, 13.2284], [-4.4272, 12.5426], [-5.2209, 11.7139], [-5.4043, 10.3707], [-6.0505, 10.0964], [-6.2052, 10.5241], [-6.8505, 10.139], [-8.0299, 10.2065], [-8.2824, 10.7926], [-8.6203, 10.8109], [-8.3763, 11.3936], [-9.1275, 12.3081], [-10.1652, 11.8441], [-11.4562, 12.0768], [-12.1707, 14.6168], [-13.4357, 16.0394], [-14.5773, 16.5983], [-16.1207, 16.4557], [-16.4631, 16.135], [-16.1463, 18.1085], [-16.2778, 20.0925], [-17.0634, 20.9998], [-16.8452, 21.3333], [-12.9291, 21.3271], [-13.1188, 22.7712], [-12.8742, 23.2848], [-11.9372, 23.3746], [-11.9694, 25.9334], [-8.6873, 25.8811], [-8.6844, 27.3957], [3.1467, 19.6936], [3.1581, 19.0574], [5.6776, 19.6012], [11.9995, 23.4717], [13.5814, 23.0405], [14.1439, 22.4913], [15.8608, 23.4097], [23.8377, 19.5805], [23.85, 20.0], [25.0, 20.003], [25.0, 22.0], [36.8662, 22.0], [37.4818, 18.6141], [38.4101, 17.9983], [36.8525, 16.9566], [36.2702, 13.5633], [34.7311, 10.9102], [34.2574, 10.6301], [33.9634, 9.4643], [33.722, 10.3253], [33.2069, 10.7201], [33.2069, 12.1793], [32.7434, 12.248], [32.0739, 11.9733], [32.4001, 11.0806], [31.3529, 9.8102], [30.8378, 9.7072], [29.9966, 10.2909], [28.9666, 9.3982], [26.752, 9.4669], [25.7906, 10.4111], [25.0696, 10.2738], [24.5374, 8.9175], [23.887, 8.6197], [24.5674, 8.2292], [23.8058, 8.6663], [23.459, 8.9543], [23.5543, 10.0893]],
    label: [10.6444, 17.3453],
    token: [10.6444, 17.3453]
  },
  "Scandinavia": {
    polygon: [[22.1832, 65.7237], [21.2135, 65.026], [21.3696, 64.4136], [17.8478, 62.7494], [17.1196, 61.3412], [18.7877, 60.0819], [17.8692, 58.9538], [16.8292, 58.7198], [15.8798, 56.1043], [14.6667, 56.2009], [14.1007, 55.4078], [12.9429, 55.3617], [11.0274, 58.8561], [10.3566, 59.4698], [8.382, 58.3133], [7.0487, 58.0789], [5.6658, 58.5882], [4.9921, 61.971], [10.5277, 64.486], [14.7611, 67.8106], [19.184, 69.8174], [23.0237, 70.2021], [24.5465, 71.0305], [28.1655, 71.1855], [31.2934, 70.4538], [30.0054, 70.1863], [31.101, 69.5581], [28.5919, 69.0648], [28.4459, 68.3646], [29.9774, 67.6983], [29.0546, 66.9443], [30.2176, 65.806], [29.5444, 64.9487], [30.4447, 64.2045], [30.0359, 63.5528], [31.5161, 62.8677], [28.07, 60.5035], [22.8697, 59.8464], [21.3222, 60.7202], [21.5449, 61.7053], [21.0592, 62.6074], [21.536, 63.1897], [25.3981, 65.1114], [25.294, 65.5343], [23.9034, 66.0069], [22.1832, 65.7237]],
    label: [13.6354, 63.3219],
    token: [13.6354, 63.3219]
  },
  "Southern Africa": {
    polygon: [[32.5803, -27.4702], [32.2034, -28.7524], [30.0557, -31.1403], [27.4646, -33.227], [25.7806, -33.9446], [22.5742, -33.8641], [20.0713, -34.7951], [18.3774, -34.1365], [17.9252, -32.6113], [18.2479, -32.4291], [18.2218, -31.6616], [15.2105, -27.091], [14.2577, -22.1112], [11.7949, -18.0691], [11.7785, -15.7938], [12.5001, -13.5477], [13.6337, -12.0386], [13.7387, -11.2979], [12.8754, -9.1669], [13.2364, -8.5626], [12.3224, -6.1001], [16.3265, -5.8775], [17.473, -8.0686], [19.0168, -7.9882], [19.4175, -7.1554], [20.0916, -6.9431], [20.6018, -6.9393], [20.5147, -7.2996], [21.7281, -7.2909], [22.1553, -11.0848], [24.2572, -10.952], [24.3145, -11.2628], [25.4181, -11.3309], [25.7523, -11.785], [26.5531, -11.9244], [27.1644, -11.6087], [27.3888, -12.1327], [28.1551, -12.2725], [28.9343, -13.249], [29.6996, -13.2572], [29.616, -12.1789], [29.3415, -12.3607], [28.3723, -11.7936], [28.7349, -8.5266], [30.3461, -8.2383], [32.1919, -8.9304], [33.2314, -9.6767], [33.4857, -10.5256], [33.1143, -11.6072], [33.3064, -12.4358], [32.6882, -13.7129], [34.4596, -14.613], [34.3813, -16.1836], [35.0338, -16.8013], [35.7719, -15.8969], [35.6868, -14.611], [35.268, -13.8878], [34.56, -13.58], [34.28, -12.28], [34.56, -11.52], [37.4713, -11.5688], [40.3166, -10.3171], [40.7755, -14.6918], [40.4773, -15.4063], [39.4526, -16.7209], [37.4111, -17.5864], [34.7864, -19.784], [34.7019, -20.497], [35.5625, -22.09], [35.3718, -23.5354], [35.6075, -23.7066], [35.0407, -24.4784], [32.5746, -25.7273], [32.916, -26.2159], [32.5803, -27.4702]],
    label: [23.8879, -20.1405],
    token: [23.8879, -20.1405]
  },
  "Turkey": {
    polygon: [[44.7727, 37.1704], [42.7791, 37.3853], [39.5226, 36.7161], [36.7395, 36.8175], [36.6854, 36.2597], [36.1498, 35.8215], [35.7821, 36.275], [36.1608, 36.6506], [34.7146, 36.7955], [34.0269, 36.22], [32.5092, 36.1076], [31.6996, 36.6443], [30.6216, 36.6779], [30.3911, 36.263], [29.7, 36.1444], [28.7329, 36.6768], [27.6412, 36.6588], [26.3182, 38.2081], [26.8047, 38.9858], [26.1708, 39.4636], [27.28, 40.42], [28.82, 40.46], [29.24, 41.22], [31.1459, 41.0876], [33.5133, 42.019], [35.1677, 42.0402], [38.3477, 40.9486], [40.3734, 41.0137], [42.6195, 41.5832], [43.5827, 41.0921], [43.6564, 40.2536], [44.794, 39.713], [44.1092, 39.4281], [44.2258, 37.9716], [44.7727, 37.1704]],
    label: [35.4549, 38.6335],
    token: [35.4549, 38.6335]
  },
  "US Midwest": {
    polygon: [[-87.6824, 42.0774], [-87.5236, 41.7104], [-87.425, 41.6447], [-87.1183, 41.6447], [-86.8226, 41.7597], [-86.6199, 41.8912], [-86.483, 42.1157], [-86.357, 42.2526], [-86.2639, 42.4443], [-86.2091, 42.7182], [-86.231, 43.0139], [-86.5268, 43.5945], [-86.4337, 43.8136], [-86.4994, 44.0765], [-86.2694, 44.3448], [-86.2201, 44.5694], [-86.253, 44.6899], [-86.0886, 44.7392], [-86.0667, 44.9035], [-85.8093, 44.9473], [-85.6122, 45.128], [-85.6286, 44.7666], [-85.5245, 44.7501], [-85.3931, 44.9309], [-85.3876, 45.2376], [-85.3054, 45.3143], [-85.0316, 45.3636], [-85.1192, 45.5772], [-84.9385, 45.7579], [-84.7139, 45.7688], [-84.462, 45.6538], [-84.2155, 45.6374], [-84.095, 45.495], [-83.9088, 45.484], [-83.5966, 45.3526], [-83.4871, 45.3581], [-83.3173, 45.1445], [-83.4542, 45.0295], [-83.3228, 44.8816], [-83.2735, 44.7118], [-83.3337, 44.3394], [-83.5364, 44.2463], [-83.5857, 44.0546], [-83.8267, 43.9888], [-83.9581, 43.7588], [-83.9088, 43.6712], [-83.6678, 43.589], [-83.4816, 43.715], [-83.2625, 43.9724], [-82.9175, 44.071], [-82.7477, 43.9943], [-82.6437, 43.8519], [-82.5396, 43.4357], [-82.5232, 43.2275], [-82.4136, 42.9756], [-82.5177, 42.6141], [-82.682, 42.5594], [-82.6875, 42.6908], [-82.797, 42.6525], [-82.923, 42.3512], [-83.1256, 42.2362], [-83.1859, 42.0062], [-83.4378, 41.8145], [-83.4542, 41.7323], [-83.0654, 41.5954], [-82.9339, 41.5133], [-82.8353, 41.5899], [-82.6163, 41.4311], [-82.4793, 41.3818], [-82.0138, 41.5133], [-81.74, 41.4859], [-81.4442, 41.6721], [-81.0115, 41.8528], [-80.5186, 41.9788], [-80.5186, 40.637], [-80.6665, 40.5822], [-80.5953, 40.4726], [-80.6008, 40.3193], [-80.7377, 40.0783], [-80.8308, 39.7113], [-81.2196, 39.3882], [-81.3456, 39.3444], [-81.4552, 39.4101], [-81.5702, 39.2677], [-81.6852, 39.2732], [-81.8112, 39.0815], [-81.7838, 38.9665], [-81.8878, 38.8734], [-82.0357, 39.0267], [-82.2219, 38.7857], [-82.1726, 38.6324], [-82.2931, 38.5776], [-82.3315, 38.4462], [-82.5944, 38.4243], [-82.7313, 38.5612], [-82.8463, 38.5886], [-82.8901, 38.7584], [-83.0325, 38.7255], [-83.1421, 38.6269], [-83.52, 38.7036], [-83.6788, 38.6324], [-83.9033, 38.7693], [-84.2155, 38.8077], [-84.232, 38.8953], [-84.4346, 39.1034], [-84.818, 39.1034], [-84.8947, 39.0596], [-84.8125, 38.7857], [-84.9878, 38.7803], [-85.174, 38.6872], [-85.4314, 38.731], [-85.4205, 38.5338], [-85.5902, 38.4517], [-85.656, 38.3257], [-85.8312, 38.2764], [-85.9243, 38.0245], [-86.0394, 37.9587], [-86.2639, 38.0518], [-86.3022, 38.1669], [-86.5213, 38.0409], [-86.5049, 37.9313], [-86.7294, 37.893], [-86.7952, 37.9916], [-87.0471, 37.893], [-87.1293, 37.7889], [-87.3812, 37.9368], [-87.5127, 37.904], [-87.6003, 37.9752], [-87.6824, 37.904], [-87.9344, 37.893], [-88.0275, 37.7999], [-88.1589, 37.6575], [-88.0658, 37.4822], [-88.4766, 37.3891], [-88.5149, 37.2851], [-88.4218, 37.1536], [-88.5478, 37.0715], [-88.9147, 37.2248], [-89.0298, 37.2139], [-89.1831, 37.0386], [-89.1338, 36.9838], [-89.216, 36.5785], [-89.3639, 36.6224], [-89.4186, 36.4964], [-89.4843, 36.4964], [-89.5391, 36.4964], [-89.5336, 36.2499], [-89.7308, 35.998], [-90.3771, 35.998], [-90.2183, 36.1842], [-90.0649, 36.3047], [-90.1525, 36.4964], [-94.4738, 36.5019], [-94.6162, 36.5019], [-94.6162, 37.0003], [-94.6108, 39.1582], [-94.8244, 39.2075], [-94.9832, 39.443], [-95.1092, 39.5416], [-94.8846, 39.8318], [-95.2078, 39.9085], [-95.3063, 40.0016], [-95.5528, 40.2645], [-95.7664, 40.5877], [-95.8814, 40.7191], [-95.8266, 40.9765], [-95.9252, 41.2011], [-95.9198, 41.453], [-96.095, 41.5406], [-96.1224, 41.6776], [-96.0622, 41.7981], [-96.1279, 41.9733], [-96.2648, 42.039], [-96.4455, 42.4882], [-96.6318, 42.7072], [-96.5441, 42.8551], [-96.5113, 43.0523], [-96.4346, 43.1235], [-96.5606, 43.2221], [-96.5277, 43.3973], [-96.5825, 43.4795], [-96.451, 43.5014], [-96.451, 45.2978], [-96.681, 45.4128], [-96.8563, 45.6045], [-96.5825, 45.8181], [-96.5606, 45.9332], [-96.5989, 46.333], [-96.7194, 46.437], [-96.8015, 46.6561], [-96.7851, 46.9245], [-96.8234, 46.9683], [-96.8563, 47.6091], [-97.0535, 47.9487], [-97.1302, 48.1404], [-97.163, 48.5457], [-97.0973, 48.6826], [-97.2287, 49.0002], [-95.153, 49.0002], [-95.153, 49.3836], [-94.9558, 49.3727], [-94.8244, 49.296], [-94.6929, 48.7757], [-94.5889, 48.7154], [-94.2602, 48.699], [-94.2219, 48.6497], [-93.8385, 48.6278], [-93.7947, 48.5183], [-93.4661, 48.5457], [-93.4661, 48.5895], [-93.2087, 48.6442], [-92.9841, 48.6223], [-92.7267, 48.5402], [-92.6555, 48.4361], [-92.5076, 48.4471], [-92.3707, 48.2225], [-92.305, 48.3156], [-92.053, 48.3594], [-92.0092, 48.2663], [-91.7135, 48.2006], [-91.7135, 48.113], [-91.5656, 48.0418], [-91.2644, 48.0801], [-91.0836, 48.1787], [-90.8372, 48.2389], [-90.7495, 48.0911], [-90.5797, 48.1239], [-90.3771, 48.0911], [-90.1416, 48.113], [-89.8732, 47.987], [-89.6158, 48.0089], [-89.6377, 47.9541], [-89.9718, 47.8282], [-90.4373, 47.7296], [-90.7386, 47.6255], [-91.1712, 47.3681], [-91.3575, 47.2093], [-91.6423, 47.0285], [-92.0914, 46.7876], [-92.0147, 46.7054], [-91.7901, 46.6944], [-91.0946, 46.8642], [-90.8372, 46.9573], [-90.7495, 46.8861], [-90.8864, 46.7547], [-90.5578, 46.5849], [-90.4154, 46.5685], [-90.0266, 46.6725], [-89.8513, 46.793], [-89.4131, 46.8423], [-89.1283, 46.9902], [-88.9969, 46.9957], [-88.8874, 47.0997], [-88.5752, 47.2476], [-88.4163, 47.3736], [-88.1808, 47.4557], [-87.9563, 47.3845], [-88.3506, 47.0778], [-88.4437, 46.9738], [-88.4383, 46.7876], [-88.2466, 46.93], [-87.9015, 46.908], [-87.6331, 46.8095], [-87.3922, 46.5356], [-87.2607, 46.4863], [-87.0088, 46.5301], [-86.9485, 46.4699], [-86.6966, 46.437], [-86.1598, 46.6671], [-85.8805, 46.689], [-85.5081, 46.678], [-85.2562, 46.7547], [-85.0645, 46.7602], [-85.0261, 46.4808], [-84.829, 46.4425], [-84.6318, 46.4863], [-84.5496, 46.4206], [-84.4182, 46.5028], [-84.1279, 46.5301], [-84.1224, 46.1796], [-83.991, 46.0317], [-83.7938, 45.9934], [-83.7719, 46.092], [-83.5802, 46.092], [-83.4761, 45.9879], [-83.5638, 45.9112], [-84.1115, 45.977], [-84.3744, 45.9332], [-84.6592, 46.0536], [-84.7413, 45.9441], [-84.703, 45.851], [-84.829, 45.8729], [-85.0152, 46.0098], [-85.3383, 46.092], [-85.5026, 46.0975], [-85.6614, 45.966], [-85.9243, 45.9332], [-86.2091, 45.9605], [-86.3242, 45.9058], [-86.3515, 45.7962], [-86.6637, 45.7031], [-86.6473, 45.8346], [-86.7842, 45.862], [-86.839, 45.725], [-87.069, 45.7196], [-87.1731, 45.6593], [-87.3264, 45.4238], [-87.6112, 45.1226], [-87.5893, 45.0952], [-87.6277, 44.9747], [-87.8194, 44.9528], [-87.9837, 44.7227], [-88.0439, 44.5639], [-87.9289, 44.5365], [-87.7755, 44.6406], [-87.6112, 44.8378], [-87.4031, 44.9144], [-87.2388, 45.1664], [-87.0307, 45.2212], [-87.0471, 45.0897], [-87.1895, 44.9692], [-87.4688, 44.553], [-87.5455, 44.3229], [-87.54, 44.1586], [-87.6441, 44.1039], [-87.7372, 43.8793], [-87.7043, 43.6876], [-87.792, 43.5616], [-87.9125, 43.2495], [-87.8851, 43.003], [-87.7646, 42.7839], [-87.8029, 42.4936], [-87.8358, 42.3019], [-87.6824, 42.0774]],
    label: [-92.2003, 42.699],
    token: [-92.2003, 42.699]
  },
  "US Northeast": {
    polygon: [[-75.5894, 39.4594], [-75.4415, 39.3115], [-75.4031, 39.0651], [-75.1895, 38.8077], [-75.091, 38.7967], [-75.0471, 38.4517], [-75.2443, 38.0299], [-75.3977, 38.0135], [-75.6715, 37.9532], [-75.8851, 37.9094], [-75.8796, 38.0737], [-75.9618, 38.1395], [-75.8468, 38.2107], [-76.0001, 38.375], [-76.0494, 38.3038], [-76.2575, 38.3202], [-76.3287, 38.5009], [-76.263, 38.5009], [-76.2575, 38.7365], [-76.1918, 38.8296], [-76.2794, 39.1472], [-76.1699, 39.3334], [-76.0001, 39.3663], [-75.9727, 39.558], [-76.0987, 39.5361], [-76.1042, 39.4375], [-76.3671, 39.3115], [-76.4438, 39.1965], [-76.4602, 38.9062], [-76.5588, 38.7693], [-76.515, 38.5393], [-76.3835, 38.3805], [-76.3999, 38.26], [-76.3178, 38.1395], [-76.3616, 38.0573], [-76.5916, 38.2161], [-76.9202, 38.2928], [-77.0188, 38.4462], [-77.205, 38.3585], [-77.2762, 38.479], [-77.1284, 38.6324], [-77.0407, 38.7912], [-76.9093, 38.8953], [-77.0353, 38.9939], [-77.1174, 38.9336], [-77.2489, 39.0267], [-77.457, 39.076], [-77.457, 39.2239], [-77.5665, 39.3061], [-77.7199, 39.3225], [-77.8349, 39.6018], [-78.0047, 39.6018], [-78.1745, 39.6949], [-78.2676, 39.6182], [-78.4319, 39.6237], [-78.4702, 39.5142], [-78.766, 39.5854], [-78.9631, 39.4375], [-79.0946, 39.4704], [-79.2918, 39.3006], [-79.4889, 39.2075], [-79.478, 39.7223], [-80.5186, 39.7223], [-80.5186, 40.637], [-80.5186, 41.9788], [-80.3324, 42.0336], [-79.7628, 42.2691], [-79.1494, 42.5539], [-79.0508, 42.6908], [-78.8536, 42.7839], [-78.9303, 42.9537], [-79.0124, 42.9866], [-79.0727, 43.2604], [-78.4867, 43.3754], [-77.9663, 43.3699], [-77.7582, 43.3426], [-77.5337, 43.233], [-77.3913, 43.2768], [-76.9586, 43.2714], [-76.6957, 43.3426], [-76.4164, 43.5233], [-76.2356, 43.5288], [-76.2302, 43.8026], [-76.137, 43.9615], [-76.3616, 44.071], [-76.3123, 44.197], [-75.9125, 44.3667], [-75.7646, 44.5146], [-75.2826, 44.8487], [-74.8281, 45.0185], [-74.1489, 44.9911], [-73.3438, 45.013], [-72.3087, 45.0021], [-71.5036, 45.013], [-71.3612, 45.2704], [-71.1311, 45.2431], [-71.0818, 45.3033], [-70.6492, 45.4402], [-70.7204, 45.5114], [-70.556, 45.6648], [-70.3863, 45.736], [-70.4191, 45.7962], [-70.2603, 45.8893], [-70.3096, 46.0646], [-70.211, 46.3275], [-70.0576, 46.4151], [-69.9974, 46.6944], [-69.2251, 47.4612], [-69.0444, 47.4284], [-69.0335, 47.2421], [-68.902, 47.1764], [-68.5789, 47.286], [-68.3762, 47.286], [-68.2338, 47.3572], [-67.9545, 47.1983], [-67.7902, 47.0669], [-67.7792, 45.9441], [-67.8011, 45.6757], [-67.4561, 45.6045], [-67.5054, 45.4895], [-67.4178, 45.38], [-67.489, 45.2814], [-67.3466, 45.128], [-67.1603, 45.1609], [-66.9796, 44.8049], [-67.1877, 44.6461], [-67.3082, 44.7063], [-67.4068, 44.5968], [-67.5492, 44.6242], [-67.5656, 44.5311], [-67.7519, 44.542], [-68.0476, 44.3284], [-68.1188, 44.4763], [-68.2229, 44.4872], [-68.1736, 44.3284], [-68.4036, 44.2517], [-68.4584, 44.3777], [-68.5679, 44.312], [-68.8253, 44.312], [-68.8308, 44.4599], [-68.9842, 44.427], [-68.9568, 44.3229], [-69.0992, 44.1039], [-69.0718, 44.0436], [-69.258, 43.9231], [-69.4442, 43.9669], [-69.5538, 43.841], [-69.7071, 43.8245], [-69.8331, 43.7205], [-69.9864, 43.7424], [-70.0303, 43.8519], [-70.2548, 43.6767], [-70.1946, 43.5671], [-70.3589, 43.5288], [-70.3698, 43.4357], [-70.556, 43.3207], [-70.7039, 43.0578], [-70.8189, 42.8715], [-70.7806, 42.6963], [-70.8244, 42.5539], [-70.9832, 42.4224], [-70.9887, 42.2691], [-70.7696, 42.2472], [-70.6382, 42.0883], [-70.6601, 41.9624], [-70.5506, 41.9295], [-70.5396, 41.8145], [-70.2603, 41.7159], [-69.9371, 41.809], [-70.0083, 41.6721], [-70.4848, 41.5516], [-70.6601, 41.5461], [-70.7642, 41.6392], [-70.9285, 41.6118], [-70.934, 41.5406], [-71.1202, 41.4968], [-71.3173, 41.4749], [-71.1968, 41.6776], [-71.2242, 41.7104], [-71.3447, 41.7269], [-71.4488, 41.579], [-71.4816, 41.3709], [-71.8596, 41.3216], [-71.9472, 41.338], [-72.3853, 41.2613], [-72.9057, 41.2832], [-73.1302, 41.1463], [-73.3712, 41.1025], [-73.656, 40.9875], [-73.2288, 40.9053], [-73.1412, 40.9656], [-72.7742, 40.9656], [-72.588, 40.9984], [-72.2813, 41.1573], [-72.2594, 41.0422], [-72.1005, 40.993], [-72.4675, 40.8451], [-73.2397, 40.626], [-73.5629, 40.5822], [-73.7765, 40.5931], [-73.9353, 40.5438], [-74.0229, 40.7082], [-74.1873, 40.6424], [-74.2749, 40.4891], [-74.001, 40.4124], [-73.9791, 40.2974], [-74.0996, 39.7606], [-74.4118, 39.3608], [-74.6145, 39.2458], [-74.7952, 38.9939], [-74.8883, 39.1582], [-75.1786, 39.2403], [-75.5346, 39.4594], [-75.5565, 39.6073], [-75.562, 39.6292], [-75.5072, 39.684], [-75.6113, 39.6182], [-75.5894, 39.4594]],
    label: [-74.9517, 42.6223],
    token: [-74.9517, 42.6223]
  },
  "US Northwest": {
    polygon: [[-104.053, 43.003], [-104.053, 41.0039], [-105.729, 40.9984], [-107.9197, 41.0039], [-109.048, 40.9984], [-111.0471, 40.9984], [-111.0471, 42.0007], [-112.1644, 41.9952], [-114.043, 41.9952], [-117.0279, 42.0007], [-117.0279, 43.83], [-116.8964, 44.1586], [-116.9786, 44.2408], [-117.1703, 44.2572], [-117.2415, 44.3941], [-117.0388, 44.7501], [-116.9348, 44.783], [-116.8307, 44.9309], [-116.8471, 45.024], [-116.7321, 45.1445], [-116.6719, 45.3197], [-116.4638, 45.6155], [-116.5459, 45.7524], [-116.7814, 45.8236], [-116.9183, 45.9934], [-116.9238, 46.1687], [-117.0553, 46.3439], [-117.0388, 46.4261], [-117.0443, 47.7625], [-117.0334, 49.0002], [-116.0475, 49.0002], [-111.5016, 48.9948], [-109.4533, 49.0002], [-104.0475, 49.0002], [-104.0421, 47.861], [-104.0475, 45.9441], [-104.0421, 44.9966], [-104.0585, 44.9966], [-104.053, 43.003]],
    label: [-110.4434, 45.0103],
    token: [-110.4434, 45.0103]
  },
  "US Pacific": {
    polygon: [[-120.0019, 38.9993], [-118.7148, 38.1011], [-117.4989, 37.2193], [-116.5404, 36.5019], [-115.8503, 35.9706], [-114.6345, 35.0012], [-114.6345, 34.8752], [-114.4702, 34.7109], [-114.3332, 34.448], [-114.1361, 34.3056], [-114.2566, 34.1742], [-114.4154, 34.1084], [-114.5359, 33.9332], [-114.4975, 33.6977], [-114.5249, 33.5498], [-114.7276, 33.4074], [-114.6618, 33.035], [-114.5249, 33.0295], [-114.4702, 32.8433], [-114.5249, 32.7556], [-114.7221, 32.7173], [-116.0475, 32.6242], [-117.1265, 32.5366], [-117.247, 32.668], [-117.2524, 32.8761], [-117.3291, 33.1226], [-117.4715, 33.2979], [-117.7837, 33.5388], [-118.1835, 33.7634], [-118.2602, 33.7031], [-118.4135, 33.7415], [-118.3916, 33.8401], [-118.5669, 34.0427], [-118.8024, 33.9989], [-119.2187, 34.1468], [-119.2789, 34.2673], [-119.5582, 34.4151], [-119.8759, 34.4097], [-120.1388, 34.4754], [-120.4729, 34.448], [-120.6481, 34.5795], [-120.6098, 34.8588], [-120.67, 34.9026], [-120.6317, 35.0998], [-120.8946, 35.2476], [-120.9056, 35.4503], [-121.0041, 35.4612], [-121.1684, 35.6365], [-121.2835, 35.6748], [-121.3328, 35.7844], [-121.7161, 36.1952], [-121.8969, 36.3156], [-121.9352, 36.6388], [-121.8585, 36.6114], [-121.7873, 36.8031], [-121.9297, 36.9784], [-122.105, 36.9564], [-122.335, 37.1153], [-122.4172, 37.2412], [-122.4008, 37.3617], [-122.5158, 37.5206], [-122.5158, 37.7835], [-122.3296, 37.7835], [-122.4062, 38.1504], [-122.4884, 38.1121], [-122.5048, 37.9313], [-122.702, 37.893], [-122.9375, 38.0299], [-122.9758, 38.2654], [-123.1292, 38.4517], [-123.3318, 38.5667], [-123.4414, 38.6981], [-123.7371, 38.9555], [-123.6878, 39.0322], [-123.8248, 39.3663], [-123.7645, 39.5525], [-123.8521, 39.8318], [-124.1096, 40.1057], [-124.3615, 40.259], [-124.4108, 40.4398], [-124.1589, 40.8779], [-124.1096, 41.0258], [-124.1589, 41.1408], [-124.0658, 41.4421], [-124.1479, 41.7159], [-124.2574, 41.7816], [-124.2136, 42.0007], [-124.356, 42.1157], [-124.4327, 42.4389], [-124.4163, 42.6634], [-124.5532, 42.8387], [-124.4546, 43.003], [-124.3834, 43.2714], [-124.2355, 43.5562], [-124.1698, 43.8081], [-124.0603, 44.657], [-124.0767, 44.772], [-123.9781, 45.1445], [-123.9398, 45.6593], [-123.9946, 45.9441], [-123.9453, 46.1139], [-123.5454, 46.2618], [-123.7262, 46.3001], [-123.8741, 46.2399], [-124.0658, 46.3275], [-124.0274, 46.4644], [-123.896, 46.5356], [-124.0986, 46.7437], [-124.2355, 47.286], [-124.3177, 47.3572], [-124.4272, 47.7405], [-124.6244, 47.8884], [-124.7066, 48.1842], [-124.597, 48.3813], [-124.3944, 48.2882], [-123.9836, 48.1623], [-123.7043, 48.1677], [-123.4249, 48.1185], [-123.1621, 48.1677], [-123.0361, 48.0801], [-122.8006, 48.0856], [-122.6363, 47.8665], [-122.5158, 47.8829], [-122.4939, 47.5872], [-122.4227, 47.3188], [-122.3241, 47.3462], [-122.4227, 47.5762], [-122.3953, 47.8008], [-122.231, 48.0308], [-122.3624, 48.1239], [-122.3734, 48.2882], [-122.472, 48.469], [-122.4227, 48.6004], [-122.4884, 48.7538], [-122.6472, 48.7757], [-122.7951, 48.8907], [-122.7568, 49.0002], [-117.0334, 49.0002], [-117.0443, 47.7625], [-117.0388, 46.4261], [-117.0553, 46.3439], [-116.9238, 46.1687], [-116.9183, 45.9934], [-116.7814, 45.8236], [-116.5459, 45.7524], [-116.4638, 45.6155], [-116.6719, 45.3197], [-116.7321, 45.1445], [-116.8471, 45.024], [-116.8307, 44.9309], [-116.9348, 44.783], [-117.0388, 44.7501], [-117.2415, 44.3941], [-117.1703, 44.2572], [-116.9786, 44.2408], [-116.8964, 44.1586], [-117.0279, 43.83], [-117.0279, 42.0007], [-118.6983, 41.9898], [-120.0019, 41.9952], [-119.9964, 40.2645], [-120.0019, 38.9993]],
    label: [-122.1412, 40.6589],
    token: [-122.1412, 40.6589]
  },
  "US Rockies": {
    polygon: [[-94.43, 35.3955], [-94.4848, 33.6374], [-94.8682, 33.747], [-94.9668, 33.862], [-95.2242, 33.9606], [-95.2899, 33.8729], [-95.5473, 33.8784], [-95.6021, 33.9332], [-95.8376, 33.8346], [-95.9362, 33.8894], [-96.1498, 33.8401], [-96.347, 33.6867], [-96.4236, 33.7743], [-96.6318, 33.8455], [-96.8508, 33.8455], [-96.922, 33.9606], [-97.174, 33.736], [-97.2561, 33.862], [-97.3711, 33.8236], [-97.4588, 33.9058], [-97.6943, 33.9825], [-97.8695, 33.851], [-97.9462, 33.9879], [-98.0886, 34.0044], [-98.1708, 34.1139], [-98.3625, 34.1577], [-98.4884, 34.0646], [-98.5706, 34.1468], [-98.7678, 34.1358], [-98.9868, 34.2235], [-99.1895, 34.2125], [-99.2607, 34.4042], [-99.5784, 34.4151], [-99.6988, 34.3823], [-99.9234, 34.574], [-100.0001, 34.563], [-100.0001, 36.5019], [-101.8129, 36.5019], [-103.0014, 36.5019], [-103.0014, 37.0003], [-104.3378, 36.9948], [-106.8682, 36.9948], [-107.4213, 37.0003], [-109.0425, 37.0003], [-109.0425, 38.1669], [-109.0589, 38.2764], [-109.0535, 39.1253], [-109.048, 40.9984], [-107.9197, 41.0039], [-105.729, 40.9984], [-104.053, 41.0039], [-104.053, 43.003], [-104.0585, 44.9966], [-104.0421, 44.9966], [-104.0475, 45.9441], [-104.0421, 47.861], [-104.0475, 49.0002], [-97.2287, 49.0002], [-97.0973, 48.6826], [-97.163, 48.5457], [-97.1302, 48.1404], [-97.0535, 47.9487], [-96.8563, 47.6091], [-96.8234, 46.9683], [-96.7851, 46.9245], [-96.8015, 46.6561], [-96.7194, 46.437], [-96.5989, 46.333], [-96.5606, 45.9332], [-96.5825, 45.8181], [-96.8563, 45.6045], [-96.681, 45.4128], [-96.451, 45.2978], [-96.451, 43.5014], [-96.5825, 43.4795], [-96.5277, 43.3973], [-96.5606, 43.2221], [-96.4346, 43.1235], [-96.5113, 43.0523], [-96.5441, 42.8551], [-96.6318, 42.7072], [-96.4455, 42.4882], [-96.2648, 42.039], [-96.1279, 41.9733], [-96.0622, 41.7981], [-96.1224, 41.6776], [-96.095, 41.5406], [-95.9198, 41.453], [-95.9252, 41.2011], [-95.8266, 40.9765], [-95.8814, 40.7191], [-95.7664, 40.5877], [-95.5528, 40.2645], [-95.3063, 40.0016], [-95.2078, 39.9085], [-94.8846, 39.8318], [-95.1092, 39.5416], [-94.9832, 39.443], [-94.8244, 39.2075], [-94.6108, 39.1582], [-94.6162, 37.0003], [-94.6162, 36.5019], [-94.43, 35.3955]],
    label: [-99.9878, 41.327],
    token: [-99.9878, 41.327]
  },
  "US South": {
    polygon: [[-91.0727, 32.8871], [-91.1439, 32.8433], [-91.1548, 32.6406], [-91.0069, 32.5146], [-90.985, 32.2189], [-91.1055, 31.9889], [-91.341, 31.8465], [-91.4013, 31.6219], [-91.4999, 31.6438], [-91.5163, 31.2769], [-91.6368, 31.2659], [-91.5656, 31.0687], [-91.6368, 30.9975], [-89.7472, 30.9975], [-89.8458, 30.6689], [-89.6815, 30.4498], [-89.6432, 30.2855], [-89.5227, 30.1815], [-89.8184, 30.0445], [-89.8404, 29.946], [-89.5994, 29.8802], [-89.4953, 30.0391], [-89.2872, 29.8802], [-89.3036, 29.7543], [-89.4241, 29.6995], [-89.6487, 29.7488], [-89.6213, 29.6557], [-89.698, 29.5133], [-89.5063, 29.3873], [-89.1995, 29.349], [-89.09, 29.2011], [-89.0024, 29.1792], [-89.1612, 29.0094], [-89.3365, 29.0423], [-89.4843, 29.2175], [-89.8513, 29.3106], [-89.8513, 29.4804], [-90.032, 29.4257], [-90.0211, 29.2833], [-90.1032, 29.1518], [-90.2347, 29.1299], [-90.3333, 29.2778], [-90.5633, 29.2833], [-90.6455, 29.1299], [-90.7988, 29.0861], [-90.9631, 29.1792], [-91.0946, 29.1901], [-91.2205, 29.4366], [-91.4451, 29.5461], [-91.5327, 29.5297], [-91.6204, 29.7378], [-91.8832, 29.7105], [-91.8887, 29.8364], [-92.1461, 29.7159], [-92.1133, 29.6228], [-92.3105, 29.5352], [-92.6172, 29.579], [-92.9732, 29.7159], [-93.2251, 29.7762], [-93.7673, 29.7269], [-93.8385, 29.6885], [-94.0028, 29.6831], [-94.5231, 29.5461], [-94.7094, 29.6228], [-94.7422, 29.7871], [-94.8737, 29.6721], [-94.9668, 29.6995], [-95.0161, 29.5571], [-94.912, 29.4969], [-94.8956, 29.3106], [-95.0818, 29.1135], [-95.383, 28.867], [-95.9855, 28.6041], [-96.0457, 28.6479], [-96.2265, 28.5822], [-96.2319, 28.6425], [-96.4784, 28.5986], [-96.5934, 28.7246], [-96.6646, 28.6972], [-96.4017, 28.4398], [-96.5934, 28.3577], [-96.7742, 28.4069], [-96.8015, 28.2262], [-97.0261, 28.04], [-97.2561, 27.6949], [-97.404, 27.3335], [-97.5135, 27.3608], [-97.5409, 27.2294], [-97.4259, 27.2623], [-97.4807, 26.9994], [-97.5574, 26.9884], [-97.5628, 26.8405], [-97.4697, 26.7584], [-97.4423, 26.4572], [-97.3328, 26.3531], [-97.3054, 26.1614], [-97.2178, 25.9916], [-97.5245, 25.8876], [-97.6505, 26.019], [-97.886, 26.0683], [-98.1982, 26.0573], [-98.4665, 26.2216], [-98.6692, 26.2381], [-98.8225, 26.3695], [-99.0307, 26.4133], [-99.1731, 26.5393], [-99.2662, 26.8405], [-99.4469, 27.0213], [-99.425, 27.1746], [-99.5071, 27.3389], [-99.4798, 27.4813], [-99.6057, 27.6402], [-99.7098, 27.6566], [-99.8796, 27.799], [-99.9344, 27.9797], [-100.0822, 28.1441], [-100.2958, 28.281], [-100.3999, 28.5822], [-100.4985, 28.6644], [-100.6299, 28.9053], [-100.6737, 29.1025], [-100.7997, 29.2449], [-101.0133, 29.3709], [-101.0626, 29.4585], [-101.2598, 29.5352], [-101.4131, 29.7543], [-101.8513, 29.8036], [-102.1142, 29.7926], [-102.3387, 29.8693], [-102.388, 29.7652], [-102.629, 29.7324], [-102.8097, 29.5242], [-102.9193, 29.1901], [-102.9795, 29.1847], [-103.1165, 28.9875], [-103.2808, 28.982], [-103.5272, 29.1354], [-104.1461, 29.3818], [-104.2666, 29.5133], [-104.5076, 29.6393], [-104.6774, 29.9241], [-104.6883, 30.1815], [-104.8581, 30.3896], [-104.8965, 30.5703], [-105.006, 30.6854], [-105.3949, 30.8551], [-105.603, 31.0852], [-105.7728, 31.1673], [-105.9535, 31.3645], [-106.2054, 31.4686], [-106.3807, 31.7314], [-106.5286, 31.7862], [-106.6436, 31.9012], [-106.6162, 31.9998], [-103.0672, 31.9998], [-103.0672, 33.0021], [-103.0453, 34.0153], [-103.0398, 36.5019], [-103.0014, 36.5019], [-101.8129, 36.5019], [-100.0001, 36.5019], [-100.0001, 34.563], [-99.9234, 34.574], [-99.6988, 34.3823], [-99.5784, 34.4151], [-99.2607, 34.4042], [-99.1895, 34.2125], [-98.9868, 34.2235], [-98.7678, 34.1358], [-98.5706, 34.1468], [-98.4884, 34.0646], [-98.3625, 34.1577], [-98.1708, 34.1139], [-98.0886, 34.0044], [-97.9462, 33.9879], [-97.8695, 33.851], [-97.6943, 33.9825], [-97.4588, 33.9058], [-97.3711, 33.8236], [-97.2561, 33.862], [-97.174, 33.736], [-96.922, 33.9606], [-96.8508, 33.8455], [-96.6318, 33.8455], [-96.4236, 33.7743], [-96.347, 33.6867], [-96.1498, 33.8401], [-95.9362, 33.8894], [-95.8376, 33.8346], [-95.6021, 33.9332], [-95.5473, 33.8784], [-95.2899, 33.8729], [-95.2242, 33.9606], [-94.9668, 33.862], [-94.8682, 33.747], [-94.4848, 33.6374], [-94.43, 35.3955], [-94.6162, 36.5019], [-94.4738, 36.5019], [-90.1525, 36.4964], [-90.0649, 36.3047], [-90.2183, 36.1842], [-90.3771, 35.998], [-89.7308, 35.998], [-89.7637, 35.8118], [-89.9116, 35.757], [-89.9444, 35.6036], [-90.1306, 35.4393], [-90.1142, 35.1983], [-90.2128, 35.0231], [-90.3114, 34.9957], [-90.2511, 34.9081], [-90.41, 34.8314], [-90.4812, 34.6616], [-90.5852, 34.6178], [-90.5688, 34.4206], [-90.7495, 34.3659], [-90.744, 34.3001], [-90.9522, 34.1358], [-90.8919, 34.0263], [-91.0727, 33.8675], [-91.2315, 33.5607], [-91.0562, 33.4293], [-91.1439, 33.3471], [-91.0891, 33.139], [-91.1658, 33.0021], [-91.0727, 32.8871]],
    label: [-98.7185, 31.2166],
    token: [-98.7185, 31.2166]
  },
  "US Southeast": {
    polygon: [[-81.258, 29.7871], [-80.9677, 29.1463], [-80.5241, 28.4617], [-80.5898, 28.4124], [-80.5679, 28.0948], [-80.3817, 27.7388], [-80.0914, 27.0213], [-80.0311, 26.7967], [-80.0366, 26.5667], [-80.1462, 25.7397], [-80.2393, 25.7232], [-80.3379, 25.4658], [-80.305, 25.3837], [-80.4967, 25.1975], [-80.5734, 25.2413], [-80.7596, 25.1646], [-81.0772, 25.1208], [-81.1704, 25.2248], [-81.1265, 25.3782], [-81.3511, 25.8218], [-81.5264, 25.904], [-81.6797, 25.8437], [-81.8002, 26.0902], [-81.8331, 26.2928], [-82.0412, 26.5174], [-82.0905, 26.6653], [-82.0576, 26.8789], [-82.1726, 26.9172], [-82.1452, 26.7912], [-82.2493, 26.7584], [-82.567, 27.3006], [-82.6929, 27.4375], [-82.3917, 27.8373], [-82.5889, 27.8154], [-82.7203, 27.6895], [-82.8518, 27.8866], [-82.6765, 28.4343], [-82.6437, 28.8889], [-82.7641, 28.9985], [-82.8025, 29.1463], [-82.9942, 29.1792], [-83.2187, 29.4202], [-83.3995, 29.5188], [-83.4104, 29.6666], [-83.5364, 29.7214], [-83.6405, 29.8857], [-84.0238, 30.1048], [-84.3579, 30.0555], [-84.3415, 29.9021], [-84.451, 29.9295], [-84.8673, 29.7433], [-85.3109, 29.6995], [-85.3, 29.809], [-85.404, 29.9405], [-85.9243, 30.2362], [-86.2968, 30.3622], [-86.6309, 30.3951], [-86.9102, 30.3732], [-87.5181, 30.2801], [-87.6551, 30.2472], [-87.907, 30.4115], [-87.9344, 30.658], [-88.0111, 30.6854], [-88.1042, 30.4991], [-88.137, 30.3184], [-88.3944, 30.3677], [-88.504, 30.3239], [-88.745, 30.3458], [-88.8435, 30.4115], [-89.0845, 30.3677], [-89.4186, 30.2527], [-89.5227, 30.1815], [-89.6432, 30.2855], [-89.6815, 30.4498], [-89.8458, 30.6689], [-89.7472, 30.9975], [-91.6368, 30.9975], [-91.5656, 31.0687], [-91.6368, 31.2659], [-91.5163, 31.2769], [-91.4999, 31.6438], [-91.4013, 31.6219], [-91.341, 31.8465], [-91.1055, 31.9889], [-90.985, 32.2189], [-91.0069, 32.5146], [-91.1548, 32.6406], [-91.1439, 32.8433], [-91.0727, 32.8871], [-91.1658, 33.0021], [-91.0891, 33.139], [-91.1439, 33.3471], [-91.0562, 33.4293], [-91.2315, 33.5607], [-91.0727, 33.8675], [-90.8919, 34.0263], [-90.9522, 34.1358], [-90.744, 34.3001], [-90.7495, 34.3659], [-90.5688, 34.4206], [-90.5852, 34.6178], [-90.4812, 34.6616], [-90.41, 34.8314], [-90.2511, 34.9081], [-90.3114, 34.9957], [-90.2128, 35.0231], [-90.1142, 35.1983], [-90.1306, 35.4393], [-89.9444, 35.6036], [-89.9116, 35.757], [-89.7637, 35.8118], [-89.7308, 35.998], [-89.5336, 36.2499], [-89.5391, 36.4964], [-89.4843, 36.4964], [-89.4186, 36.4964], [-89.3639, 36.6224], [-89.216, 36.5785], [-89.1338, 36.9838], [-89.1831, 37.0386], [-89.0298, 37.2139], [-88.9147, 37.2248], [-88.5478, 37.0715], [-88.4218, 37.1536], [-88.5149, 37.2851], [-88.4766, 37.3891], [-88.0658, 37.4822], [-88.1589, 37.6575], [-88.0275, 37.7999], [-87.9344, 37.893], [-87.6824, 37.904], [-87.6003, 37.9752], [-87.5127, 37.904], [-87.3812, 37.9368], [-87.1293, 37.7889], [-87.0471, 37.893], [-86.7952, 37.9916], [-86.7294, 37.893], [-86.5049, 37.9313], [-86.5213, 38.0409], [-86.3022, 38.1669], [-86.2639, 38.0518], [-86.0394, 37.9587], [-85.9243, 38.0245], [-85.8312, 38.2764], [-85.656, 38.3257], [-85.5902, 38.4517], [-85.4205, 38.5338], [-85.4314, 38.731], [-85.174, 38.6872], [-84.9878, 38.7803], [-84.8125, 38.7857], [-84.8947, 39.0596], [-84.818, 39.1034], [-84.4346, 39.1034], [-84.232, 38.8953], [-84.2155, 38.8077], [-83.9033, 38.7693], [-83.6788, 38.6324], [-83.52, 38.7036], [-83.1421, 38.6269], [-83.0325, 38.7255], [-82.8901, 38.7584], [-82.8463, 38.5886], [-82.7313, 38.5612], [-82.5944, 38.4243], [-82.3315, 38.4462], [-82.2931, 38.5776], [-82.1726, 38.6324], [-82.2219, 38.7857], [-82.0357, 39.0267], [-81.8878, 38.8734], [-81.7838, 38.9665], [-81.8112, 39.0815], [-81.6852, 39.2732], [-81.5702, 39.2677], [-81.4552, 39.4101], [-81.3456, 39.3444], [-81.2196, 39.3882], [-80.8308, 39.7113], [-80.7377, 40.0783], [-80.6008, 40.3193], [-80.5953, 40.4726], [-80.6665, 40.5822], [-80.5186, 40.637], [-80.5186, 39.7223], [-79.478, 39.7223], [-79.4889, 39.2075], [-79.2918, 39.3006], [-79.0946, 39.4704], [-78.9631, 39.4375], [-78.766, 39.5854], [-78.4702, 39.5142], [-78.4319, 39.6237], [-78.2676, 39.6182], [-78.1745, 39.6949], [-78.0047, 39.6018], [-77.8349, 39.6018], [-77.7199, 39.3225], [-77.5665, 39.3061], [-77.457, 39.2239], [-77.457, 39.076], [-77.2489, 39.0267], [-77.1174, 38.9336], [-77.0407, 38.7912], [-77.1284, 38.6324], [-77.2489, 38.5886], [-77.3255, 38.4462], [-77.2817, 38.3421], [-77.0134, 38.375], [-76.9641, 38.2161], [-76.6135, 38.1504], [-76.515, 38.0245], [-76.2356, 37.8875], [-76.3616, 37.6082], [-76.2466, 37.3891], [-76.3835, 37.2851], [-76.3999, 37.1591], [-76.274, 37.0824], [-76.4109, 36.9619], [-76.619, 37.1208], [-76.6683, 37.066], [-76.4876, 36.951], [-75.9946, 36.9236], [-75.8687, 36.5512], [-75.7537, 36.1513], [-76.033, 36.1897], [-76.0713, 36.1404], [-76.4109, 36.0801], [-76.4602, 36.0254], [-76.6847, 36.0089], [-76.6738, 35.9377], [-76.3999, 35.987], [-76.3616, 35.9432], [-76.0604, 35.9925], [-75.9618, 35.8994], [-75.781, 35.9377], [-75.7153, 35.6968], [-75.7756, 35.5817], [-75.8961, 35.5708], [-76.148, 35.3243], [-76.4821, 35.3134], [-76.5369, 35.1436], [-76.3945, 34.9738], [-76.2794, 34.9409], [-76.493, 34.6616], [-76.6738, 34.6945], [-76.9914, 34.6671], [-77.2105, 34.6068], [-77.5556, 34.4151], [-77.8294, 34.1632], [-77.9718, 33.8455], [-78.1799, 33.9167], [-78.5414, 33.851], [-78.7167, 33.8017], [-78.9358, 33.6374], [-79.1494, 33.38], [-79.1877, 33.1719], [-79.3575, 33.0076], [-79.582, 33.0076], [-79.6313, 32.8871], [-79.8668, 32.7556], [-79.9983, 32.6132], [-80.2064, 32.553], [-80.431, 32.3996], [-80.4529, 32.3284], [-80.661, 32.2463], [-80.8856, 32.0327], [-81.132, 31.6931], [-81.1758, 31.5178], [-81.2799, 31.3645], [-81.2908, 31.2057], [-81.4004, 31.1345], [-81.4442, 30.7073], [-81.384, 30.2746], [-81.258, 29.7871]],
    label: [-85.3894, 32.8652],
    token: [-85.3894, 32.8652]
  },
  "US Southwest": {
    polygon: [[-104.3378, 36.9948], [-103.0014, 37.0003], [-103.0014, 36.5019], [-103.0398, 36.5019], [-103.0453, 34.0153], [-103.0672, 33.0021], [-103.0672, 31.9998], [-106.6162, 31.9998], [-106.6436, 31.9012], [-106.5286, 31.7862], [-108.21, 31.7862], [-108.21, 31.3316], [-109.048, 31.3316], [-111.0744, 31.3316], [-112.2465, 31.7041], [-114.8152, 32.4927], [-114.7221, 32.7173], [-114.5249, 32.7556], [-114.4702, 32.8433], [-114.5249, 33.0295], [-114.6618, 33.035], [-114.7276, 33.4074], [-114.5249, 33.5498], [-114.4975, 33.6977], [-114.5359, 33.9332], [-114.4154, 34.1084], [-114.2566, 34.1742], [-114.1361, 34.3056], [-114.3332, 34.448], [-114.4702, 34.7109], [-114.6345, 34.8752], [-114.6345, 35.0012], [-115.8503, 35.9706], [-116.5404, 36.5019], [-117.4989, 37.2193], [-118.7148, 38.1011], [-120.0019, 38.9993], [-119.9964, 40.2645], [-120.0019, 41.9952], [-118.6983, 41.9898], [-117.0279, 42.0007], [-114.043, 41.9952], [-112.1644, 41.9952], [-111.0471, 42.0007], [-111.0471, 40.9984], [-109.048, 40.9984], [-109.0535, 39.1253], [-109.0589, 38.2764], [-109.0425, 38.1669], [-109.0425, 37.0003], [-107.4213, 37.0003], [-106.8682, 36.9948], [-104.3378, 36.9948]],
    label: [-109.9356, 36.7483],
    token: [-109.9356, 36.7483]
  },
  "Ukraine": {
    polygon: [[31.786, 52.1017], [33.7527, 52.3351], [34.3917, 51.7689], [34.2248, 51.256], [35.0222, 51.2076], [35.3561, 50.5772], [36.6262, 50.2256], [37.3935, 50.384], [38.0106, 49.9157], [40.069, 49.6011], [39.6746, 48.7838], [39.7383, 47.8989], [38.7706, 47.8256], [38.2551, 47.5464], [38.2235, 47.1022], [34.9623, 46.2732], [35.0127, 45.7377], [33.6995, 46.2196], [33.436, 45.9719], [31.7441, 46.3333], [31.6753, 46.7062], [30.7487, 46.5831], [29.6033, 45.2933], [28.6798, 45.304], [28.2336, 45.4883], [28.863, 46.4379], [30.0247, 46.4239], [28.6709, 48.1181], [27.5225, 48.4671], [24.8663, 47.7375], [23.1422, 48.0963], [22.7105, 47.8822], [22.0856, 48.4223], [22.7764, 49.0274], [22.5185, 49.4768], [23.9228, 50.4249], [23.5271, 51.5785], [25.3278, 51.9107], [30.5551, 51.3195], [30.9275, 52.0424], [31.786, 52.1017]],
    label: [30.9808, 48.8046],
    token: [30.9808, 48.8046]
  },
  "Venezuela": {
    polygon: [[-60.7336, 5.2003], [-60.9669, 4.5365], [-63.0932, 3.7706], [-64.8161, 4.0564], [-64.3685, 3.7972], [-64.27, 2.497], [-63.3688, 2.2009], [-65.5483, 0.7893], [-66.3258, 0.7245], [-67.8099, 2.8207], [-67.3032, 3.3185], [-67.823, 4.5039], [-67.3414, 6.0955], [-69.3895, 6.0999], [-70.0933, 6.9604], [-71.9602, 6.9916], [-72.4445, 7.4238], [-72.7887, 9.085], [-73.305, 9.152], [-72.9053, 10.4503], [-71.9739, 11.6087], [-71.3316, 11.7763], [-71.9471, 11.4233], [-71.6331, 10.4465], [-72.0742, 9.8657], [-71.6956, 9.0723], [-71.2646, 9.1372], [-71.04, 9.86], [-71.4006, 10.969], [-70.1553, 11.3755], [-70.2938, 11.8468], [-69.9432, 12.1623], [-69.5843, 11.4596], [-68.883, 11.4434], [-68.1941, 10.5547], [-66.2279, 10.6486], [-64.8905, 10.0772], [-64.318, 10.6414], [-61.8809, 10.7156], [-62.7301, 10.4203], [-62.3885, 9.9482], [-60.8306, 9.3813], [-60.6713, 8.5802], [-59.7583, 8.367], [-60.5506, 7.7796], [-60.2957, 7.0439], [-61.1593, 6.6961], [-61.4103, 5.9591], [-60.7336, 5.2003]],
    label: [-65.4259, 6.4817],
    token: [-65.4259, 6.4817]
  }
};

const VIEWBOX_WIDTH = 1000;
const VIEWBOX_HEIGHT = 620;

function projectLonLat(coord) {
  const [lon, lat] = coord;
  const x = ((lon + 180) / 360) * VIEWBOX_WIDTH;
  const y = ((90 - lat) / 180) * VIEWBOX_HEIGHT;
  return {
    x: Math.round(x * 10) / 10,
    y: Math.round(y * 10) / 10
  };
}

function buildMapLayout() {
  return Object.fromEntries(
    Object.entries(GEO_LAYOUT).map(([name, geo]) => {
      const points = geo.polygon.map((coord) => {
        const p = projectLonLat(coord);
        return `${p.x},${p.y}`;
      }).join(' ');
      return [
        name,
        {
          points,
          label: projectLonLat(geo.label),
          token: projectLonLat(geo.token)
        }
      ];
    })
  );
}

const MAP_LAYOUT = buildMapLayout();

function polygonAreaFromPointsString(pointsString) {
  const pts = pointsString.trim().split(/\s+/).map((pair) => {
    const [x, y] = pair.split(",").map(Number);
    return { x, y };
  });
  if (pts.length < 3) return 1;
  let sum = 0;
  for (let i = 0; i < pts.length; i += 1) {
    const a = pts[i];
    const b = pts[(i + 1) % pts.length];
    sum += (a.x * b.y) - (b.x * a.y);
  }
  return Math.max(1, Math.abs(sum / 2));
}

const TERRITORY_AREAS = Object.fromEntries(
  Object.entries(MAP_LAYOUT).map(([name, layout]) => [name, polygonAreaFromPointsString(layout.points)])
);

const AREA_VALUES = Object.values(TERRITORY_AREAS);
const MIN_AREA = Math.min(...AREA_VALUES);
const MAX_AREA = Math.max(...AREA_VALUES);
const TOTAL_MAP_AREA = AREA_VALUES.reduce((sum, area) => sum + area, 0) || 1;

function scaleByArea(name, minValue, maxValue) {
  const area = TERRITORY_AREAS[name] ?? MIN_AREA;
  if (MAX_AREA <= MIN_AREA) return (minValue + maxValue) / 2;
  const t = (area - MIN_AREA) / (MAX_AREA - MIN_AREA);
  return minValue + ((maxValue - minValue) * t);
}

function tokenRadiusFor(name) {
  return Math.round(scaleByArea(name, 12.9, 19.4) * 10) / 10;
}

function labelFontSizeFor(name) {
  return Math.round(scaleByArea(name, 11.2, 15.6) * 10) / 10;
}

const SEASONS = ["Spring", "Summer", "Fall", "Winter"];
const NS = "http://www.w3.org/2000/svg";
const ECONOMY = {
  armiesBundle: 10,
  armiesCost: 400,
  shipsBundle: 5,
  shipsCost: 400,
  fortifyCost: 1000,
  annualIncomeFloor: 900,
  annualIncomeScale: 22000
};
const STARTING_TREASURY = 5000;
const WATER_TRANSPORT_SHIP_BATCH = 5;
const WATER_TRANSPORT_TROOPS_PER_BATCH = 35;
const WATER_TRANSPORT_TROOPS_PER_SHIP = WATER_TRANSPORT_TROOPS_PER_BATCH / WATER_TRANSPORT_SHIP_BATCH;
const AI_OWNERS = ["ai1", "ai2", "ai3", "ai4", "ai5", "ai6"];
const NETWORK_HUMAN_OWNER_SLOTS = ["player", "ai1", "ai2", "ai3"];
const OWNER_STYLE_CLASSES = ["player", "neutral", "ai1", "ai2", "ai3", "ai4", "ai5", "ai6"];

const OCEAN_ROUTE_PAIRS = [
  ["Arabia", "East Africa"],
  ["Australia East", "New Zealand"],
  ["Australia East", "Papua"],
  ["Australia West", "Maritime SEA"],
  ["Benelux", "British Isles"],
  ["Brazil North", "France"],
  ["British Isles", "France"],
  ["British Isles", "Greenland"],
  ["British Isles", "US Northeast"],
  ["Cuba", "Hispaniola"],
  ["Cuba", "US Southeast"],
  ["East Africa", "Madagascar"],
  ["Greenland", "Canada East"],
  ["Gulf of Guinea", "Brazil North"],
  ["Hispaniola", "Venezuela"],
  ["Iberia", "Maghreb"],
  ["Iberia", "US Southeast"],
  ["Japan North", "Japan South"],
  ["Japan North", "Russia East"],
  ["Japan South", "Korea"],
  ["Madagascar", "Southern Africa"],
  ["Mainland SEA", "Maritime SEA"],
  ["Maritime SEA", "Papua"],
  ["Papua", "New Zealand"],
  ["Poland-Baltic", "Scandinavia"],
  ["Russia East", "US Northwest"]
];

function routeKey(a, b) {
  return [a, b].sort().join("|");
}

const OCEAN_ROUTE_KEYS = new Set(
  OCEAN_ROUTE_PAIRS.map(([a, b]) => routeKey(a, b))
);

const MOUNTAIN_BLOCKED_PAIRS = [
  ["US Pacific", "US Rockies"],
  ["US Southwest", "US Rockies"],
  ["US Midwest", "US Rockies"],
  ["US South", "US Rockies"],
  ["Chile", "Bolivia"],
  ["Peru", "Bolivia"],
  ["India North", "China West"],
  ["India North", "China Central"],
  ["Pakistan", "China West"],
  ["Mongolia", "Russia East"]
];

const MOUNTAIN_BLOCKED_ROUTE_KEYS = new Set(
  MOUNTAIN_BLOCKED_PAIRS.map(([a, b]) => routeKey(a, b))
);

const MOUNTAIN_RANGES = [
  {
    id: "rockies",
    territory: "US Rockies",
    anchorToSide: true,
    sideHint: "east",
    sideDepth: 0.26,
    sideInset: 0.86,
    sampleStart: 0.0,
    sampleEnd: 1.0,
    coverFullSide: true,
    spine: [
      { x: 198.5, y: 145.8 },
      { x: 198.0, y: 155.4 },
      { x: 197.4, y: 165.3 },
      { x: 197.5, y: 175.0 },
      { x: 198.3, y: 182.7 }
    ],
    side: 1,
    edgeInset: 0.52,
    bandWidth: 6.7,
    peakSpacing: 8.4,
    peakWidth: 3.2,
    peakHeight: 5.2
  },
  {
    id: "southern-russia",
    territory: "Russia West",
    anchorToSide: true,
    sideHint: "south",
    sideDepth: 0.18,
    sideInset: 0.86,
    sampleStart: 0.12,
    sampleEnd: 0.9,
    edgeInset: 0.54,
    bandWidth: 6.1,
    peakSpacing: 8.2,
    peakWidth: 2.8,
    peakHeight: 4.6
  },
  {
    id: "urga-north",
    territory: "Mongolia",
    anchorToSide: true,
    sideHint: "north",
    sideDepth: 0.22,
    sideInset: 0.9,
    sampleStart: 0.06,
    sampleEnd: 0.94,
    edgeInset: 0.54,
    bandWidth: 5.8,
    peakSpacing: 7.9,
    peakWidth: 2.6,
    peakHeight: 4.2
  },
  {
    id: "andes",
    territory: "Bolivia",
    anchorToSide: true,
    sideHint: "west",
    sideDepth: 0.2,
    sideInset: 0.95,
    spine: [
      { x: 307.6, y: 348.2 },
      { x: 308.0, y: 356.0 },
      { x: 308.4, y: 364.4 },
      { x: 308.8, y: 372.5 },
      { x: 309.1, y: 380.3 }
    ],
    side: 1,
    edgeInset: 0.68,
    bandWidth: 7.2,
    peakSpacing: 8.6,
    peakWidth: 3.4,
    peakHeight: 5.8
  },
  {
    id: "himalaya",
    territory: "India North",
    anchorToSide: true,
    sideHint: "north",
    sideDepth: 0.18,
    sideInset: 1.0,
    spine: [
      { x: 705.4, y: 191.2 },
      { x: 718.2, y: 193.8 },
      { x: 730.8, y: 198.4 },
      { x: 743.8, y: 203.1 },
      { x: 756.7, y: 207.8 },
      { x: 768.5, y: 212.2 }
    ],
    side: 1,
    edgeInset: 0.74,
    bandWidth: 7.8,
    peakSpacing: 9.2,
    peakWidth: 3.6,
    peakHeight: 6.1
  },
  {
    id: "alps",
    territory: "Alpine States",
    anchorToSide: true,
    sideHint: "north",
    sideDepth: 0.22,
    sideInset: 0.8,
    spine: [
      { x: 539.5, y: 134.2 },
      { x: 545.0, y: 135.3 },
      { x: 550.8, y: 136.9 },
      { x: 556.8, y: 138.5 },
      { x: 561.8, y: 140.9 }
    ],
    side: 1,
    edgeInset: 0.58,
    bandWidth: 5.6,
    peakSpacing: 8.0,
    peakWidth: 2.9,
    peakHeight: 4.6
  }
];

const COASTAL_TERRITORIES = new Set([
  "Arabia",
  "Argentina North",
  "Argentina South",
  "Australia East",
  "Australia West",
  "Balkans",
  "Benelux",
  "Brazil North",
  "Brazil South",
  "British Isles",
  "Canada Central",
  "Canada East",
  "Canada West",
  "Caucasus",
  "Central America",
  "Chile",
  "China East",
  "Colombia",
  "Cuba",
  "East Africa",
  "Egypt",
  "France",
  "Germany",
  "Greenland",
  "Gulf of Guinea",
  "Hispaniola",
  "Iberia",
  "India North",
  "India South",
  "Iran",
  "Italy",
  "Japan North",
  "Japan South",
  "Korea",
  "La Plata",
  "Madagascar",
  "Maghreb",
  "Mainland SEA",
  "Maritime SEA",
  "Mexico",
  "New Zealand",
  "Nigeria",
  "Pakistan",
  "Papua",
  "Peru",
  "Poland-Baltic",
  "Russia East",
  "Russia West",
  "Scandinavia",
  "Southern Africa",
  "Turkey",
  "Ukraine",
  "US Northeast",
  "US Northwest",
  "US Pacific",
  "US South",
  "US Southeast",
  "US Southwest",
  "Venezuela"
]);

const state = {
  territories: {},
  turn: "player",
  phase: "reinforce",
  reinforcementsLeft: 0,
  attackForce: 1,
  attackShips: 0,
  selection: { from: null, to: null },
  viewedTerritory: null,
  homeBase: null,
  ships: 0,
  playerShipLocations: {},
  shipsByOwner: { player: 0 },
  shipLocationsByOwner: { player: {} },
  aiShips: AI_OWNERS.reduce((acc, owner) => {
    acc[owner] = 0;
    return acc;
  }, {}),
  gameOver: false,
  seasonIndex: 0,
  year: 1850,
  lastIncomeYear: 1850,
  treasury: STARTING_TREASURY,
  treasuryByOwner: { player: STARTING_TREASURY },
  firstRound: true,
  animating: false,
  setupOpen: false,
  playerCountryId: "united-states",
  setupStep: "create",
  setupTab: "map",
  setupOptions: {
    playMode: "solo",
    mapPreset: "world-1850",
    rulesPreset: "classic",
    difficulty: "very-easy",
    campaignMode: "deathmatch",
    passPlayers: 2
  },
  networkSetup: {
    role: "host",
    room: "empires-room",
    playerName: "Commander",
    selectedLobbyId: "",
    maxPlayers: 4,
    aiEnabled: true,
    countryChosen: false
  },
  multiplayer: {
    commanderIndex: 0,
    network: {
      active: false,
      role: "host",
      room: "",
      lobbyId: "",
      playerId: "",
      hostPlayerId: "",
      waitingForRemote: false,
      connected: false,
      started: false,
      players: [],
      maxPlayers: 4,
      aiEnabled: true,
      activePlayerId: "",
      payloadVersion: 0,
      lastAppliedPayloadVersion: 0,
      availableLobbies: [],
      ownerByPlayerId: {},
      ownerCountryByOwner: {},
      lastError: "",
      actionPending: false
    }
  },
  forceMenuHidden: false,
  economyPanelOpen: false,
  outcomeAckRequired: false,
  outcomeAckWaiters: []
};

const SAVE_FORMAT_VERSION = 1;
const SAVE_STORAGE_KEY = "until-zero-save-v1";
const VALID_OWNER_SET = new Set(["player", "neutral", ...AI_OWNERS]);
const NETWORK_ROOM_MAX_LEN = 32;
const MULTIPLAYER_DEFAULT_ROOM = "empires-room";
const NETWORK_POLL_INTERVAL_MS = 900;
const NETWORK_REQUEST_TIMEOUT_MS = 7000;
let networkPollTimer = null;
let networkPollBusy = false;
let networkLobbyBrowseBusy = false;
let networkLobbyBrowseQueued = false;
let networkLastLobbyBrowseAt = 0;

const DISPLAY_NAMES = {
  "Alpine States": "Alps",
  "Australia East": "Eastern Australia",
  "Australia West": "Western Australia",
  "British Isles": "United Kingdom",
  "Canada Central": "Central Canada",
  "Canada East": "Eastern Canada",
  "Canada West": "Western Canada",
  "Central Africa": "Central Africa",
  "Central America": "Central America",
  "Central Asia": "Central Asia",
  "China Central": "Central China",
  "China East": "Eastern China",
  "China West": "Western China",
  "East Africa": "East Africa",
  "Gulf of Guinea": "Gulf Guinea",
  "India North": "North India",
  "India South": "South India",
  "Japan North": "North Japan",
  "Japan South": "South Japan",
  "Mainland SEA": "Mainland SE Asia",
  "Maritime SEA": "Maritime SE Asia",
  "Poland-Baltic": "Poland-Baltic",
  "Russia East": "Eastern Russia",
  "Russia West": "Western Russia",
  "Southern Africa": "Southern Africa",
  "US Midwest": "US Midwest",
  "US Northeast": "US Northeast",
  "US Northwest": "US Northwest",
  "US Pacific": "US Pacific",
  "US Rockies": "US Rockies",
  "US South": "US South",
  "US Southeast": "US Southeast",
  "US Southwest": "US Southwest"
};

const CAPITAL_LABELS = {
  "Alpine States": "Vienna",
  "Arabia": "Mecca",
  "Argentina North": "Cordoba",
  "Argentina South": "Patagonia",
  "Australia East": "Sydney",
  "Australia West": "Perth",
  "Balkans": "Belgrade",
  "Benelux": "Brussels",
  "Bolivia": "La Paz",
  "Brazil North": "Manaus",
  "Brazil South": "Rio",
  "British Isles": "London",
  "Canada Central": "Winnipeg",
  "Canada East": "Toronto",
  "Canada West": "Vancouver",
  "Caucasus": "Tbilisi",
  "Central Africa": "Kinshasa",
  "Central America": "Guatemala",
  "Central Asia": "Tashkent",
  "Chile": "Santiago",
  "China Central": "Xi'an",
  "China East": "Shanghai",
  "China West": "Urumqi",
  "Colombia": "Bogota",
  "Cuba": "Havana",
  "East Africa": "Zanzibar",
  "Egypt": "Cairo",
  "France": "Paris",
  "Germany": "Berlin",
  "Greenland": "Greenland",
  "Gulf of Guinea": "Accra",
  "Hispaniola": "Santo Domingo",
  "Iberia": "Madrid",
  "India North": "Delhi",
  "India South": "Bangalore",
  "Iran": "Tehran",
  "Italy": "Rome",
  "Japan North": "Sapporo",
  "Japan South": "Tokyo",
  "Korea": "Seoul",
  "La Plata": "Buenos Aires",
  "Madagascar": "Madagascar",
  "Maghreb": "Algiers",
  "Mainland SEA": "Bangkok",
  "Maritime SEA": "Jakarta",
  "Mexico": "Mexico City",
  "Mongolia": "Ulaanbaatar",
  "New Zealand": "Wellington",
  "Nigeria": "Lagos",
  "Pakistan": "Karachi",
  "Papua": "Port Moresby",
  "Peru": "Lima",
  "Poland-Baltic": "Warsaw",
  "Russia East": "Vladivostok",
  "Russia West": "Moscow",
  "Sahel": "Timbuktu",
  "Scandinavia": "Stockholm",
  "Southern Africa": "Cape Town",
  "Turkey": "Istanbul",
  "US Midwest": "Chicago",
  "US Northeast": "New York",
  "US Northwest": "Seattle",
  "US Pacific": "Los Angeles",
  "US Rockies": "Denver",
  "US South": "New Orleans",
  "US Southeast": "Washington",
  "US Southwest": "Phoenix",
  "Ukraine": "Kyiv",
  "Venezuela": "Caracas"
};

const STARTING_COUNTRY_POOL = [
  { id: "united-states", name: "United States", territory: "US Southeast" },
  { id: "united-kingdom", name: "United Kingdom", territory: "British Isles" },
  { id: "japan", name: "Japan", territory: "Japan South" },
  { id: "south-africa", name: "South Africa", territory: "Southern Africa" },
  { id: "russia", name: "Russia", territory: "Russia West" },
  { id: "india", name: "India", territory: "India North" },
  { id: "brazil", name: "Brazil", territory: "Brazil South" }
];
const CAPITAL_ICON_TERRITORIES = new Set(
  STARTING_COUNTRY_POOL.map((country) => country.territory)
);

const STARTING_COUNTRY_FLAGS = {
  "united-states": "",
  "united-kingdom": "",
  "japan": "",
  "south-africa": "",
  "russia": "",
  "india": "",
  "brazil": ""
};

const STARTING_AI_PRIORITY = [
  "united-kingdom",
  "russia",
  "india",
  "south-africa",
  "japan",
  "brazil",
  "united-states"
];

const SETUP_PLAY_MODES = [
  {
    id: "solo",
    name: "Solo",
    icon: "",
    summary: "Play alone against AI empires."
  },
  {
    id: "online",
    name: "Play Online",
    icon: "",
    summary: "Internet matchmaking and private lobbies (planned)."
  },
  {
    id: "pass-play",
    name: "Pass & Play",
    icon: "",
    summary: "Rotate local commanders on one device."
  },
  {
    id: "network",
    name: "Network Play",
    icon: "",
    summary: "Host or join a room and hand off turns remotely."
  }
];

const SETUP_MAP_PRESETS = [
  {
    id: "world-1850",
    name: "World 1850",
    summary: "77 regions. Best for full campaigns."
  },
  {
    id: "classic-world",
    name: "Classic World",
    summary: "Alternate map layout and pacing (planned)."
  }
];

const SETUP_RULE_PRESETS = [
  {
    id: "classic",
    name: "Classic Rules",
    summary: "Standard conquest with annual budget and reinforcements."
  },
  {
    id: "rapid",
    name: "Rapid Rules",
    summary: "Faster seasons and more aggressive pacing (planned)."
  }
];

const SETUP_CAMPAIGN_MODES = [
  { id: "deathmatch", name: "Deathmatch" },
  { id: "cooperative", name: "Cooperative" }
];

const SETUP_DIFFICULTIES = [
  {
    id: "very-easy",
    name: "Very easy",
    playerStartArmies: 14,
    aiStartArmies: 10,
    reserveStartArmies: 10,
    playerReinforcementBonus: 1,
    aiReinforcementBonus: 0,
    aiAttackThreshold: -5
  },
  {
    id: "easy",
    name: "Easy",
    playerStartArmies: 13,
    aiStartArmies: 11,
    reserveStartArmies: 10,
    playerReinforcementBonus: 1,
    aiReinforcementBonus: 0,
    aiAttackThreshold: -4
  },
  {
    id: "normal",
    name: "Normal",
    playerStartArmies: 12,
    aiStartArmies: 12,
    reserveStartArmies: 11,
    playerReinforcementBonus: 0,
    aiReinforcementBonus: 0,
    aiAttackThreshold: -3
  },
  {
    id: "hard",
    name: "Hard",
    playerStartArmies: 11,
    aiStartArmies: 13,
    reserveStartArmies: 12,
    playerReinforcementBonus: 0,
    aiReinforcementBonus: 1,
    aiAttackThreshold: -2
  },
  {
    id: "very-hard",
    name: "Very hard",
    playerStartArmies: 10,
    aiStartArmies: 14,
    reserveStartArmies: 13,
    playerReinforcementBonus: 0,
    aiReinforcementBonus: 1,
    aiAttackThreshold: -1
  }
];

const DEFAULT_SETUP_OPTIONS = Object.freeze({
  step: "create",
  tab: "map",
  playMode: "solo",
  mapPreset: "world-1850",
  rulesPreset: "classic",
  difficulty: "very-easy",
  campaignMode: "deathmatch",
  passPlayers: 2
});

function territoryLabel(name, fallback = "") {
  if (!name) return fallback;
  return CAPITAL_LABELS[name] || DISPLAY_NAMES[name] || name;
}

function hasCapitalIcon(name) {
  return CAPITAL_ICON_TERRITORIES.has(name);
}

function resolveStartingCountry(countryId) {
  return STARTING_COUNTRY_POOL.find((country) => country.id === countryId) || STARTING_COUNTRY_POOL[0];
}

function buildStartingAssignments(playerCountryId) {
  const playerCountry = resolveStartingCountry(playerCountryId);
  const used = new Set([playerCountry.id]);
  const aiCountryIds = [];

  STARTING_AI_PRIORITY.forEach((countryId) => {
    if (aiCountryIds.length >= AI_OWNERS.length) return;
    if (used.has(countryId)) return;
    aiCountryIds.push(countryId);
    used.add(countryId);
  });

  STARTING_COUNTRY_POOL.forEach((country) => {
    if (aiCountryIds.length >= AI_OWNERS.length) return;
    if (used.has(country.id)) return;
    aiCountryIds.push(country.id);
    used.add(country.id);
  });

  const aiStarts = AI_OWNERS.map((owner, index) => {
    const country = resolveStartingCountry(aiCountryIds[index]);
    return {
      owner,
      country,
      territory: country.territory
    };
  });

  return {
    playerCountry,
    aiStarts
  };
}

function setupModeById(modeId) {
  return SETUP_PLAY_MODES.find((mode) => mode.id === modeId) || SETUP_PLAY_MODES[0];
}

function setupMapPresetById(mapId) {
  return SETUP_MAP_PRESETS.find((preset) => preset.id === mapId) || SETUP_MAP_PRESETS[0];
}

function setupRulesPresetById(rulesId) {
  return SETUP_RULE_PRESETS.find((preset) => preset.id === rulesId) || SETUP_RULE_PRESETS[0];
}

function setupDifficultyById(difficultyId) {
  return SETUP_DIFFICULTIES.find((entry) => entry.id === difficultyId) || SETUP_DIFFICULTIES[0];
}

function setupCampaignModeById(modeId) {
  return SETUP_CAMPAIGN_MODES.find((entry) => entry.id === modeId) || SETUP_CAMPAIGN_MODES[0];
}

function setupDifficultyIndex() {
  const index = SETUP_DIFFICULTIES.findIndex((entry) => entry.id === state.setupOptions.difficulty);
  return index < 0 ? 0 : index;
}

function sanitizeNetworkRoom(value) {
  const raw = typeof value === "string" ? value.trim().toLowerCase() : "";
  const normalized = raw
    .replace(/[^a-z0-9-]+/g, "-")
    .replace(/^-+/, "")
    .replace(/-+$/, "")
    .slice(0, NETWORK_ROOM_MAX_LEN);
  return normalized || MULTIPLAYER_DEFAULT_ROOM;
}

function isPassPlayMode() {
  return state.setupOptions.playMode === "pass-play";
}

function isNetworkMode() {
  return state.setupOptions.playMode === "network" && state.multiplayer.network.active;
}

function multiplayerCommanderCount() {
  if (isPassPlayMode()) {
    return Math.max(2, Math.min(6, state.setupOptions.passPlayers || 2));
  }
  if (isNetworkMode()) {
    return Math.max(1, Math.min(4, state.multiplayer.network.players.length || 1));
  }
  return 1;
}

function currentCommanderNumber() {
  return Math.max(1, Math.min(multiplayerCommanderCount(), (state.multiplayer.commanderIndex || 0) + 1));
}

function isNetworkInputLocked() {
  return isNetworkMode() && state.multiplayer.network.waitingForRemote;
}

function currentCommanderLabel() {
  if (isNetworkMode()) {
    const localPlayer = networkLocalPlayer();
    const activePlayer = networkActivePlayer();
    if (activePlayer && localPlayer && activePlayer.id === localPlayer.id) {
      return `${localPlayer.name} (You)`;
    }
    if (activePlayer) {
      return `${activePlayer.name} (Remote)`;
    }
    if (localPlayer) return `${localPlayer.name} (You)`;
    return isNetworkInputLocked() ? "Remote Commander" : "Your Commander";
  }
  if (isPassPlayMode()) {
    return `Commander ${currentCommanderNumber()}`;
  }
  return "Player";
}

function sanitizeNetworkPlayerName(value) {
  const raw = typeof value === "string" ? value.trim() : "";
  if (!raw) return "Commander";
  return raw.replace(/\s+/g, " ").slice(0, 24);
}

function normalizeNetworkOwnerSlot(value) {
  const slot = typeof value === "string" ? value.trim() : "";
  return NETWORK_HUMAN_OWNER_SLOTS.includes(slot) ? slot : "";
}

function networkLocalPlayer() {
  if (!state.multiplayer.network.playerId) return null;
  return state.multiplayer.network.players.find((entry) => entry.id === state.multiplayer.network.playerId) || null;
}

function networkActivePlayer() {
  if (!state.multiplayer.network.activePlayerId) return null;
  return state.multiplayer.network.players.find((entry) => entry.id === state.multiplayer.network.activePlayerId) || null;
}

function networkCountrySelectionMap(players = state.multiplayer.network.players) {
  const byCountry = {};
  players.forEach((entry) => {
    if (!entry || !entry.countryId) return;
    byCountry[entry.countryId] = entry;
  });
  return byCountry;
}

function syncNetworkOwnerAssignments() {
  const players = Array.isArray(state.multiplayer.network.players)
    ? state.multiplayer.network.players
    : [];
  const byPlayerId = {};
  const byOwner = {};
  const assignedOwners = new Set();

  players.forEach((entry, index) => {
    if (!entry?.id) return;
    let owner = normalizeNetworkOwnerSlot(entry.ownerSlot);
    if (!owner || assignedOwners.has(owner)) {
      owner = NETWORK_HUMAN_OWNER_SLOTS.find((slot) => !assignedOwners.has(slot)) || "";
    }
    if (!owner) {
      const slotIndex = Math.max(0, Math.min(NETWORK_HUMAN_OWNER_SLOTS.length - 1, index));
      owner = NETWORK_HUMAN_OWNER_SLOTS[slotIndex];
    }
    assignedOwners.add(owner);
    byPlayerId[entry.id] = owner;
    if (entry.countryId) {
      byOwner[owner] = entry.countryId;
    }
  });

  state.multiplayer.network.ownerByPlayerId = byPlayerId;
  state.multiplayer.network.ownerCountryByOwner = byOwner;
}

function networkOwnerForPlayerId(playerId) {
  if (!playerId) return "";
  return state.multiplayer.network.ownerByPlayerId[playerId] || "";
}

function networkPlayerForOwner(owner) {
  if (!owner) return null;
  const players = Array.isArray(state.multiplayer.network.players)
    ? state.multiplayer.network.players
    : [];
  return players.find((entry) => networkOwnerForPlayerId(entry.id) === owner) || null;
}

function isNetworkHumanOwner(owner) {
  if (!owner) return false;
  if (!isNetworkMode()) return owner === "player";
  return Object.values(state.multiplayer.network.ownerByPlayerId || {}).includes(owner);
}

function localHumanOwner() {
  if (isNetworkMode()) {
    const mapped = networkOwnerForPlayerId(state.multiplayer.network.playerId);
    if (mapped) return mapped;
  }
  return "player";
}

function activeNetworkOwner() {
  if (isNetworkMode()) {
    const mapped = networkOwnerForPlayerId(state.multiplayer.network.activePlayerId);
    if (mapped) return mapped;
  }
  return state.turn || "player";
}

function ownerCapitalTerritory(owner = localHumanOwner()) {
  if (!owner) return null;
  if (isNetworkMode()) {
    const countryId = state.multiplayer.network.ownerCountryByOwner?.[owner];
    if (countryId) return resolveStartingCountry(countryId).territory;
  }
  if (owner === "player") {
    return state.homeBase || resolveStartingCountry(state.playerCountryId).territory;
  }
  return null;
}

function syncHomeBaseForTurnOwner() {
  if (!isNetworkMode()) return;
  const homeBase = ownerCapitalTerritory(state.turn);
  if (homeBase) {
    state.homeBase = homeBase;
  }
}

function isLocalTurnOwner() {
  return state.turn === localHumanOwner();
}

function nextNetworkPlayerId(currentPlayerId = state.multiplayer.network.activePlayerId || state.multiplayer.network.playerId) {
  const players = Array.isArray(state.multiplayer.network.players)
    ? state.multiplayer.network.players
    : [];
  if (players.length < 1) return "";
  const currentIndex = players.findIndex((entry) => entry.id === currentPlayerId);
  if (currentIndex < 0) return players[0].id || "";
  const nextIndex = (currentIndex + 1) % players.length;
  return players[nextIndex]?.id || players[0].id || "";
}

function nextNetworkHumanOwner(currentPlayerId = state.multiplayer.network.activePlayerId || state.multiplayer.network.playerId) {
  const nextPlayerId = nextNetworkPlayerId(currentPlayerId);
  return networkOwnerForPlayerId(nextPlayerId) || "player";
}

function firstNetworkHumanOwner() {
  const firstPlayerId = state.multiplayer.network.players?.[0]?.id || "";
  return networkOwnerForPlayerId(firstPlayerId) || "player";
}

function isLastNetworkHumanTurn(currentPlayerId = state.multiplayer.network.playerId || state.multiplayer.network.activePlayerId) {
  const players = Array.isArray(state.multiplayer.network.players)
    ? state.multiplayer.network.players
    : [];
  if (players.length < 2) return true;
  const currentIndex = players.findIndex((entry) => entry.id === currentPlayerId);
  if (currentIndex < 0) return true;
  return currentIndex === players.length - 1;
}

function closeNetworkChannel() {
  if (networkPollTimer) {
    clearInterval(networkPollTimer);
    networkPollTimer = null;
  }
  networkPollBusy = false;
}

function shutdownNetworkSession(options = {}) {
  const notifyServer = options?.notifyServer !== false;
  const leavingLobbyId = state.multiplayer.network.lobbyId;
  const leavingPlayerId = state.multiplayer.network.playerId;
  const cachedLobbies = Array.isArray(state.multiplayer.network.availableLobbies)
    ? state.multiplayer.network.availableLobbies.slice()
    : [];

  closeNetworkChannel();
  state.multiplayer.network.active = false;
  state.multiplayer.network.room = "";
  state.multiplayer.network.role = "host";
  state.multiplayer.network.lobbyId = "";
  state.multiplayer.network.playerId = "";
  state.multiplayer.network.hostPlayerId = "";
  state.multiplayer.network.connected = false;
  state.multiplayer.network.started = false;
  state.multiplayer.network.players = [];
  state.multiplayer.network.maxPlayers = Math.max(2, Math.min(4, state.networkSetup.maxPlayers || 4));
  state.multiplayer.network.aiEnabled = state.networkSetup.aiEnabled !== false;
  state.multiplayer.network.activePlayerId = "";
  state.multiplayer.network.payloadVersion = 0;
  state.multiplayer.network.lastAppliedPayloadVersion = 0;
  state.multiplayer.network.availableLobbies = cachedLobbies;
  state.multiplayer.network.ownerByPlayerId = {};
  state.multiplayer.network.ownerCountryByOwner = {};
  state.multiplayer.network.lastError = "";
  state.multiplayer.network.actionPending = false;
  state.multiplayer.network.waitingForRemote = false;

  if (notifyServer && leavingLobbyId && leavingPlayerId) {
    void networkApiRequest(`/lobbies/${encodeURIComponent(leavingLobbyId)}/leave`, {
      method: "POST",
      body: { playerId: leavingPlayerId },
      keepalive: true
    });
  }
}

async function networkApiRequest(path, options = {}) {
  const method = options.method || "GET";
  const headers = { Accept: "application/json" };
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    controller.abort();
  }, NETWORK_REQUEST_TIMEOUT_MS);
  const init = {
    method,
    headers,
    cache: "no-store",
    signal: controller.signal
  };
  if (options.keepalive) init.keepalive = true;
  if (options.body !== undefined) {
    headers["Content-Type"] = "application/json";
    init.body = JSON.stringify(options.body);
  }
  let response;
  try {
    response = await fetch(`/api${path}`, init);
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === "AbortError") {
      return {
        ok: false,
        status: 0,
        message: "LAN request timed out. Verify lan-server.js is running and reachable on this network."
      };
    }
    return {
      ok: false,
      status: 0,
      message: "Cannot reach the LAN game server. Make sure the host started lan-server.js."
    };
  }
  clearTimeout(timeoutId);
  let payload = null;
  try {
    payload = await response.json();
  } catch (error) {
    payload = null;
  }
  if (!response.ok && !payload) {
    if (response.status === 404 || response.status === 405 || response.status === 501) {
      return {
        ok: false,
        status: response.status,
        message: "LAN API is unavailable on this URL. Start the game with `node lan-server.js` and open that server address."
      };
    }
    return {
      ok: false,
      status: response.status,
      message: `LAN server returned ${response.status}. Confirm lan-server.js is the process serving this page.`
    };
  }
  if (!response.ok || !payload || payload.ok === false) {
    return {
      ok: false,
      status: response.status,
      message: payload?.message || `LAN request failed (${response.status}).`
    };
  }
  return payload;
}

function syncNetworkStateFromLobby(lobby, options = {}) {
  if (!lobby || typeof lobby !== "object") return;
  const network = state.multiplayer.network;
  const previousWaiting = Boolean(network.waitingForRemote);
  const previousActivePlayerId = network.activePlayerId;

  const players = Array.isArray(lobby.players)
    ? lobby.players.map((entry) => ({
      id: String(entry?.id || ""),
      name: sanitizeNetworkPlayerName(entry?.name),
      countryId: STARTING_COUNTRY_POOL.some((country) => country.id === entry?.countryId) ? entry.countryId : "",
      ownerSlot: normalizeNetworkOwnerSlot(entry?.ownerSlot),
      isHost: Boolean(entry?.isHost)
    })).filter((entry) => entry.id)
    : [];

  network.players = players;
  syncNetworkOwnerAssignments();
  network.connected = players.length > 1;
  network.hostPlayerId = typeof lobby.hostPlayerId === "string" ? lobby.hostPlayerId : "";
  network.room = sanitizeNetworkRoom(lobby.room || lobby.name || state.networkSetup.room);
  network.maxPlayers = Math.max(2, Math.min(4, Number.parseInt(lobby.maxPlayers, 10) || network.maxPlayers || 4));
  network.aiEnabled = lobby.aiEnabled !== false;
  network.started = lobby.status === "started";
  network.activePlayerId = typeof lobby.activePlayerId === "string" ? lobby.activePlayerId : "";
  network.payloadVersion = Math.max(0, Math.floor(Number(lobby.payloadVersion) || 0));
  network.lastError = "";

  state.networkSetup.room = network.room;
  state.networkSetup.maxPlayers = network.maxPlayers;
  state.networkSetup.aiEnabled = network.aiEnabled;
  if (lobby.settings && typeof lobby.settings === "object") {
    state.setupOptions = normalizeSetupOptions(lobby.settings);
  }

  const local = networkLocalPlayer();
  if (local && local.countryId) {
    state.playerCountryId = local.countryId;
    state.networkSetup.countryChosen = true;
  }

  const shouldWait = network.started &&
    Boolean(network.activePlayerId) &&
    Boolean(network.playerId) &&
    network.activePlayerId !== network.playerId;
  setNetworkWaiting(shouldWait);

  if (network.started) {
    state.turn = activeNetworkOwner();
    syncHomeBaseForTurnOwner();
  }

  const canApplyPayload = options.applyPayload !== false &&
    network.started &&
    lobby.payload &&
    network.payloadVersion > network.lastAppliedPayloadVersion;

  if (canApplyPayload) {
    const loaded = applyNetworkPayload(lobby.payload);
    if (!loaded.ok) {
      showBattleOutcome(loaded.message || "Network sync failed.", false, false);
    } else {
      network.lastAppliedPayloadVersion = network.payloadVersion;
      if (state.setupOpen) hideCountryPicker();
      if (isNetworkInputLocked()) {
        addLog("LAN sync received. Waiting for active commander.");
      } else {
        addLog("LAN sync received. Your turn is ready.");
      }
    }
  }

  if (!shouldWait && previousWaiting && network.started) {
    const previousActive = players.find((entry) => entry.id === previousActivePlayerId);
    const previousName = previousActive?.name || "Remote commander";
    const localName = networkLocalPlayer()?.name || ownerName(localHumanOwner());
    const instruction = currentTurnActionInstruction();
    addLog(`${localName} is up. ${previousName} finished turn.`);
    showBattleOutcome(`${previousName} turn summary received. ${localName}, your turn: ${instruction}`, true, true);
    playSound("ding");
  } else if (shouldWait && !previousWaiting && network.started) {
    const activeNow = networkActivePlayer();
    const activeName = activeNow ? activeNow.name : "Remote commander";
    addLog(`Turn passed to ${activeName}. Waiting while they issue orders.`);
  }

  if (previousActivePlayerId !== network.activePlayerId && state.setupOpen) {
    renderSetupWizard();
  }
}

async function refreshHostedLobbies(force = false) {
  if (networkLobbyBrowseBusy) {
    networkLobbyBrowseQueued = networkLobbyBrowseQueued || force;
    return;
  }
  const now = Date.now();
  if (!force && now - networkLastLobbyBrowseAt < 1300) return;

  networkLobbyBrowseBusy = true;
  networkLastLobbyBrowseAt = now;
  const response = await networkApiRequest("/lobbies");
  if (response.ok) {
    clearNetworkSetupError();
    state.multiplayer.network.availableLobbies = Array.isArray(response.lobbies) ? response.lobbies : [];
    const selected = state.multiplayer.network.availableLobbies.find((entry) => entry.id === state.networkSetup.selectedLobbyId);
    if (!selected && state.networkSetup.role === "join") {
      state.networkSetup.selectedLobbyId = "";
    }
    if (selected && selected.settings) {
      state.setupOptions = normalizeSetupOptions(selected.settings);
      state.networkSetup.maxPlayers = Math.max(2, Math.min(4, Number.parseInt(selected.maxPlayers, 10) || state.networkSetup.maxPlayers));
      state.networkSetup.aiEnabled = selected.aiEnabled !== false;
    }
    if (state.setupOpen && state.setupOptions.playMode === "network" && state.networkSetup.role === "join") {
      renderSetupWizard();
      render();
    }
  } else if (force) {
    const message = response.message || "Unable to browse LAN lobbies.";
    setNetworkSetupError(message, true);
  }
  networkLobbyBrowseBusy = false;
  if (networkLobbyBrowseQueued) {
    networkLobbyBrowseQueued = false;
    void refreshHostedLobbies(true);
  }
}

async function refreshActiveNetworkLobby(showErrors = false) {
  if (!state.multiplayer.network.active || !state.multiplayer.network.lobbyId || !state.multiplayer.network.playerId) {
    return { ok: false, message: "No active network lobby." };
  }
  const lobbyId = encodeURIComponent(state.multiplayer.network.lobbyId);
  const playerId = encodeURIComponent(state.multiplayer.network.playerId);
  const since = Math.max(0, Math.floor(state.multiplayer.network.lastAppliedPayloadVersion || 0));
  const response = await networkApiRequest(`/lobbies/${lobbyId}?playerId=${playerId}&since=${since}`);
  if (!response.ok) {
    const status = Number(response.status) || 0;
    if (status === 404 || status === 403) {
      const missingMessage = response.message || "Lobby is no longer active.";
      shutdownNetworkSession({ notifyServer: false });
      if (showErrors || state.setupOpen) {
        showBattleOutcome(missingMessage, false, false);
      }
      if (state.setupOpen) {
        renderSetupWizard();
        render();
      }
      return { ok: false, message: missingMessage, status };
    }
    if (showErrors) showBattleOutcome(response.message || "Failed to refresh lobby state.", false, false);
    state.multiplayer.network.connected = false;
    return response;
  }
  if (!response.lobby) {
    const missingMessage = "Lobby no longer exists.";
    if (showErrors) showBattleOutcome(missingMessage, false, false);
    shutdownNetworkSession({ notifyServer: false });
    if (state.setupOpen) {
      renderSetupWizard();
      render();
    }
    return { ok: false, message: missingMessage };
  }
  syncNetworkStateFromLobby(response.lobby);
  if (state.setupOpen && state.setupOptions.playMode === "network") {
    renderSetupWizard();
  }
  render();
  return { ok: true };
}

function startNetworkPolling() {
  closeNetworkChannel();
  void refreshActiveNetworkLobby(false);
  networkPollTimer = setInterval(() => {
    if (networkPollBusy) return;
    networkPollBusy = true;
    void refreshActiveNetworkLobby(false).finally(() => {
      networkPollBusy = false;
    });
  }, NETWORK_POLL_INTERVAL_MS);
}

function setNetworkWaiting(waiting) {
  state.multiplayer.network.waitingForRemote = Boolean(waiting);
}

function setNetworkSetupError(message, showOutcome = false) {
  state.multiplayer.network.lastError = String(message || "").trim();
  if (showOutcome && state.multiplayer.network.lastError) {
    showBattleOutcome(state.multiplayer.network.lastError, false, state.setupOpen);
  }
}

function clearNetworkSetupError() {
  state.multiplayer.network.lastError = "";
}

function validateNetworkSetupBeforeLobbyAction() {
  if (state.setupOptions.playMode !== "network") return "";
  if (window.location.protocol === "file:") {
    return "LAN mode cannot run from file://. Start `node lan-server.js` and open the server URL (for example http://localhost:8080).";
  }
  const role = state.networkSetup.role === "join" ? "join" : "host";
  const playerNameRaw = typeof state.networkSetup.playerName === "string"
    ? state.networkSetup.playerName.trim()
    : "";
  if (!playerNameRaw) {
    return "Enter a commander name before continuing.";
  }
  if (role === "host") {
    const roomRaw = typeof state.networkSetup.room === "string"
      ? state.networkSetup.room.trim()
      : "";
    if (!roomRaw) {
      return "Enter a lobby code before opening a lobby.";
    }
    if (!state.networkSetup.countryChosen) {
      return "Choose your country before opening a lobby.";
    }
    return "";
  }
  if (!state.networkSetup.selectedLobbyId) {
    return "Select a hosted LAN lobby before joining.";
  }
  return "";
}

function networkLobbyStateForSetup() {
  const role = state.networkSetup.role === "join" ? "join" : "host";
  const room = sanitizeNetworkRoom(state.networkSetup.room);
  const active = state.multiplayer.network.active;
  const pending = state.multiplayer.network.actionPending;
  const started = state.multiplayer.network.started;
  const players = state.multiplayer.network.players;
  const playerCount = players.length;
  const pickedCount = players.reduce((sum, entry) => sum + (entry.countryId ? 1 : 0), 0);
  const selectedLobby = state.multiplayer.network.availableLobbies.find((entry) => entry.id === state.networkSetup.selectedLobbyId);

  if (pending) {
    const buttonLabel = role === "join" ? "Joining..." : "Opening...";
    return {
      buttonLabel,
      canStart: false,
      status: role === "join"
        ? "Joining selected LAN lobby..."
        : "Opening LAN lobby..."
    };
  }

  if (!active) {
    if (role === "host") {
      return {
        buttonLabel: "Open Lobby",
        canStart: true,
        status: `Host "${room}" on LAN. Choose your country first, then wait for up to ${state.networkSetup.maxPlayers} total players.`
      };
    }
    const joinable = Boolean(selectedLobby && selectedLobby.status === "open");
    return {
      buttonLabel: "Join Selected Lobby",
      canStart: joinable,
      status: selectedLobby
        ? selectedLobby.status === "open"
          ? `Previewing "${selectedLobby.room}". Settings are host-controlled; you can only choose an unclaimed country.`
          : `"${selectedLobby.room}" is already in a live match. Choose another hosted lobby.`
        : "Browse LAN hosted games, select one, then join."
    };
  }

  if (started) {
    const activeCommander = networkActivePlayer();
    return {
      buttonLabel: role === "host" ? "Match Running" : "Waiting for Turn",
      canStart: false,
      status: activeCommander
        ? `Match in progress. Active commander: ${activeCommander.name}.`
        : "Match in progress."
    };
  }

  if (role === "host") {
    const hasEnoughPlayers = playerCount >= 2;
    const everyonePicked = playerCount > 0 && pickedCount === playerCount;
    const canLaunch = hasEnoughPlayers && everyonePicked;
    let status = `Lobby open (${playerCount}/${state.multiplayer.network.maxPlayers}). `;
    if (!hasEnoughPlayers) {
      status += "Need at least 2 LAN players.";
    } else if (!everyonePicked) {
      status += "Waiting for all players to choose unique countries.";
    } else {
      status += "All commanders ready. Launch when ready.";
    }
    return {
      buttonLabel: "Launch Match",
      canStart: canLaunch,
      status
    };
  }

  return {
    buttonLabel: "Waiting for Host",
    canStart: false,
    status: `Joined "${state.multiplayer.network.room}". Waiting for host launch.`
  };
}

function networkPayloadFromCurrentState() {
  return {
    version: SAVE_FORMAT_VERSION,
    savedAt: new Date().toISOString(),
    game: captureGameSaveSnapshot()
  };
}

function applyNetworkPayload(payload) {
  const storage = getSaveStorage();
  if (!storage) return { ok: false, message: "Local storage is unavailable for network sync." };
  try {
    storage.setItem(SAVE_STORAGE_KEY, JSON.stringify(payload));
  } catch (error) {
    return { ok: false, message: "Failed to stage remote state in local storage." };
  }
  return loadGameFromStorage();
}

async function beginNetworkSessionFromSetup() {
  const validationError = validateNetworkSetupBeforeLobbyAction();
  if (validationError) {
    setNetworkSetupError(validationError, true);
    return { ok: false, message: validationError };
  }

  const role = state.networkSetup.role === "join" ? "join" : "host";
  const room = sanitizeNetworkRoom(state.networkSetup.room);
  const playerName = sanitizeNetworkPlayerName(state.networkSetup.playerName);
  state.networkSetup.role = role;
  state.networkSetup.room = room;
  state.networkSetup.playerName = playerName;
  clearNetworkSetupError();

  if (state.multiplayer.network.active) {
    shutdownNetworkSession();
  }

  let response;
  if (role === "host") {
    response = await networkApiRequest("/lobbies", {
      method: "POST",
      body: {
        room,
        playerName,
        countryId: state.playerCountryId,
        maxPlayers: Math.max(2, Math.min(4, state.networkSetup.maxPlayers || 4)),
        aiEnabled: state.networkSetup.aiEnabled !== false,
        settings: normalizeSetupOptions(state.setupOptions)
      }
    });
  } else {
    if (!state.networkSetup.selectedLobbyId) {
      const message = "Choose a hosted LAN lobby first.";
      setNetworkSetupError(message, true);
      return { ok: false, message };
    }
    response = await networkApiRequest(`/lobbies/${encodeURIComponent(state.networkSetup.selectedLobbyId)}/join`, {
      method: "POST",
      body: {
        playerName,
        countryId: state.playerCountryId
      }
    });
  }

  if (!response.ok || !response.lobby || !response.playerId) {
    const message = response.message || "Failed to open LAN lobby.";
    setNetworkSetupError(message, true);
    return { ok: false, message };
  }

  state.multiplayer.network.active = true;
  state.multiplayer.network.role = role;
  state.multiplayer.network.playerId = String(response.playerId);
  state.multiplayer.network.lobbyId = String(response.lobby.id || "");
  state.multiplayer.network.room = sanitizeNetworkRoom(response.lobby.room || room);
  state.multiplayer.network.lastAppliedPayloadVersion = 0;
  state.multiplayer.network.payloadVersion = 0;
  state.networkSetup.selectedLobbyId = state.multiplayer.network.lobbyId;

  syncNetworkStateFromLobby(response.lobby, { applyPayload: false });
  startNetworkPolling();

  if (role === "host") {
    addLog(`LAN lobby "${state.multiplayer.network.room}" opened. Waiting for commanders.`);
    showBattleOutcome(`LAN lobby "${state.multiplayer.network.room}" opened. Share this host on your local network.`, true, false);
  } else {
    addLog(`Joined LAN lobby "${state.multiplayer.network.room}" as ${playerName}.`);
    showBattleOutcome(`Joined "${state.multiplayer.network.room}". Waiting for host launch.`, true, false);
  }
  clearNetworkSetupError();
  return { ok: true };
}

async function updateHostedNetworkSettings() {
  if (!state.multiplayer.network.active || state.multiplayer.network.role !== "host") return { ok: false };
  const response = await networkApiRequest(`/lobbies/${encodeURIComponent(state.multiplayer.network.lobbyId)}/settings`, {
    method: "POST",
    body: {
      playerId: state.multiplayer.network.playerId,
      maxPlayers: Math.max(2, Math.min(4, state.networkSetup.maxPlayers || 4)),
      aiEnabled: state.networkSetup.aiEnabled !== false,
      settings: normalizeSetupOptions(state.setupOptions)
    }
  });
  if (!response.ok || !response.lobby) {
    const message = response.message || "Failed to update host settings.";
    setNetworkSetupError(message, true);
    return { ok: false };
  }
  clearNetworkSetupError();
  syncNetworkStateFromLobby(response.lobby, { applyPayload: false });
  if (state.setupOpen) {
    renderSetupWizard();
    render();
  }
  return { ok: true };
}

async function selectNetworkCountry(countryId) {
  const resolved = resolveStartingCountry(countryId).id;
  if (!state.multiplayer.network.active) {
    state.playerCountryId = resolved;
    return { ok: true };
  }
  const response = await networkApiRequest(`/lobbies/${encodeURIComponent(state.multiplayer.network.lobbyId)}/select-country`, {
    method: "POST",
    body: {
      playerId: state.multiplayer.network.playerId,
      countryId: resolved
    }
  });
  if (!response.ok || !response.lobby) {
    const message = response.message || "Country is unavailable.";
    setNetworkSetupError(message, true);
    return { ok: false };
  }
  clearNetworkSetupError();
  syncNetworkStateFromLobby(response.lobby, { applyPayload: false });
  if (state.setupOpen) {
    renderSetupWizard();
    render();
  }
  return { ok: true };
}

async function sendNetworkHandoff() {
  if (!state.multiplayer.network.active || !state.multiplayer.network.playerId || !state.multiplayer.network.lobbyId) {
    return false;
  }
  const response = await networkApiRequest(`/lobbies/${encodeURIComponent(state.multiplayer.network.lobbyId)}/handoff`, {
    method: "POST",
    body: {
      playerId: state.multiplayer.network.playerId,
      payload: networkPayloadFromCurrentState()
    }
  });
  if (!response.ok || !response.lobby) {
    setNetworkSetupError(response.message || "LAN handoff failed.");
    return false;
  }
  clearNetworkSetupError();
  syncNetworkStateFromLobby(response.lobby, { applyPayload: false });
  state.multiplayer.network.lastAppliedPayloadVersion = Math.max(
    state.multiplayer.network.lastAppliedPayloadVersion,
    state.multiplayer.network.payloadVersion
  );
  return true;
}

function applyNetworkHumanOwnershipAtLaunch() {
  if (!state.multiplayer.network.active) return;
  syncNetworkOwnerAssignments();

  const difficulty = setupDifficultyById(state.setupOptions.difficulty);
  const humanOwners = new Set();
  const humanCapitalsByOwner = {};

  state.multiplayer.network.players.forEach((entry) => {
    const owner = networkOwnerForPlayerId(entry.id);
    if (!owner || !entry.countryId) return;
    const capitalTerritory = resolveStartingCountry(entry.countryId).territory;
    humanOwners.add(owner);
    humanCapitalsByOwner[owner] = capitalTerritory;
    state.territories[capitalTerritory] = {
      owner,
      armies: difficulty.playerStartArmies,
      fortified: 0
    };
  });

  const availableAiOwners = AI_OWNERS.filter((owner) => !humanOwners.has(owner));
  let aiOwnerIndex = 0;
  Object.entries(state.territories).forEach(([name, territory]) => {
    if (!humanOwners.has(territory.owner)) return;
    const reservedCapital = humanCapitalsByOwner[territory.owner];
    if (reservedCapital && name === reservedCapital) return;
    if (state.multiplayer.network.aiEnabled && availableAiOwners.length > 0) {
      const reassignedOwner = availableAiOwners[aiOwnerIndex % availableAiOwners.length];
      aiOwnerIndex += 1;
      territory.owner = reassignedOwner;
    } else {
      territory.owner = "neutral";
      territory.fortified = 0;
    }
  });

  if (state.multiplayer.network.aiEnabled === false) {
    Object.values(state.territories).forEach((territory) => {
      if (territory.owner === "neutral") return;
      if (humanOwners.has(territory.owner)) return;
      territory.owner = "neutral";
      territory.fortified = 0;
    });
    AI_OWNERS.forEach((owner) => {
      state.aiShips[owner] = 0;
    });
  }

  Object.entries(humanCapitalsByOwner).forEach(([owner, territoryName]) => {
    const existing = state.territories[territoryName] || { armies: difficulty.playerStartArmies };
    state.territories[territoryName] = {
      owner,
      armies: Math.max(difficulty.playerStartArmies, Math.round(Number(existing.armies) || difficulty.playerStartArmies)),
      fortified: 0
    };
  });

  const existingTreasuryByOwner = state.treasuryByOwner && typeof state.treasuryByOwner === "object"
    ? state.treasuryByOwner
    : {};
  const treasuryByOwner = {};
  humanOwners.forEach((owner) => {
    treasuryByOwner[owner] = Math.max(0, Math.round(Number(existingTreasuryByOwner[owner]) || STARTING_TREASURY));
  });
  if (Object.keys(treasuryByOwner).length < 1) {
    treasuryByOwner.player = STARTING_TREASURY;
  }
  state.treasuryByOwner = treasuryByOwner;
  syncDisplayedTreasury();

  state.turn = activeNetworkOwner() || networkOwnerForPlayerId(state.multiplayer.network.hostPlayerId) || "player";
  state.phase = "reinforce";
  state.reinforcementsLeft = reinforcementFor(state.turn);
  state.selection = { from: null, to: null };
  state.attackForce = 1;
  state.attackShips = 0;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  syncHomeBaseForTurnOwner();
}

async function launchHostedNetworkMatch() {
  if (!state.multiplayer.network.active || state.multiplayer.network.role !== "host") {
    return { ok: false, message: "Open a host lobby first." };
  }
  if (state.multiplayer.network.players.length < 2) {
    return { ok: false, message: "Need at least 2 LAN players before launch." };
  }
  const unselected = state.multiplayer.network.players.filter((entry) => !entry.countryId);
  if (unselected.length > 0) {
    return { ok: false, message: "Every player must select a country before launch." };
  }

  initGame(state.playerCountryId);
  applyNetworkHumanOwnershipAtLaunch();
  setNetworkWaiting(false);
  hideCountryPicker();
  const response = await networkApiRequest(`/lobbies/${encodeURIComponent(state.multiplayer.network.lobbyId)}/start`, {
    method: "POST",
    body: {
      playerId: state.multiplayer.network.playerId,
      payload: networkPayloadFromCurrentState()
    }
  });
  if (!response.ok || !response.lobby) {
    const message = response.message || "Failed to launch LAN match.";
    setNetworkSetupError(message);
    return { ok: false, message };
  }
  clearNetworkSetupError();
  syncNetworkStateFromLobby(response.lobby, { applyPayload: false });
  state.multiplayer.network.lastAppliedPayloadVersion = Math.max(
    state.multiplayer.network.lastAppliedPayloadVersion,
    state.multiplayer.network.payloadVersion
  );
  addLog(`LAN match launched in "${state.multiplayer.network.room}".`);
  showBattleOutcome("LAN match started.", true, false);
  render();
  return { ok: true };
}
function setupDifficultyForOwner(owner) {
  const difficulty = setupDifficultyById(state.setupOptions.difficulty);
  if (owner === "player" || isNetworkHumanOwner(owner)) {
    return difficulty.playerReinforcementBonus;
  }
  if (isAIOwner(owner)) {
    return difficulty.aiReinforcementBonus;
  }
  return 0;
}

function resetSetupToDefaults(preferredCountryId = state.playerCountryId) {
  state.setupStep = DEFAULT_SETUP_OPTIONS.step;
  state.setupTab = DEFAULT_SETUP_OPTIONS.tab;
  state.setupOptions = {
    playMode: DEFAULT_SETUP_OPTIONS.playMode,
    mapPreset: DEFAULT_SETUP_OPTIONS.mapPreset,
    rulesPreset: DEFAULT_SETUP_OPTIONS.rulesPreset,
    difficulty: DEFAULT_SETUP_OPTIONS.difficulty,
    campaignMode: DEFAULT_SETUP_OPTIONS.campaignMode,
    passPlayers: DEFAULT_SETUP_OPTIONS.passPlayers
  };
  state.networkSetup = {
    role: "host",
    room: MULTIPLAYER_DEFAULT_ROOM,
    playerName: sanitizeNetworkPlayerName(state.networkSetup.playerName || "Commander"),
    selectedLobbyId: "",
    maxPlayers: 4,
    aiEnabled: true,
    countryChosen: false
  };
  state.playerCountryId = resolveStartingCountry(preferredCountryId).id;
  state.multiplayer.network.availableLobbies = [];
}

function setupSummaryLine() {
  const mode = setupModeById(state.setupOptions.playMode);
  const difficulty = setupDifficultyById(state.setupOptions.difficulty);
  const mapPreset = setupMapPresetById(state.setupOptions.mapPreset);
  const campaignMode = setupCampaignModeById(state.setupOptions.campaignMode);
  const country = resolveStartingCountry(state.playerCountryId);
  const displayCountry = state.setupOptions.playMode === "network" && !state.networkSetup.countryChosen
    ? "Choose Country"
    : country.name;
  const parts = [
    `${mode.name}`,
    `${difficulty.name}`,
    `${mapPreset.name}`,
    `${campaignMode.name}`,
    displayCountry
  ];
  if (state.setupOptions.playMode === "pass-play") {
    parts.push(`${state.setupOptions.passPlayers} players`);
  }
  if (state.setupOptions.playMode === "network") {
    const roleText = state.networkSetup.role === "join" ? "Join" : "Host";
    const aiMode = (state.multiplayer.network.active
      ? state.multiplayer.network.aiEnabled
      : state.networkSetup.aiEnabled) ? "AI On" : "LAN Only";
    const roomLabel = state.multiplayer.network.active
      ? state.multiplayer.network.room
      : sanitizeNetworkRoom(state.networkSetup.room);
    if (state.multiplayer.network.active) {
      const playerCount = state.multiplayer.network.players.length;
      parts.push(`${roleText}  Lobby ${roomLabel}  ${playerCount}/${state.multiplayer.network.maxPlayers} players  ${aiMode}`);
    } else {
      parts.push(`${roleText}  Lobby ${roomLabel}  Max ${state.networkSetup.maxPlayers} players  ${aiMode}`);
    }
  }
  return parts.join("  ");
}

async function launchCampaignFromSetup() {
  const mode = setupModeById(state.setupOptions.playMode);
  const difficulty = setupDifficultyById(state.setupOptions.difficulty);
  const mapPreset = setupMapPresetById(state.setupOptions.mapPreset);
  const rulesPreset = setupRulesPresetById(state.setupOptions.rulesPreset);
  const campaignMode = setupCampaignModeById(state.setupOptions.campaignMode);
  const passPlayers = Math.max(2, Math.min(6, state.setupOptions.passPlayers || 2));
  state.setupOptions.passPlayers = passPlayers;
  state.multiplayer.commanderIndex = 0;
  if (mode.id === "network") {
    if (state.multiplayer.network.actionPending) return;
    state.multiplayer.network.actionPending = true;
    renderSetupWizard();
    render();
    try {
      if (!state.multiplayer.network.active) {
        const networkStart = await beginNetworkSessionFromSetup();
        if (!networkStart.ok) {
          setNetworkSetupError(networkStart.message || "Unable to open lobby.", true);
        } else {
          clearNetworkSetupError();
          showBattleOutcome(networkLobbyStateForSetup().status, true, false);
        }
        renderSetupWizard();
        render();
        return;
      }
      if (state.networkSetup.role === "join") {
        const refreshed = await refreshActiveNetworkLobby(false);
        if (!refreshed.ok) {
          setNetworkSetupError(refreshed.message || "Could not refresh lobby.", true);
        }
        showBattleOutcome(networkLobbyStateForSetup().status, true, false);
        renderSetupWizard();
        render();
        return;
      }
      const launched = await launchHostedNetworkMatch();
      if (!launched.ok) {
        setNetworkSetupError(launched.message || "Unable to launch LAN match.", true);
        renderSetupWizard();
        render();
      }
      return;
    } finally {
      state.multiplayer.network.actionPending = false;
      if (state.setupOpen && state.setupOptions.playMode === "network") {
        renderSetupWizard();
        render();
      }
    }
  }
  shutdownNetworkSession();
  initGame(state.playerCountryId);
  addLog(`Setup loaded: ${mode.name}  ${difficulty.name}  ${mapPreset.name}  ${rulesPreset.name}  ${campaignMode.name}.`);
  if (mode.id !== "solo") {
    if (mode.id === "pass-play") {
      addLog(`Pass & Play active (${passPlayers} local commanders). Commander 1 begins.`);
      showBattleOutcome("Pass device as turns rotate between local commanders.", true, false);
    } else {
      addLog(`${mode.name} scaffolding enabled. Networking flow is planned next.`);
    }
  }
  render();
}

function hideCountryPicker() {
  state.setupOpen = false;
  if (countryPickerEl) countryPickerEl.classList.remove("visible");
}

function renderCountryPickerOptions() {
  const pickerOptionsEl = document.getElementById("country-picker-options");
  if (!pickerOptionsEl) return;
  pickerOptionsEl.innerHTML = "";
  const networkMode = state.setupOptions.playMode === "network";
  const networkActive = networkMode && state.multiplayer.network.active;
  const selectedByCountry = networkActive ? networkCountrySelectionMap() : {};
  const localPlayerId = state.multiplayer.network.playerId;

  STARTING_COUNTRY_POOL.forEach((country) => {
    const button = document.createElement("button");
    button.type = "button";
    button.id = `country-choice-${country.id}`;
    button.className = "country-option-btn";
    const selectedEntry = selectedByCountry[country.id] || null;
    const selectedByMe = Boolean(selectedEntry && selectedEntry.id === localPlayerId);
    const selectedByOther = Boolean(selectedEntry && !selectedByMe);
    const localPreLobbySelection = networkMode
      ? state.networkSetup.countryChosen && country.id === state.playerCountryId
      : country.id === state.playerCountryId;
    const selected = networkMode && networkActive
      ? selectedByMe
      : localPreLobbySelection;
    button.classList.toggle("selected", selected);
    button.classList.toggle("locked", selectedByOther);
    button.disabled = selectedByOther;

    const header = document.createElement("span");
    header.className = "country-option-header";

    const flag = document.createElement("span");
    flag.className = "country-option-flag";
    flag.dataset.countryId = country.id;
    flag.textContent = STARTING_COUNTRY_FLAGS[country.id] || "";
    flag.setAttribute("aria-hidden", "true");

    const countryName = document.createElement("span");
    countryName.className = "country-option-name";
    countryName.textContent = country.name;

    const capitalName = territoryLabel(country.territory, country.territory);
    const capital = document.createElement("span");
    capital.className = "country-option-capital";
    let selectionNote = "";
    if (networkMode) {
      if (selectedEntry) {
        const hostBadge = selectedEntry.isHost ? " (Host)" : "";
        selectionNote = ` \u00b7 ${selectedByMe ? "You" : selectedEntry.name}${hostBadge}`;
      } else {
        selectionNote = " \u00b7 Available";
      }
    }
    capital.textContent = `Capital: ${capitalName}${selectionNote}`;

    header.appendChild(flag);
    header.appendChild(countryName);
    button.appendChild(header);
    button.appendChild(capital);
    button.addEventListener("click", () => {
      if (selectedByOther) return;
      if (networkMode) {
        void (async () => {
          const selected = await selectNetworkCountry(country.id);
          if (!selected.ok) return;
          state.networkSetup.countryChosen = true;
          clearNetworkSetupError();
          playSound("select");
          renderSetupWizard();
          render();
        })();
        return;
      }
      state.playerCountryId = country.id;
      state.networkSetup.countryChosen = true;
      clearNetworkSetupError();
      playSound("select");
      renderSetupWizard();
      render();
    });

    pickerOptionsEl.appendChild(button);
  });
}

function escapeHtml(value) {
  return String(value ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function countryNameFromId(countryId) {
  const country = STARTING_COUNTRY_POOL.find((entry) => entry.id === countryId);
  return country ? country.name : "Unselected";
}

function networkRosterMarkup(players, hostPlayerId) {
  if (!Array.isArray(players) || players.length < 1) {
    return `<p class="setup-rule-copy">No commanders connected yet.</p>`;
  }
  return `
    <div class="network-player-list">
      ${players.map((entry) => {
    const name = escapeHtml(entry.name || "Commander");
    const hostTag = entry.id === hostPlayerId ? " (Host)" : "";
    const country = entry.countryId ? escapeHtml(countryNameFromId(entry.countryId)) : "Unselected";
    return `
          <div class="network-player-row">
            <span>${name}${hostTag}</span>
            <span>${country}</span>
          </div>
        `;
  }).join("")}
    </div>
  `;
}

function networkLobbySettingsSummary(lobby) {
  const settings = lobby?.settings || {};
  const mapName = setupMapPresetById(settings.mapPreset).name;
  const rulesName = setupRulesPresetById(settings.rulesPreset).name;
  const difficultyName = setupDifficultyById(settings.difficulty).name;
  const modeName = setupCampaignModeById(settings.campaignMode).name;
  return `${mapName}  ${rulesName}  ${difficultyName}  ${modeName}`;
}

function networkLobbyClaimsSummary(lobby) {
  const players = Array.isArray(lobby?.players) ? lobby.players : [];
  if (players.length < 1) return "No players joined.";
  return players.map((entry) => {
    const name = escapeHtml(entry?.name || "Commander");
    const country = entry?.countryId ? escapeHtml(countryNameFromId(entry.countryId)) : "Unselected";
    return `${name}: ${country}`;
  }).join(" | ");
}

function renderSetupWizard() {
  if (!startScreenCreateEl || !startScreenOptionsEl || !startScreenTitleEl || !startScreenBackBtn || !startScreenNextBtn) {
    return;
  }

  const isCreateStep = state.setupStep === "create";
  const selectedMode = setupModeById(state.setupOptions.playMode);
  const selectedDifficulty = setupDifficultyById(state.setupOptions.difficulty);
  const selectedMap = setupMapPresetById(state.setupOptions.mapPreset);
  const selectedRules = setupRulesPresetById(state.setupOptions.rulesPreset);
  const selectedCampaignMode = setupCampaignModeById(state.setupOptions.campaignMode);
  const savedPayload = readSavedGamePayload();
  const hasSavedGame = Boolean(savedPayload);
  const savedTimestampLabel = hasSavedGame
    ? formatSavedTimestamp(savedPayload.savedAt)
    : "No saved game found yet.";
  const difficultyIndex = setupDifficultyIndex();
  const networkRole = state.networkSetup.role === "join" ? "join" : "host";
  const networkRoom = sanitizeNetworkRoom(state.networkSetup.room);
  const networkPlayerName = sanitizeNetworkPlayerName(state.networkSetup.playerName || "Commander");
  const networkMaxPlayers = Math.max(2, Math.min(4, Number.parseInt(state.networkSetup.maxPlayers, 10) || 4));
  const networkAiEnabled = state.networkSetup.aiEnabled !== false;
  const networkActive = state.multiplayer.network.active;
  const networkReadOnlySettings = selectedMode.id === "network" && networkRole === "join";
  const selectedLobby = state.multiplayer.network.availableLobbies.find((entry) => entry.id === state.networkSetup.selectedLobbyId);
  const networkError = selectedMode.id === "network" ? (state.multiplayer.network.lastError || "") : "";
  const networkRoster = networkRosterMarkup(
    networkActive ? state.multiplayer.network.players : [],
    state.multiplayer.network.hostPlayerId
  );
  const lobbyCardsMarkup = state.multiplayer.network.availableLobbies.length
    ? state.multiplayer.network.availableLobbies.map((lobby) => {
      const isSelected = lobby.id === state.networkSetup.selectedLobbyId;
      const roomLabel = escapeHtml(lobby.room || "lobby");
      const playerCount = Math.max(0, Number.parseInt(lobby.playerCount, 10) || (Array.isArray(lobby.players) ? lobby.players.length : 0));
      const maxPlayers = Math.max(2, Math.min(4, Number.parseInt(lobby.maxPlayers, 10) || 4));
      const aiText = lobby.aiEnabled !== false ? "AI On" : "LAN Only";
      const statusText = lobby.status === "started" ? "In Match" : "Open";
      const joinable = lobby.status !== "started";
      return `
        <button type="button" class="map-choice-btn ${isSelected ? "active" : ""}" data-network-lobby-id="${escapeHtml(lobby.id)}" ${joinable ? "" : "disabled"}>
          <span class="map-choice-title">${roomLabel}</span>
          <span class="map-choice-copy">${statusText}  ${playerCount}/${maxPlayers} players  ${aiText}</span>
          <span class="map-choice-copy">${escapeHtml(networkLobbySettingsSummary(lobby))}</span>
        </button>
      `;
    }).join("")
    : `<p class="setup-rule-copy">No hosted LAN games found yet.</p>`;
  const networkLobby = networkLobbyStateForSetup();
  state.networkSetup.role = networkRole;
  state.networkSetup.room = networkRoom;
  state.networkSetup.playerName = networkPlayerName;
  state.networkSetup.maxPlayers = networkMaxPlayers;
  state.networkSetup.aiEnabled = networkAiEnabled;

  startScreenTitleEl.textContent = isCreateStep ? "Create a game" : "Options";
  startScreenBackBtn.disabled = false;
  startScreenNextBtn.disabled = false;
  if (isCreateStep) {
    startScreenNextBtn.textContent = "Next";
  } else if (selectedMode.id === "network") {
    startScreenNextBtn.textContent = networkLobby.buttonLabel;
    startScreenNextBtn.disabled = state.multiplayer.network.actionPending || state.multiplayer.network.started;
  } else {
    startScreenNextBtn.textContent = "Start";
  }
  startScreenCreateEl.classList.toggle("visible", isCreateStep);
  startScreenOptionsEl.classList.toggle("visible", !isCreateStep);

  const soloMode = SETUP_PLAY_MODES.find((mode) => mode.id === "solo");
  const multiplayerModes = SETUP_PLAY_MODES.filter((mode) => mode.id !== "solo");

  startScreenCreateEl.innerHTML = `
    <section class="start-screen-section start-screen-card">
      <h3>Continue</h3>
      <div class="mode-grid solo">
        <button type="button" id="start-screen-continue-btn" class="mode-option-btn continue-save-btn" ${hasSavedGame ? "" : "disabled"}>
          <span class="mode-option-icon"></span>
          <span class="mode-option-name">Continue Saved Game</span>
          <span class="mode-option-copy">${hasSavedGame ? `Resume from ${savedTimestampLabel}.` : savedTimestampLabel}</span>
        </button>
      </div>
    </section>
    <section class="start-screen-section start-screen-card">
      <h3>Solo</h3>
      <div class="mode-grid solo">
        <button type="button" class="mode-option-btn ${selectedMode.id === soloMode.id ? "active" : ""}" data-mode-id="${soloMode.id}">
          <span class="mode-option-icon">${soloMode.icon}</span>
          <span class="mode-option-name">${soloMode.name}</span>
          <span class="mode-option-copy">${soloMode.summary}</span>
        </button>
      </div>
    </section>
    <section class="start-screen-section start-screen-card">
      <h3>Multi-Player</h3>
      <div class="mode-grid multi">
        ${multiplayerModes.map((mode) => `
          <button type="button" class="mode-option-btn ${selectedMode.id === mode.id ? "active" : ""}" data-mode-id="${mode.id}">
            <span class="mode-option-icon">${mode.icon}</span>
            <span class="mode-option-name">${mode.name}</span>
            <span class="mode-option-copy">${mode.summary}</span>
          </button>
        `).join("")}
      </div>
      ${selectedMode.id === "network" ? `
        <div class="setup-inline network-setup" style="margin-top:10px;">
          <div class="setup-inline-row">
            <p class="setup-inline-label">LAN Session</p>
            <p class="setup-inline-value">${networkRole === "join" ? "Join" : "Host"}</p>
          </div>
          <div class="mode-toggle-row">
            <button type="button" class="mode-toggle-btn ${networkRole === "host" ? "active" : ""}" data-network-role="host">Host</button>
            <button type="button" class="mode-toggle-btn ${networkRole === "join" ? "active" : ""}" data-network-role="join">Join</button>
          </div>
          <label class="network-room-label" for="setup-network-player-name-create">Commander name</label>
          <input id="setup-network-player-name-create" data-network-player-input="1" class="setup-network-room-input" type="text" maxlength="24" value="${escapeHtml(networkPlayerName)}" />
          ${networkRole === "host" ? `
            <label class="network-room-label" for="setup-network-room-create">Lobby code</label>
            <input id="setup-network-room-create" data-network-room-input="1" class="setup-network-room-input" type="text" maxlength="${NETWORK_ROOM_MAX_LEN}" value="${networkRoom}" ${networkActive ? "disabled" : ""} />
            <p class="setup-inline-label" style="font-size:0.8rem;">Max players</p>
            <div class="mode-toggle-row">
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 2 ? "active" : ""}" data-network-max-players="2">2</button>
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 3 ? "active" : ""}" data-network-max-players="3">3</button>
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 4 ? "active" : ""}" data-network-max-players="4">4</button>
            </div>
            <p class="setup-inline-label" style="font-size:0.8rem;">AI Factions</p>
            <div class="mode-toggle-row">
              <button type="button" class="mode-toggle-btn ${networkAiEnabled ? "active" : ""}" data-network-ai-enabled="1">AI On</button>
              <button type="button" class="mode-toggle-btn ${networkAiEnabled ? "" : "active"}" data-network-ai-enabled="0">LAN Only</button>
            </div>
          ` : `
            <button type="button" class="mode-toggle-btn" data-network-refresh="1">Refresh Hosted Games</button>
            <div class="map-choice-grid network-lobby-browser">
              ${lobbyCardsMarkup}
            </div>
            ${selectedLobby ? `
              <p class="setup-rule-copy">Preview: ${escapeHtml(networkLobbySettingsSummary(selectedLobby))}</p>
              <p class="setup-rule-copy">${networkLobbyClaimsSummary(selectedLobby)}</p>
            ` : ""}
          `}
          <p class="setup-rule-copy">${networkLobby.status}</p>
          ${networkError ? `<p class="setup-rule-copy network-error-copy">${escapeHtml(networkError)}</p>` : ""}
          ${networkActive ? `
            <p class="setup-rule-copy">Country claims</p>
            ${networkRoster}
          ` : ""}
        </div>
      ` : ""}
    </section>
  `;

  startScreenOptionsEl.innerHTML = `
    <section class="start-screen-section start-screen-card">
      <div class="setup-options-tabs">
        <button type="button" class="setup-tab-btn ${state.setupTab === "map" ? "active" : ""}" data-setup-tab="map">Map</button>
        <button type="button" class="setup-tab-btn ${state.setupTab === "rules" ? "active" : ""}" data-setup-tab="rules">Rules</button>
      </div>
      <div class="setup-tab-panel ${state.setupTab === "map" ? "visible" : ""}" data-tab-panel="map">
        <div class="map-choice-grid">
          ${SETUP_MAP_PRESETS.map((preset) => `
            <button type="button" class="map-choice-btn ${selectedMap.id === preset.id ? "active" : ""}" data-map-id="${preset.id}" ${networkReadOnlySettings ? "disabled" : ""}>
              <span class="map-choice-title">${preset.name}</span>
              <span class="map-choice-copy">${preset.summary}</span>
            </button>
          `).join("")}
        </div>
      </div>
      <div class="setup-tab-panel ${state.setupTab === "rules" ? "visible" : ""}" data-tab-panel="rules">
        <div class="mode-toggle-row">
          ${SETUP_RULE_PRESETS.map((preset) => `
            <button type="button" class="mode-toggle-btn ${selectedRules.id === preset.id ? "active" : ""}" data-rules-id="${preset.id}" ${networkReadOnlySettings ? "disabled" : ""}>
              ${preset.name}
            </button>
          `).join("")}
        </div>
        <p class="setup-rule-copy">${selectedRules.summary}</p>
      </div>
    </section>

    <section class="start-screen-section start-screen-card">
      <div class="setup-inline">
        <div class="setup-inline-row">
          <p class="setup-inline-label">Difficulty</p>
          <p class="setup-inline-value">${selectedDifficulty.name}</p>
        </div>
        <input id="setup-difficulty-slider" class="parchment-slider setup-difficulty-slider" type="range" min="0" max="${SETUP_DIFFICULTIES.length - 1}" value="${difficultyIndex}" step="1" ${networkReadOnlySettings ? "disabled" : ""} />
        <div class="setup-difficulty-scale">
          <span>Very easy</span>
          <span>Very hard</span>
        </div>
      </div>
      <div class="setup-inline" style="margin-top:10px;">
        <div class="setup-inline-row">
          <p class="setup-inline-label">Game Mode</p>
          <p class="setup-inline-value">${selectedCampaignMode.name}</p>
        </div>
        <div class="mode-toggle-row">
          ${SETUP_CAMPAIGN_MODES.map((mode) => `
            <button type="button" class="mode-toggle-btn ${selectedCampaignMode.id === mode.id ? "active" : ""}" data-campaign-mode-id="${mode.id}" ${networkReadOnlySettings ? "disabled" : ""}>
              ${mode.name}
            </button>
          `).join("")}
        </div>
      </div>
      ${selectedMode.id === "pass-play" ? `
        <div class="setup-inline" style="margin-top:10px;">
          <div class="passplay-row">
            <p>Local players</p>
            <div class="passplay-controls">
              <button type="button" class="passplay-btn" data-passplay-adjust="-1">-</button>
              <span class="passplay-count">${state.setupOptions.passPlayers}</span>
              <button type="button" class="passplay-btn" data-passplay-adjust="1">+</button>
            </div>
          </div>
        </div>
      ` : ""}
      ${selectedMode.id === "network" ? `
        <div class="setup-inline network-setup" style="margin-top:10px;">
          <div class="setup-inline-row">
            <p class="setup-inline-label">LAN Session</p>
            <p class="setup-inline-value">${networkRole === "join" ? "Join" : "Host"}</p>
          </div>
          <div class="mode-toggle-row">
            <button type="button" class="mode-toggle-btn ${networkRole === "host" ? "active" : ""}" data-network-role="host">Host</button>
            <button type="button" class="mode-toggle-btn ${networkRole === "join" ? "active" : ""}" data-network-role="join">Join</button>
          </div>
          <label class="network-room-label" for="setup-network-player-name">Commander name</label>
          <input id="setup-network-player-name" data-network-player-input="1" class="setup-network-room-input" type="text" maxlength="24" value="${escapeHtml(networkPlayerName)}" />
          ${networkRole === "host" ? `
            <label class="network-room-label" for="setup-network-room">Lobby code</label>
            <input id="setup-network-room" data-network-room-input="1" class="setup-network-room-input" type="text" maxlength="${NETWORK_ROOM_MAX_LEN}" value="${networkRoom}" ${networkActive ? "disabled" : ""} />
            <p class="setup-inline-label" style="font-size:0.8rem;">Max players</p>
            <div class="mode-toggle-row">
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 2 ? "active" : ""}" data-network-max-players="2">2</button>
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 3 ? "active" : ""}" data-network-max-players="3">3</button>
              <button type="button" class="mode-toggle-btn ${networkMaxPlayers === 4 ? "active" : ""}" data-network-max-players="4">4</button>
            </div>
            <p class="setup-inline-label" style="font-size:0.8rem;">AI Factions</p>
            <div class="mode-toggle-row">
              <button type="button" class="mode-toggle-btn ${networkAiEnabled ? "active" : ""}" data-network-ai-enabled="1">AI On</button>
              <button type="button" class="mode-toggle-btn ${networkAiEnabled ? "" : "active"}" data-network-ai-enabled="0">LAN Only</button>
            </div>
          ` : `
            <button type="button" class="mode-toggle-btn" data-network-refresh="1">Refresh Hosted Games</button>
            <div class="map-choice-grid network-lobby-browser">
              ${lobbyCardsMarkup}
            </div>
            ${selectedLobby ? `
              <p class="setup-rule-copy">Preview: ${escapeHtml(networkLobbySettingsSummary(selectedLobby))}</p>
              <p class="setup-rule-copy">${networkLobbyClaimsSummary(selectedLobby)}</p>
            ` : ""}
          `}
          <p class="setup-rule-copy">${networkLobby.status}</p>
          ${networkError ? `<p class="setup-rule-copy network-error-copy">${escapeHtml(networkError)}</p>` : ""}
          ${networkActive ? `
            <p class="setup-rule-copy">Country claims</p>
            ${networkRoster}
          ` : ""}
        </div>
      ` : ""}
    </section>

    <section class="start-screen-section start-screen-card">
      <h3>Choose Your Starting Country</h3>
      <p class="start-screen-subtitle">${selectedMode.id === "network"
        ? "Each LAN commander must claim a unique country. Joiners can preview settings, but only the host can edit them."
        : "You start at that country&apos;s capital. AI empires spawn in different major capitals."}</p>
      <div id="country-picker-options" class="country-picker-options"></div>
      <div class="setup-summary" style="margin-top:10px;">
        <strong>Summary:</strong> ${setupSummaryLine()}
      </div>
    </section>
  `;

  startScreenCreateEl.querySelectorAll("[data-mode-id]").forEach((button) => {
    button.addEventListener("click", () => {
      const nextModeId = button.dataset.modeId || DEFAULT_SETUP_OPTIONS.playMode;
      state.setupOptions.playMode = nextModeId;
      if (nextModeId !== "network" && state.multiplayer.network.active) {
        shutdownNetworkSession();
      }
      if (nextModeId !== "network") {
        clearNetworkSetupError();
      }
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  const continueBtn = document.getElementById("start-screen-continue-btn");
  if (continueBtn) {
    continueBtn.addEventListener("click", async () => {
      await unlockAudio();
      if (state.multiplayer.network.active) {
        shutdownNetworkSession();
      }
      const result = loadGameFromStorage();
      if (!result.ok) {
        showBattleOutcome(result.message, false, false);
        renderSetupWizard();
        render();
        return;
      }
      hideCountryPicker();
      playSound("select");
      showBattleOutcome(`Loaded save from ${formatSavedTimestamp(result.savedAt)}.`, true, false);
      render();
    });
  }

  startScreenOptionsEl.querySelectorAll("[data-setup-tab]").forEach((button) => {
    button.addEventListener("click", () => {
      state.setupTab = button.dataset.setupTab === "rules" ? "rules" : "map";
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  startScreenOptionsEl.querySelectorAll("[data-map-id]").forEach((button) => {
    button.addEventListener("click", () => {
      if (networkReadOnlySettings) return;
      state.setupOptions.mapPreset = setupMapPresetById(button.dataset.mapId || DEFAULT_SETUP_OPTIONS.mapPreset).id;
      playSound("select");
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      renderSetupWizard();
      render();
    });
  });

  startScreenOptionsEl.querySelectorAll("[data-rules-id]").forEach((button) => {
    button.addEventListener("click", () => {
      if (networkReadOnlySettings) return;
      state.setupOptions.rulesPreset = setupRulesPresetById(button.dataset.rulesId || DEFAULT_SETUP_OPTIONS.rulesPreset).id;
      playSound("select");
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      renderSetupWizard();
      render();
    });
  });

  startScreenOptionsEl.querySelectorAll("[data-campaign-mode-id]").forEach((button) => {
    button.addEventListener("click", () => {
      if (networkReadOnlySettings) return;
      state.setupOptions.campaignMode = setupCampaignModeById(button.dataset.campaignModeId || DEFAULT_SETUP_OPTIONS.campaignMode).id;
      playSound("select");
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      renderSetupWizard();
      render();
    });
  });

  const difficultySlider = document.getElementById("setup-difficulty-slider");
  if (difficultySlider) {
    difficultySlider.addEventListener("input", () => {
      if (networkReadOnlySettings) return;
      const nextIndex = clampNumber(Number.parseInt(difficultySlider.value, 10), 0, SETUP_DIFFICULTIES.length - 1);
      state.setupOptions.difficulty = SETUP_DIFFICULTIES[nextIndex].id;
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      renderSetupWizard();
      render();
    });
  }

  startScreenOptionsEl.querySelectorAll("[data-passplay-adjust]").forEach((button) => {
    button.addEventListener("click", () => {
      const delta = Number.parseInt(button.dataset.passplayAdjust || "0", 10) || 0;
      const next = Math.max(2, Math.min(6, state.setupOptions.passPlayers + delta));
      state.setupOptions.passPlayers = next;
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  const networkRoleButtons = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-role]")
    : [];
  networkRoleButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const role = button.dataset.networkRole === "join" ? "join" : "host";
      const changed = state.networkSetup.role !== role;
      state.networkSetup.role = role;
      if (changed && state.multiplayer.network.active) {
        shutdownNetworkSession();
      }
      clearNetworkSetupError();
      if (role === "join" && !state.multiplayer.network.active) {
        void refreshHostedLobbies(true);
      }
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  const networkRoomInputs = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-room-input]")
    : [];
  networkRoomInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      state.networkSetup.room = inputEl.value;
      clearNetworkSetupError();
    });
    inputEl.addEventListener("change", () => {
      const cleaned = sanitizeNetworkRoom(inputEl.value);
      state.networkSetup.room = cleaned;
      if (state.multiplayer.network.active && cleaned !== state.multiplayer.network.room) {
        shutdownNetworkSession();
      }
      clearNetworkSetupError();
      renderSetupWizard();
      render();
    });
    inputEl.addEventListener("blur", () => {
      const cleaned = sanitizeNetworkRoom(inputEl.value);
      if (cleaned !== inputEl.value) {
        state.networkSetup.room = cleaned;
      }
      if (state.multiplayer.network.active && cleaned !== state.multiplayer.network.room) {
        shutdownNetworkSession();
      }
      clearNetworkSetupError();
      renderSetupWizard();
      render();
    });
  });

  const networkPlayerInputs = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-player-input]")
    : [];
  networkPlayerInputs.forEach((inputEl) => {
    inputEl.addEventListener("input", () => {
      state.networkSetup.playerName = inputEl.value;
      clearNetworkSetupError();
    });
    inputEl.addEventListener("change", () => {
      state.networkSetup.playerName = sanitizeNetworkPlayerName(inputEl.value);
      clearNetworkSetupError();
      renderSetupWizard();
      render();
    });
    inputEl.addEventListener("blur", () => {
      state.networkSetup.playerName = sanitizeNetworkPlayerName(inputEl.value);
      clearNetworkSetupError();
      renderSetupWizard();
      render();
    });
  });

  const networkRefreshButtons = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-refresh]")
    : [];
  networkRefreshButtons.forEach((button) => {
    button.addEventListener("click", () => {
      clearNetworkSetupError();
      void refreshHostedLobbies(true);
      playSound("select");
    });
  });

  const networkLobbyButtons = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-lobby-id]")
    : [];
  networkLobbyButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const lobbyId = String(button.dataset.networkLobbyId || "");
      if (!lobbyId) return;
      state.networkSetup.selectedLobbyId = lobbyId;
      clearNetworkSetupError();
      const preview = state.multiplayer.network.availableLobbies.find((entry) => entry.id === lobbyId);
      if (preview?.settings) {
        state.setupOptions = normalizeSetupOptions(preview.settings);
      }
      if (preview) {
        state.networkSetup.room = sanitizeNetworkRoom(preview.room || state.networkSetup.room);
        state.networkSetup.maxPlayers = Math.max(2, Math.min(4, Number.parseInt(preview.maxPlayers, 10) || state.networkSetup.maxPlayers));
        state.networkSetup.aiEnabled = preview.aiEnabled !== false;
      }
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  const networkMaxPlayerButtons = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-max-players]")
    : [];
  networkMaxPlayerButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const next = Math.max(2, Math.min(4, Number.parseInt(button.dataset.networkMaxPlayers || "4", 10) || 4));
      state.networkSetup.maxPlayers = next;
      clearNetworkSetupError();
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  const networkAiButtons = countryPickerEl
    ? countryPickerEl.querySelectorAll("[data-network-ai-enabled]")
    : [];
  networkAiButtons.forEach((button) => {
    button.addEventListener("click", () => {
      state.networkSetup.aiEnabled = button.dataset.networkAiEnabled === "1";
      clearNetworkSetupError();
      if (selectedMode.id === "network" && state.multiplayer.network.active && state.multiplayer.network.role === "host") {
        void updateHostedNetworkSettings();
      }
      playSound("select");
      renderSetupWizard();
      render();
    });
  });

  if (selectedMode.id === "network" && networkRole === "join" && !state.multiplayer.network.active) {
    void refreshHostedLobbies(false);
  }

  renderCountryPickerOptions();
}

function showCountryPicker(preferredCountryId = state.playerCountryId) {
  if (!aimLineEl) buildMap();
  resetSetupToDefaults(preferredCountryId);
  state.setupOpen = true;
  state.animating = false;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  state.selection = { from: null, to: null };
  clearMovementCue();
  clearBattleOutcome(true);
  renderSetupWizard();
  if (countryPickerEl) countryPickerEl.classList.add("visible");
  render();
}

const worldMapEl = document.getElementById("world-map");
const mapStageEl = document.querySelector(".map-stage");
const countryPickerEl = document.getElementById("country-picker");
const startScreenBackBtn = document.getElementById("start-screen-back-btn");
const startScreenNextBtn = document.getElementById("start-screen-next-btn");
const startScreenTitleEl = document.getElementById("start-screen-title");
const startScreenCreateEl = document.getElementById("start-screen-create");
const startScreenOptionsEl = document.getElementById("start-screen-options");
const logEl = document.getElementById("log");
const turnLabel = document.getElementById("turn-label");
const phaseLabel = document.getElementById("phase-label");
const reinforcementLabel = document.getElementById("reinforcement-label");
const selectionLabel = document.getElementById("selection-label");
const regionValueLabel = document.getElementById("region-value-label");
const statusText = document.getElementById("status-text");
const ribbonText = document.getElementById("ribbon-text");
const dateLabel = document.getElementById("date-label");
const turnPill = document.getElementById("turn-pill");
const mobileMenuTurnPill = document.getElementById("mobile-menu-turn-pill");
const treasuryLabel = document.getElementById("treasury-label");
const powerPlayerEl = document.getElementById("power-player");
const powerAi1El = document.getElementById("power-ai1");
const powerAi2El = document.getElementById("power-ai2");
const powerAi3El = document.getElementById("power-ai3");
const powerAi4El = document.getElementById("power-ai4");
const powerAi5El = document.getElementById("power-ai5");
const powerAi6El = document.getElementById("power-ai6");
const powerAiCoalitionEl = document.getElementById("power-ai");
const powerNeutralEl = document.getElementById("power-neutral");
const powerPlayerLabelEl = document.getElementById("power-player-label");
const powerAiLabelEl = document.getElementById("power-ai-label");
const powerNeutralLabelEl = document.getElementById("power-neutral-label");
const powerAiEls = {
  ai1: powerAi1El,
  ai2: powerAi2El,
  ai3: powerAi3El,
  ai4: powerAi4El,
  ai5: powerAi5El,
  ai6: powerAi6El
};
const movementBadge = document.getElementById("movement-badge");
const mobileNextStepEl = document.getElementById("mobile-next-step");
const mobileNextText = document.getElementById("mobile-next-text");
const mobileNextBtn = document.getElementById("mobile-next-btn");
const mobileEndBtn = document.getElementById("mobile-end-btn");
const zoomInBtn = document.getElementById("zoom-in-btn");
const zoomOutBtn = document.getElementById("zoom-out-btn");
const zoomResetBtn = document.getElementById("zoom-reset-btn");

const startAttackBtn = document.getElementById("start-attack-btn");
const attackBtn = document.getElementById("attack-btn");
const endTurnBtn = document.getElementById("end-turn-btn");
const newGameBtn = document.getElementById("new-game-btn");
const confirmBtn = document.getElementById("confirm-btn");
const soundToggleBtn = document.getElementById("sound-toggle-btn");
const soundTestBtn = document.getElementById("sound-test-btn");
const mobileMenuBtn = document.getElementById("mobile-menu-btn");
const mobileTopMenuEl = document.getElementById("mobile-top-menu");
const mobileMenuHomeBtn = document.getElementById("mobile-menu-home-btn");
const mobileMenuSfxBtn = document.getElementById("mobile-menu-sfx-btn");
const mobileMenuTestBtn = document.getElementById("mobile-menu-test-btn");
const mobileMenuSaveBtn = document.getElementById("mobile-menu-save-btn");
const mobileMenuLoadBtn = document.getElementById("mobile-menu-load-btn");
const mobileMenuSaveStatus = document.getElementById("mobile-menu-save-status");
const mobileMenuCloseBtn = document.getElementById("mobile-menu-close-btn");
const ordersPanel = document.getElementById("orders-panel");
const closePanelBtn = document.getElementById("close-panel-btn");
const attackForcePanel = document.querySelector(".attack-force-panel");
const armySendSlider = document.getElementById("army-send-slider");
const armySendValue = document.getElementById("army-send-value");
const armySendHint = document.getElementById("army-send-hint");
const shipSendSlider = document.getElementById("ship-send-slider");
const shipSendValue = document.getElementById("ship-send-value");
const shipSendHint = document.getElementById("ship-send-hint");
const attackSuccessLabel = document.getElementById("attack-success-label");
const mobileForcePopupEl = document.getElementById("mobile-force-popup");
const mobileArmySendSlider = document.getElementById("mobile-army-send-slider");
const mobileArmySendValue = document.getElementById("mobile-army-send-value");
const mobileArmySendHint = document.getElementById("mobile-army-send-hint");
const mobileShipSendSlider = document.getElementById("mobile-ship-send-slider");
const mobileShipSendValue = document.getElementById("mobile-ship-send-value");
const mobileShipSendHint = document.getElementById("mobile-ship-send-hint");
const mobileAttackSuccessLabel = document.getElementById("mobile-attack-success-label");
const mobileResolveBtn = document.getElementById("mobile-resolve-btn");
const mobileForceCloseBtn = document.getElementById("mobile-force-close-btn");
const mobileForceOpenBtn = document.getElementById("mobile-force-open-btn");
const battleOutcomeEl = document.getElementById("battle-outcome");
const buyArmiesBtn = document.getElementById("buy-armies-btn");
const buyShipsBtn = document.getElementById("buy-ships-btn");
const fortifyBtn = document.getElementById("fortify-btn");
const economyToggleCard = document.getElementById("economy-toggle-card");
const economyToggleBtn = document.getElementById("economy-toggle-btn");
const economyToggleNote = document.getElementById("economy-toggle-note");
const economyActionsPanel = document.getElementById("economy-actions-panel");
const opsArmiesCard = document.getElementById("ops-armies-card");
const opsShipsCard = document.getElementById("ops-ships-card");
const opsFortifyCard = document.getElementById("ops-fortify-card");
const buyArmiesInfo = document.getElementById("buy-armies-info");
const buyShipsInfo = document.getElementById("buy-ships-info");
const fortifyInfo = document.getElementById("fortify-info");
const mobileShopBarEl = document.getElementById("mobile-shop-bar");
const mobileBuyArmiesBtn = document.getElementById("mobile-buy-armies-btn");
const mobileBuyShipsBtn = document.getElementById("mobile-buy-ships-btn");
const mobileFortifyBtn = document.getElementById("mobile-fortify-btn");

const territoryEls = {};
let routeEls = [];
let aimLineEl;
let moveLineEl;
let movementCue = null;
let battleOutcomeTimer = null;
let attackOddsCacheKey = "";
let attackOddsCacheValue = null;
let mobileTopMenuOpen = false;

const MAP_BASE_VIEWBOX = {
  x: 0,
  y: 0,
  w: VIEWBOX_WIDTH,
  h: VIEWBOX_HEIGHT
};

const mapCamera = {
  x: MAP_BASE_VIEWBOX.x,
  y: MAP_BASE_VIEWBOX.y,
  w: MAP_BASE_VIEWBOX.w,
  h: MAP_BASE_VIEWBOX.h,
  scale: 1,
  minScale: 1,
  maxScale: 6.8,
  activePointerId: null,
  dragStart: null,
  pointers: new Map(),
  pinchStart: null,
  suppressClickUntil: 0,
  interactionsBound: false
};

const audioState = {
  supported: Boolean(window.AudioContext || window.webkitAudioContext),
  enabled: true,
  context: null,
  masterGain: null,
  volume: 0.48,
  musicTimer: null
};

const MUSIC_BEAT_SECONDS = 0.62;
const MUSIC_BAR_MS = Math.round(MUSIC_BEAT_SECONDS * 8 * 1000);
const MUSIC_BARS = [
  { bass: 146.83, upper1: 220.0, upper2: 293.66, lead: 293.66 },
  { bass: 130.81, upper1: 196.0, upper2: 261.63, lead: 261.63 },
  { bass: 164.81, upper1: 246.94, upper2: 329.63, lead: 329.63 },
  { bass: 146.83, upper1: 220.0, upper2: 293.66, lead: 246.94 }
];

function svgEl(tag, attrs = {}) {
  const el = document.createElementNS(NS, tag);
  Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, String(value)));
  return el;
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function createArrowMarker(id, color) {
  const marker = svgEl("marker", {
    id,
    viewBox: "0 0 10 10",
    refX: 8.4,
    refY: 5,
    markerWidth: 6.8,
    markerHeight: 6.8,
    orient: "auto-start-reverse",
    markerUnits: "strokeWidth"
  });
  const path = svgEl("path", { d: "M 0 0 L 10 5 L 0 10 z", fill: color });
  marker.appendChild(path);
  return marker;
}

function createGradientStop(offset, color, opacity = 1) {
  return svgEl("stop", {
    offset,
    "stop-color": color,
    "stop-opacity": opacity
  });
}

function createOceanScratchPath() {
  return [
    "M -120 112 C 128 12 356 20 1134 178",
    "M -120 236 C 168 132 424 140 1144 286",
    "M -100 356 C 164 278 386 284 1132 438",
    "M -80 484 C 208 426 434 438 1128 574",
    "M 146 -40 C 94 164 118 356 232 672",
    "M 476 -36 C 424 164 438 348 568 676",
    "M 812 -30 C 748 178 768 380 882 684"
  ].join(" ");
}

function createMapTextureDefs(defs) {
  const makePattern = (id, width, height, transform = "") => {
    const pattern = svgEl("pattern", {
      id,
      patternUnits: "userSpaceOnUse",
      width: String(width),
      height: String(height)
    });
    if (transform) pattern.setAttribute("patternTransform", transform);
    return pattern;
  };

  const oceanGradient = svgEl("linearGradient", {
    id: "ocean-gradient",
    x1: "0%",
    y1: "0%",
    x2: "0%",
    y2: "100%"
  });
  oceanGradient.appendChild(createGradientStop("0%", "#b7e7ee"));
  oceanGradient.appendChild(createGradientStop("46%", "#8bced8"));
  oceanGradient.appendChild(createGradientStop("100%", "#5eaebd"));
  defs.appendChild(oceanGradient);

  const oceanVignetteGradient = svgEl("radialGradient", {
    id: "ocean-vignette-gradient",
    cx: "52%",
    cy: "46%",
    r: "78%"
  });
  oceanVignetteGradient.appendChild(createGradientStop("0%", "#d6f4f8", 0));
  oceanVignetteGradient.appendChild(createGradientStop("72%", "#5aa7b8", 0.06));
  oceanVignetteGradient.appendChild(createGradientStop("100%", "#2f7587", 0.38));
  defs.appendChild(oceanVignetteGradient);

  const oceanWashPattern = svgEl("pattern", {
    id: "ocean-wash-pattern",
    patternUnits: "userSpaceOnUse",
    width: "220",
    height: "220"
  });
  oceanWashPattern.appendChild(svgEl("rect", {
    x: "0",
    y: "0",
    width: "220",
    height: "220",
    fill: "#97d6df",
    opacity: "0.18"
  }));
  for (let i = 0; i < 28; i += 1) {
    const x = ((i * 53) + ((i % 4) * 19)) % 220;
    const y = ((i * 41) + ((i % 6) * 17)) % 220;
    const r = 12 + ((i * 7) % 28);
    const opacity = 0.045 + ((i % 6) * 0.014);
    oceanWashPattern.appendChild(svgEl("circle", {
      cx: x.toFixed(2),
      cy: y.toFixed(2),
      r: r.toFixed(2),
      fill: i % 2 === 0 ? "#d9f6fb" : "#72bccb",
      opacity: opacity.toFixed(3)
    }));
  }
  oceanWashPattern.appendChild(svgEl("path", {
    d: "M 12 42 C 66 24 120 24 188 56 M 28 112 C 88 90 146 88 212 116 M 4 176 C 72 152 126 154 204 184",
    fill: "none",
    stroke: "#e3f8fd",
    "stroke-width": "1.8",
    "stroke-linecap": "round",
    opacity: "0.17"
  }));
  defs.appendChild(oceanWashPattern);

  const landShadeGradient = svgEl("radialGradient", {
    id: "land-shade-gradient",
    cx: "45%",
    cy: "34%",
    r: "74%"
  });
  landShadeGradient.appendChild(createGradientStop("0%", "#fff8d4", 0.22));
  landShadeGradient.appendChild(createGradientStop("56%", "#f0d289", 0.04));
  landShadeGradient.appendChild(createGradientStop("100%", "#5b3f19", 0.34));
  defs.appendChild(landShadeGradient);

  const oceanNoiseFilter = svgEl("filter", {
    id: "ocean-noise",
    x: "-20%",
    y: "-20%",
    width: "140%",
    height: "140%"
  });
  oceanNoiseFilter.appendChild(svgEl("feTurbulence", {
    type: "fractalNoise",
    baseFrequency: "0.016 0.042",
    numOctaves: "3",
    seed: "9",
    result: "noise"
  }));
  oceanNoiseFilter.appendChild(svgEl("feColorMatrix", {
    in: "noise",
    type: "matrix",
    values: "0 0 0 0 0.76 0 0 0 0 0.90 0 0 0 0 0.93 0 0 0 0.22 0",
    result: "tone"
  }));
  oceanNoiseFilter.appendChild(svgEl("feBlend", {
    in: "SourceGraphic",
    in2: "tone",
    mode: "overlay"
  }));
  defs.appendChild(oceanNoiseFilter);

  const landNoisePattern = svgEl("pattern", {
    id: "land-noise-pattern",
    patternUnits: "userSpaceOnUse",
    width: "96",
    height: "96"
  });
  landNoisePattern.appendChild(svgEl("rect", {
    x: "0",
    y: "0",
    width: "96",
    height: "96",
    fill: "#7a5526",
    opacity: "0.06"
  }));
  for (let i = 0; i < 36; i += 1) {
    const x = ((i * 29) + ((i % 4) * 17)) % 96;
    const y = ((i * 23) + ((i % 5) * 11)) % 96;
    const r = 0.9 + ((i % 5) * 0.38);
    const opacity = 0.09 + ((i % 6) * 0.02);
    landNoisePattern.appendChild(svgEl("circle", {
      cx: x.toFixed(2),
      cy: y.toFixed(2),
      r: r.toFixed(2),
      fill: i % 2 === 0 ? "#6a481f" : "#8a6431",
      opacity: opacity.toFixed(3)
    }));
  }
  for (let i = 0; i < 6; i += 1) {
    const cx = 12 + (i * 14.2);
    const cy = 9 + ((i % 3) * 25.5);
    const rx = 5.5 + (i % 3);
    const ry = 3.8 + ((i + 1) % 3);
    landNoisePattern.appendChild(svgEl("ellipse", {
      cx: cx.toFixed(2),
      cy: cy.toFixed(2),
      rx: rx.toFixed(2),
      ry: ry.toFixed(2),
      fill: "#9d743f",
      opacity: "0.11"
    }));
  }
  landNoisePattern.appendChild(svgEl("path", {
    d: "M 6 14 L 34 10 M 42 22 L 78 18 M 12 52 L 44 50 M 56 66 L 86 60 M 18 82 L 54 86",
    fill: "none",
    stroke: "#5a3d18",
    "stroke-width": "1.04",
    "stroke-linecap": "round",
    opacity: "0.15"
  }));
  defs.appendChild(landNoisePattern);

  const mountainBandPattern = svgEl("pattern", {
    id: "mountain-band-pattern",
    patternUnits: "userSpaceOnUse",
    width: "26",
    height: "14"
  });
  mountainBandPattern.appendChild(svgEl("rect", {
    x: "0",
    y: "0",
    width: "26",
    height: "14",
    fill: "#dfc58f"
  }));
  for (let i = 0; i < 3; i += 1) {
    const baseX = 2 + (i * 8.0);
    const ridgeY = 8.2 + ((i % 2) * 0.8);
    mountainBandPattern.appendChild(svgEl("path", {
      d: `M ${baseX.toFixed(2)} ${ridgeY.toFixed(2)} ` +
        `Q ${(baseX + 1.25).toFixed(2)} ${(ridgeY - 2.35).toFixed(2)} ${(baseX + 2.5).toFixed(2)} ${ridgeY.toFixed(2)} ` +
        `M ${(baseX + 3.0).toFixed(2)} ${ridgeY.toFixed(2)} ` +
        `Q ${(baseX + 4.25).toFixed(2)} ${(ridgeY - 2.1).toFixed(2)} ${(baseX + 5.45).toFixed(2)} ${ridgeY.toFixed(2)}`,
      fill: "none",
      stroke: "#7c5a32",
      "stroke-width": "0.74",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      opacity: "0.62"
    }));
    mountainBandPattern.appendChild(svgEl("path", {
      d: `M ${(baseX + 1.2).toFixed(2)} ${(ridgeY + 2.0).toFixed(2)} ` +
        `Q ${(baseX + 2.7).toFixed(2)} ${(ridgeY + 1.2).toFixed(2)} ${(baseX + 4.2).toFixed(2)} ${(ridgeY + 2.0).toFixed(2)}`,
      fill: "none",
      stroke: "#8f6b3f",
      "stroke-width": "0.46",
      "stroke-linecap": "round",
      opacity: "0.23"
    }));
  }
  mountainBandPattern.appendChild(svgEl("path", {
    d: "M 0.8 12.2 C 6.1 11.4 10.8 12.2 15.8 11.0 C 19.5 10.1 22.5 10.8 25.2 10.2",
    fill: "none",
    stroke: "#8e673a",
    "stroke-width": "0.54",
    "stroke-linecap": "round",
    opacity: "0.2"
  }));
  defs.appendChild(mountainBandPattern);

  const ai1Pattern = makePattern("territory-fill-ai1", 34, 34, "rotate(45)");
  ai1Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "34", height: "34", fill: "#8078bc" }));
  for (let x = -20; x <= 58; x += 12) {
    ai1Pattern.appendChild(svgEl("line", {
      x1: String(x),
      y1: "-8",
      x2: String(x),
      y2: "46",
      stroke: "#4a447e",
      "stroke-width": "5.2",
      opacity: "0.34"
    }));
  }
  defs.appendChild(ai1Pattern);

  const ai2Pattern = makePattern("territory-fill-ai2", 28, 28);
  ai2Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "28", height: "28", fill: "#68a972" }));
  for (let p = 0; p <= 28; p += 8) {
    ai2Pattern.appendChild(svgEl("line", {
      x1: String(p),
      y1: "0",
      x2: String(p),
      y2: "28",
      stroke: "#3e6a43",
      "stroke-width": "2.0",
      opacity: "0.34"
    }));
    ai2Pattern.appendChild(svgEl("line", {
      x1: "0",
      y1: String(p),
      x2: "28",
      y2: String(p),
      stroke: "#3e6a43",
      "stroke-width": "1.5",
      opacity: "0.24"
    }));
  }
  defs.appendChild(ai2Pattern);

  const ai3Pattern = makePattern("territory-fill-ai3", 34, 34, "rotate(-45)");
  ai3Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "34", height: "34", fill: "#bf8b4f" }));
  for (let x = -20; x <= 58; x += 12) {
    ai3Pattern.appendChild(svgEl("line", {
      x1: String(x),
      y1: "-8",
      x2: String(x),
      y2: "46",
      stroke: "#7b5528",
      "stroke-width": "4.8",
      opacity: "0.34"
    }));
  }
  defs.appendChild(ai3Pattern);

  const ai4Pattern = makePattern("territory-fill-ai4", 30, 30);
  ai4Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "30", height: "30", fill: "#6a97bf" }));
  for (let y = 3; y <= 30; y += 9) {
    ai4Pattern.appendChild(svgEl("line", {
      x1: "0",
      y1: String(y),
      x2: "30",
      y2: String(y),
      stroke: "#35566f",
      "stroke-width": "2.2",
      opacity: "0.32"
    }));
  }
  defs.appendChild(ai4Pattern);

  const ai5Pattern = makePattern("territory-fill-ai5", 30, 30);
  ai5Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "30", height: "30", fill: "#5aaaa5" }));
  for (let x = 2; x <= 30; x += 8) {
    ai5Pattern.appendChild(svgEl("line", {
      x1: String(x),
      y1: "0",
      x2: String(x),
      y2: "30",
      stroke: "#25605c",
      "stroke-width": "2.0",
      "stroke-dasharray": "4 4",
      opacity: "0.36"
    }));
  }
  defs.appendChild(ai5Pattern);

  const ai6Pattern = makePattern("territory-fill-ai6", 30, 30);
  ai6Pattern.appendChild(svgEl("rect", { x: "0", y: "0", width: "30", height: "30", fill: "#9e74aa" }));
  for (let y = 4; y <= 30; y += 10) {
    for (let x = 4; x <= 30; x += 10) {
      ai6Pattern.appendChild(svgEl("circle", {
        cx: String(x),
        cy: String(y),
        r: "1.7",
        fill: "#4c3568",
        opacity: "0.5"
      }));
    }
  }
  defs.appendChild(ai6Pattern);
}

function setLineEndpoints(lineEl, fromName, toName) {
  const from = MAP_LAYOUT[fromName].token;
  const to = MAP_LAYOUT[toName].token;
  lineEl.setAttribute("x1", String(from.x));
  lineEl.setAttribute("y1", String(from.y));
  lineEl.setAttribute("x2", String(to.x));
  lineEl.setAttribute("y2", String(to.y));
}

function parsePolygonPoints(pointsText) {
  if (typeof pointsText !== "string") return [];
  const matches = pointsText.match(/-?\d+(?:\.\d+)?,-?\d+(?:\.\d+)?/g) || [];
  const points = [];
  matches.forEach((pair) => {
    const [xText, yText] = pair.split(",");
    const x = Number.parseFloat(xText);
    const y = Number.parseFloat(yText);
    if (Number.isFinite(x) && Number.isFinite(y)) {
      points.push({ x, y });
    }
  });
  return points;
}

function polygonCentroid(pointsText) {
  const points = parsePolygonPoints(pointsText);
  if (points.length === 0) return null;
  if (points.length < 3) {
    const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
    const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
    return { x: avgX, y: avgY };
  }
  let twiceArea = 0;
  let cx = 0;
  let cy = 0;
  for (let i = 0; i < points.length; i += 1) {
    const current = points[i];
    const next = points[(i + 1) % points.length];
    const cross = (current.x * next.y) - (next.x * current.y);
    twiceArea += cross;
    cx += (current.x + next.x) * cross;
    cy += (current.y + next.y) * cross;
  }
  if (Math.abs(twiceArea) < 0.0001) {
    const avgX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
    const avgY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
    return { x: avgX, y: avgY };
  }
  return {
    x: cx / (3 * twiceArea),
    y: cy / (3 * twiceArea)
  };
}

function buildPathFromPoints(points, close = false) {
  if (!Array.isArray(points) || points.length === 0) return "";
  const d = points.map((point, index) => (
    `${index === 0 ? "M" : "L"} ${point.x.toFixed(1)} ${point.y.toFixed(1)}`
  )).join(" ");
  return close ? `${d} Z` : d;
}

function midpoint(a, b) {
  return {
    x: (a.x + b.x) * 0.5,
    y: (a.y + b.y) * 0.5
  };
}

function buildSmoothPathFromPoints(points, close = false) {
  if (!Array.isArray(points) || points.length === 0) return "";
  if (points.length < 3) return buildPathFromPoints(points, close);

  if (!close) {
    const mids = [];
    for (let i = 0; i < points.length - 1; i += 1) {
      mids.push(midpoint(points[i], points[i + 1]));
    }
    let d = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
    for (let i = 0; i < mids.length; i += 1) {
      const control = points[i + 1];
      const end = mids[i] || points[points.length - 1];
      d += ` Q ${control.x.toFixed(1)} ${control.y.toFixed(1)} ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
    }
    const last = points[points.length - 1];
    d += ` L ${last.x.toFixed(1)} ${last.y.toFixed(1)}`;
    return d;
  }

  const count = points.length;
  const start = midpoint(points[0], points[1]);
  let d = `M ${start.x.toFixed(1)} ${start.y.toFixed(1)}`;
  for (let i = 1; i <= count; i += 1) {
    const control = points[i % count];
    const next = points[(i + 1) % count];
    const end = midpoint(control, next);
    d += ` Q ${control.x.toFixed(1)} ${control.y.toFixed(1)} ${end.x.toFixed(1)} ${end.y.toFixed(1)}`;
  }
  return `${d} Z`;
}

function normalForSegment(from, to, side = 1) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const length = Math.hypot(dx, dy);
  if (length < 0.0001) return { x: 0, y: 0 };
  return {
    x: ((-dy) / length) * side,
    y: (dx / length) * side
  };
}

function offsetPolyline(points, distance, side = 1) {
  if (!Array.isArray(points) || points.length === 0) return [];
  if (points.length === 1) return [{ x: points[0].x, y: points[0].y }];
  return points.map((point, index) => {
    const previous = points[Math.max(0, index - 1)];
    const next = points[Math.min(points.length - 1, index + 1)];
    const normal = normalForSegment(previous, next, side);
    return {
      x: point.x + (normal.x * distance),
      y: point.y + (normal.y * distance)
    };
  });
}

const mountainTerritoryGeometryCache = new Map();
const mountainSideSpineCache = new Map();

function getMountainTerritoryGeometry(territory) {
  if (!territory) return null;
  if (mountainTerritoryGeometryCache.has(territory)) {
    return mountainTerritoryGeometryCache.get(territory);
  }
  const layout = MAP_LAYOUT[territory];
  if (!layout?.points) {
    mountainTerritoryGeometryCache.set(territory, null);
    return null;
  }
  const points = parsePolygonPoints(layout.points);
  const centroid = polygonCentroid(layout.points);
  const geometry = (points.length >= 3 && Number.isFinite(centroid?.x) && Number.isFinite(centroid?.y))
    ? { points, centroid }
    : null;
  mountainTerritoryGeometryCache.set(territory, geometry);
  return geometry;
}

function normalizeMountainBoundaryPoints(points) {
  if (!Array.isArray(points) || points.length < 3) return [];
  const normalized = [];
  for (let index = 0; index < points.length; index += 1) {
    const point = points[index];
    if (!point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) continue;
    if (normalized.length > 0) {
      const previous = normalized[normalized.length - 1];
      if (Math.hypot(previous.x - point.x, previous.y - point.y) < 0.06) continue;
    }
    normalized.push({ x: point.x, y: point.y });
  }
  if (normalized.length < 3) return [];
  const first = normalized[0];
  const last = normalized[normalized.length - 1];
  if (Math.hypot(first.x - last.x, first.y - last.y) < 0.08) {
    normalized.pop();
  }
  return normalized;
}

function mountainBounds(points) {
  if (!Array.isArray(points) || points.length === 0) return null;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  points.forEach((point) => {
    minX = Math.min(minX, point.x);
    minY = Math.min(minY, point.y);
    maxX = Math.max(maxX, point.x);
    maxY = Math.max(maxY, point.y);
  });
  return {
    minX,
    minY,
    maxX,
    maxY,
    width: Math.max(0.001, maxX - minX),
    height: Math.max(0.001, maxY - minY)
  };
}

function longestCircularRun(flags) {
  if (!Array.isArray(flags) || flags.length === 0) return null;
  const size = flags.length;
  let bestStart = -1;
  let bestLength = 0;
  let currentStart = -1;
  let currentLength = 0;

  for (let index = 0; index < size * 2; index += 1) {
    const isActive = Boolean(flags[index % size]);
    if (isActive) {
      if (currentLength === 0) currentStart = index;
      currentLength += 1;
      if (currentLength > size) {
        currentLength = size;
        currentStart = index - size + 1;
      }
      if (currentLength > bestLength) {
        bestLength = currentLength;
        bestStart = currentStart;
      }
    } else {
      currentLength = 0;
      currentStart = -1;
    }
  }

  if (bestStart < 0 || bestLength < 2) return null;
  return {
    start: ((bestStart % size) + size) % size,
    length: Math.min(size, bestLength)
  };
}

function simplifyMountainPolyline(points, minDistance = 1.1) {
  if (!Array.isArray(points) || points.length <= 2) return Array.isArray(points) ? [...points] : [];
  const simplified = [points[0]];
  for (let index = 1; index < points.length - 1; index += 1) {
    const point = points[index];
    const previous = simplified[simplified.length - 1];
    if (Math.hypot(point.x - previous.x, point.y - previous.y) >= minDistance) {
      simplified.push(point);
    }
  }
  const tail = points[points.length - 1];
  const previous = simplified[simplified.length - 1];
  if (Math.hypot(tail.x - previous.x, tail.y - previous.y) >= (minDistance * 0.4)) {
    simplified.push(tail);
  }
  if (simplified.length < 2) return [points[0], tail];
  return simplified;
}

function orderMountainSidePolyline(points, sideHint) {
  if (!Array.isArray(points) || points.length <= 2) return Array.isArray(points) ? [...points] : [];
  const sortVertical = sideHint === "east" || sideHint === "west";
  const pickExtreme = (current, candidate) => {
    if (!current) return candidate;
    if (sortVertical) {
      if (sideHint === "east") return candidate.x > current.x ? candidate : current;
      return candidate.x < current.x ? candidate : current;
    }
    if (sideHint === "north") return candidate.y < current.y ? candidate : current;
    return candidate.y > current.y ? candidate : current;
  };
  const buckets = new Map();
  for (const point of points) {
    const axisValue = sortVertical ? point.y : point.x;
    const key = Math.round(axisValue); // one sample per pixel along the edge axis avoids corner jitter
    buckets.set(key, pickExtreme(buckets.get(key), point));
  }
  const collapsed = [...buckets.values()];
  collapsed.sort((a, b) => {
    if (sortVertical) return a.y - b.y;
    return a.x - b.x;
  });
  if (collapsed.length <= 2) return collapsed;
  const filtered = [collapsed[0]];
  for (let index = 1; index < collapsed.length; index += 1) {
    const point = collapsed[index];
    const previous = filtered[filtered.length - 1];
    const dx = Math.abs(point.x - previous.x);
    const dy = Math.abs(point.y - previous.y);
    if (sortVertical && dy < 0.9 && dx > 1.35) continue;
    if (!sortVertical && dx < 0.9 && dy > 1.35) continue;
    filtered.push(point);
  }
  return filtered;
}

function pointOnMountainSide(point, bounds, sideHint, sideDepth) {
  const depth = clampNumber(sideDepth, 0.12, 0.45);
  switch (sideHint) {
    case "east":
      return point.x >= (bounds.maxX - (bounds.width * depth));
    case "north":
      return point.y <= (bounds.minY + (bounds.height * depth));
    case "south":
      return point.y >= (bounds.maxY - (bounds.height * depth));
    case "west":
    default:
      return point.x <= (bounds.minX + (bounds.width * depth));
  }
}

function extractMountainSidePolyline(points, sideHint, sideDepth) {
  const boundary = normalizeMountainBoundaryPoints(points);
  if (boundary.length < 3) return [];
  const bounds = mountainBounds(boundary);
  if (!bounds) return [];

  const eligible = boundary.map((point) => pointOnMountainSide(point, bounds, sideHint, sideDepth));
  if (!eligible.some(Boolean)) return [];
  const run = longestCircularRun(eligible);
  if (!run) return [];

  const sidePoints = [];
  for (let offset = 0; offset < run.length; offset += 1) {
    const point = boundary[(run.start + offset) % boundary.length];
    sidePoints.push({ x: point.x, y: point.y });
  }
  const ordered = orderMountainSidePolyline(sidePoints, sideHint);
  return simplifyMountainPolyline(ordered, 1.08);
}

function buildMountainSideSpine(range, geometry) {
  if (!range || !geometry?.points || !geometry?.centroid) return [];
  const sideHint = (
    range.sideHint === "east" ||
    range.sideHint === "north" ||
    range.sideHint === "south" ||
    range.sideHint === "west"
  ) ? range.sideHint : "west";
  const sideDepth = Number.isFinite(range.sideDepth) ? range.sideDepth : 0.25;
  const sidePolyline = extractMountainSidePolyline(geometry.points, sideHint, sideDepth);
  if (sidePolyline.length < 2) return [];

  const edgeInset = Number.isFinite(range.edgeInset) ? range.edgeInset : 1.2;
  const bandWidth = Number.isFinite(range.bandWidth) ? range.bandWidth : 7.2;
  const sideInset = Number.isFinite(range.sideInset)
    ? range.sideInset
    : (edgeInset + (bandWidth * 0.16));
  const spinePoints = [];
  const total = sidePolyline.length;

  for (let index = 0; index < total; index += 1) {
    const point = sidePolyline[index];
    const previous = sidePolyline[Math.max(0, index - 1)];
    const next = sidePolyline[Math.min(total - 1, index + 1)];
    const dx = next.x - previous.x;
    const dy = next.y - previous.y;
    const length = Math.hypot(dx, dy);
    if (length < 0.0001) {
      spinePoints.push({ x: point.x, y: point.y });
      continue;
    }
    const tangentX = dx / length;
    const tangentY = dy / length;
    const normalA = { x: -tangentY, y: tangentX };
    const normalB = { x: -normalA.x, y: -normalA.y };
    const toCentroid = {
      x: geometry.centroid.x - point.x,
      y: geometry.centroid.y - point.y
    };
    const dotA = (toCentroid.x * normalA.x) + (toCentroid.y * normalA.y);
    const normal = dotA >= 0 ? normalA : normalB;
    const inset = sideInset;
    spinePoints.push({
      x: point.x + (normal.x * inset),
      y: point.y + (normal.y * inset)
    });
  }

  return simplifyMountainPolyline(spinePoints, 1.12);
}

function getMountainSpine(range) {
  if (!range) return [];
  if (range.anchorToSide && range.territory) {
    const cacheKey = [
      range.id || range.territory,
      range.territory,
      range.sideHint || "west",
      Number.isFinite(range.sideDepth) ? range.sideDepth.toFixed(3) : "",
      Number.isFinite(range.sideInset) ? range.sideInset.toFixed(3) : ""
    ].join("|");
    if (mountainSideSpineCache.has(cacheKey)) {
      return mountainSideSpineCache.get(cacheKey);
    }
    const geometry = getMountainTerritoryGeometry(range.territory);
    const derived = geometry ? buildMountainSideSpine(range, geometry) : [];
    if (derived.length >= 2) {
      mountainSideSpineCache.set(cacheKey, derived);
      return derived;
    }
    const fallback = Array.isArray(range.spine) ? range.spine : [];
    mountainSideSpineCache.set(cacheKey, fallback);
    return fallback;
  }
  return Array.isArray(range.spine) ? range.spine : [];
}

function resolveMountainNormalSign(range, point, baseNormal) {
  const fallback = range?.side === -1 ? -1 : 1;
  if (!point || !baseNormal) return fallback;
  const geometry = getMountainTerritoryGeometry(range?.territory);
  if (!geometry) return fallback;

  const bandWidth = Number.isFinite(range?.bandWidth) ? range.bandWidth : 8;
  const probeDistance = Number.isFinite(range?.inwardProbe)
    ? range.inwardProbe
    : Math.max(2.0, bandWidth * 0.36);

  const plusProbe = {
    x: point.x + (baseNormal.x * probeDistance),
    y: point.y + (baseNormal.y * probeDistance)
  };
  const minusProbe = {
    x: point.x - (baseNormal.x * probeDistance),
    y: point.y - (baseNormal.y * probeDistance)
  };
  const plusInside = isPointInsidePolygon(plusProbe, geometry.points);
  const minusInside = isPointInsidePolygon(minusProbe, geometry.points);
  if (plusInside && !minusInside) return 1;
  if (minusInside && !plusInside) return -1;

  const toCentroid = {
    x: geometry.centroid.x - point.x,
    y: geometry.centroid.y - point.y
  };
  const dot = (toCentroid.x * baseNormal.x) + (toCentroid.y * baseNormal.y);
  if (Math.abs(dot) > 0.0001) return dot >= 0 ? 1 : -1;
  return fallback;
}

function sampleMountainSpine(range, spacingHint = null) {
  const spine = getMountainSpine(range);
  if (!Array.isArray(spine) || spine.length < 2) return [];
  const spacingBase = Number.isFinite(spacingHint)
    ? spacingHint
    : (Number.isFinite(range.peakSpacing) ? range.peakSpacing * 0.72 : 6.4);
  const spacing = Math.max(3.8, spacingBase);
  const samples = [];
  const segmentCount = spine.length - 1;

  for (let segmentIndex = 0; segmentIndex < segmentCount; segmentIndex += 1) {
    const from = spine[segmentIndex];
    const to = spine[segmentIndex + 1];
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const length = Math.hypot(dx, dy);
    if (length < 0.5) continue;
    const tangentX = dx / length;
    const tangentY = dy / length;
    const baseNormal = normalForSegment(from, to, 1);
    const normalSign = resolveMountainNormalSign(range, {
      x: (from.x + to.x) * 0.5,
      y: (from.y + to.y) * 0.5
    }, baseNormal);
    const normal = {
      x: baseNormal.x * normalSign,
      y: baseNormal.y * normalSign
    };
    const steps = Math.max(1, Math.ceil(length / spacing));

    for (let step = 0; step <= steps; step += 1) {
      if (segmentIndex > 0 && step === 0) continue;
      const t = step / steps;
      const progress = (segmentIndex + t) / segmentCount;
      samples.push({
        x: from.x + (tangentX * length * t),
        y: from.y + (tangentY * length * t),
        tangentX,
        tangentY,
        normalX: normal.x,
        normalY: normal.y,
        progress
      });
    }
  }

  return samples;
}

function offsetMountainSample(sample, normalOffset, tangentOffset = 0) {
  return {
    x: sample.x + (sample.normalX * normalOffset) + (sample.tangentX * tangentOffset),
    y: sample.y + (sample.normalY * normalOffset) + (sample.tangentY * tangentOffset)
  };
}

function mountainTaper(index, total) {
  if (total <= 1) return 1;
  return Math.sin(Math.PI * (index / (total - 1)));
}

function trimMountainSamples(samples, range, minCount = 2) {
  if (!Array.isArray(samples) || samples.length === 0) return [];
  const total = samples.length;
  const startFraction = Number.isFinite(range?.sampleStart)
    ? clampNumber(range.sampleStart, 0, 0.96)
    : 0;
  const endFraction = Number.isFinite(range?.sampleEnd)
    ? clampNumber(range.sampleEnd, 0.04, 1)
    : 1;
  let start = Math.min(startFraction, endFraction);
  let end = Math.max(startFraction, endFraction);
  if ((end - start) < 0.1) {
    const mid = (start + end) * 0.5;
    start = clampNumber(mid - 0.05, 0, 0.95);
    end = clampNumber(mid + 0.05, 0.05, 1);
  }
  const startIndex = Math.max(0, Math.floor(start * (total - 1)));
  const endIndex = Math.min(total - 1, Math.ceil(end * (total - 1)));
  const subset = samples.slice(startIndex, endIndex + 1);
  if (subset.length >= minCount) return subset;
  return samples;
}

function buildMountainBandPath(range) {
  const spacingHint = Number.isFinite(range?.peakSpacing) ? range.peakSpacing * 0.92 : 6.6;
  const samples = sampleMountainSpine(range, Math.max(5.8, spacingHint));
  if (samples.length < 2) return "";
  const trimmed = trimMountainSamples(samples, range, 2);
  const keepEndpoints = range?.coverFullSide === true;
  const coreSamples = (!keepEndpoints && trimmed.length > 4) ? trimmed.slice(1, -1) : trimmed;
  const edgeInset = Number.isFinite(range.edgeInset) ? range.edgeInset : 1.2;
  const bandWidth = Number.isFinite(range.bandWidth) ? range.bandWidth : 7.2;
  const centerOffset = edgeInset + (bandWidth * 0.38);
  const centerLine = coreSamples.map((sample) => offsetMountainSample(sample, centerOffset));
  return buildPathFromPoints(simplifyMountainPolyline(centerLine, 0.88), false);
}

function buildMountainRidgePath(range, ridgeFactor = 0.62) {
  const preferredSpacing = Number.isFinite(range?.peakSpacing) ? range.peakSpacing * 0.62 : 5.2;
  const samples = sampleMountainSpine(range, Math.max(4.2, preferredSpacing));
  if (samples.length < 2) return "";
  const edgeInset = Number.isFinite(range.edgeInset) ? range.edgeInset : 1.2;
  const bandWidth = Number.isFinite(range.bandWidth) ? range.bandWidth : 7.2;
  const ridgeOffset = edgeInset + (bandWidth * ridgeFactor);
  const amplitude = bandWidth * 0.2;
  const tangentAmplitude = Math.min(1.2, bandWidth * 0.18);
  const ridgePoints = samples.map((sample, index) => {
    const taper = mountainTaper(index, samples.length);
    const wave = Math.sin((sample.progress * Math.PI * 6.8) + (ridgeFactor * 1.7));
    const normalShift = wave * amplitude * taper;
    const tangentShift = wave * tangentAmplitude * taper;
    return offsetMountainSample(sample, ridgeOffset + normalShift, tangentShift);
  });
  return buildPathFromPoints(ridgePoints);
}

function buildMountainPeakPath(range) {
  const peakSpacingHint = Number.isFinite(range?.peakSpacing) ? range.peakSpacing : 8;
  const samples = sampleMountainSpine(range, Math.max(6.4, peakSpacingHint * 1.06));
  if (samples.length < 3) return "";
  const trimmed = trimMountainSamples(samples, range, 3);
  const keepEndpoints = range?.coverFullSide === true;
  const coreSamples = (!keepEndpoints && trimmed.length > 5) ? trimmed.slice(1, -1) : trimmed;
  const edgeInset = Number.isFinite(range.edgeInset) ? range.edgeInset : 1.2;
  const bandWidth = Number.isFinite(range.bandWidth) ? range.bandWidth : 7.2;
  const peakHeight = Number.isFinite(range.peakHeight) ? range.peakHeight : (bandWidth * 0.72);
  const peakWidth = Number.isFinite(range.peakWidth)
    ? Math.max(1.6, range.peakWidth * 0.64)
    : (peakSpacingHint * 0.28);
  const baseOffset = edgeInset + (bandWidth * 0.40);
  const commands = [];

  for (let index = 0; index < coreSamples.length; index += 1) {
    const sample = coreSamples[index];
    const taper = mountainTaper(index, coreSamples.length);
    if (taper < 0.2) continue;

    const halfWidth = peakWidth * (0.76 + (0.14 * taper));
    const glyphHeight = peakHeight * (0.32 + (0.14 * taper));
    const baseCenter = offsetMountainSample(sample, baseOffset, 0);
    const lx = baseCenter.x - (halfWidth * 0.95);
    const mx = baseCenter.x - (halfWidth * 0.20);
    const rx = baseCenter.x + (halfWidth * 0.58);
    const y = baseCenter.y;
    const peakA = y - glyphHeight;
    const peakB = y - (glyphHeight * 0.88);

    commands.push(
      `M ${lx.toFixed(1)} ${y.toFixed(1)} ` +
      `Q ${(lx + (halfWidth * 0.34)).toFixed(1)} ${peakA.toFixed(1)} ${mx.toFixed(1)} ${y.toFixed(1)} ` +
      `M ${mx.toFixed(1)} ${y.toFixed(1)} ` +
      `Q ${(mx + (halfWidth * 0.36)).toFixed(1)} ${peakB.toFixed(1)} ${rx.toFixed(1)} ${y.toFixed(1)}`
    );
  }
  return commands.join(" ");
}

function isPointInsidePolygon(point, points) {
  if (!point || !Array.isArray(points) || points.length < 3) return false;
  let inside = false;
  for (let i = 0, j = points.length - 1; i < points.length; j = i, i += 1) {
    const xi = points[i].x;
    const yi = points[i].y;
    const xj = points[j].x;
    const yj = points[j].y;
    const intersects = (
      ((yi > point.y) !== (yj > point.y)) &&
      (point.x < (((xj - xi) * (point.y - yi)) / ((yj - yi) || 1e-9)) + xi)
    );
    if (intersects) inside = !inside;
  }
  return inside;
}

function computeLocalLabelDensityAt(name, x, y, labelPositions) {
  let nearby = 0;
  for (const [other, position] of Object.entries(labelPositions)) {
    if (other === name) continue;
    const dx = position.x - x;
    const dy = position.y - y;
    const d = Math.hypot(dx, dy);
    if (d < 42) nearby += 1;
  }
  return nearby;
}

function isAIOwner(owner) {
  return AI_OWNERS.includes(owner);
}

function ownerToneClass(owner) {
  return owner === "player" ? "player" : "ai";
}

function ownerStyleClass(owner) {
  if (owner === "player") return "player";
  if (owner === "neutral") return "neutral";
  if (isAIOwner(owner)) return owner;
  return "neutral";
}

function isOceanRoute(fromName, toName) {
  if (!fromName || !toName) return false;
  return OCEAN_ROUTE_KEYS.has(routeKey(fromName, toName));
}

function isCoastalTerritory(name) {
  if (!name) return false;
  return COASTAL_TERRITORIES.has(name);
}

function canUseShipsOnRoute(fromName, toName) {
  if (!fromName || !toName || fromName === toName) return false;
  return isCoastalTerritory(fromName) && isCoastalTerritory(toName);
}

function isAdjacentTerritory(fromName, toName) {
  if (!fromName || !toName || fromName === toName) return false;
  return TERRITORIES[fromName]?.includes(toName) || false;
}

function isMountainBlockedRoute(fromName, toName) {
  if (!fromName || !toName || fromName === toName) return false;
  return MOUNTAIN_BLOCKED_ROUTE_KEYS.has(routeKey(fromName, toName));
}

function isLandRouteAvailable(fromName, toName) {
  if (!isAdjacentTerritory(fromName, toName)) return false;
  return !isMountainBlockedRoute(fromName, toName);
}

function showMovementCue(from, to, owner, force = null) {
  movementCue = { from, to, owner, force };
  const forceText = force ? ` (${force})` : "";
  movementBadge.textContent = `${ownerName(owner)}: ${territoryLabel(from, from)} -> ${territoryLabel(to, to)}${forceText}`;
  movementBadge.classList.remove("player", "ai");
  movementBadge.classList.add("visible", ownerToneClass(owner));
}

function clearMovementCue() {
  movementCue = null;
  movementBadge.classList.remove("visible", "player", "ai");
  movementBadge.textContent = "";
}

function clearBattleOutcome(acknowledged = false) {
  if (!battleOutcomeEl) return;
  if (battleOutcomeTimer) {
    clearTimeout(battleOutcomeTimer);
    battleOutcomeTimer = null;
  }
  battleOutcomeEl.classList.remove("success", "fail", "visible", "ack-required");
  if (acknowledged || state.outcomeAckRequired) {
    state.outcomeAckRequired = false;
    const waiters = state.outcomeAckWaiters.splice(0, state.outcomeAckWaiters.length);
    waiters.forEach((resolve) => resolve());
  }
}

function waitForBattleOutcomeAcknowledge() {
  if (!state.outcomeAckRequired) return Promise.resolve();
  return new Promise((resolve) => {
    state.outcomeAckWaiters.push(resolve);
  });
}

function tryAcknowledgeBattleOutcome(event) {
  if (!state.outcomeAckRequired) return false;
  clearBattleOutcome(true);
  if (event) {
    event.preventDefault();
    event.stopPropagation();
  }
  return true;
}

function showBattleOutcome(message, wasSuccess, requireAck = false) {
  if (!battleOutcomeEl) return;
  clearBattleOutcome(true);
  const text = requireAck
    ? `${message} Tap anywhere to continue.`
    : message;
  battleOutcomeEl.textContent = text;
  battleOutcomeEl.classList.add(wasSuccess ? "success" : "fail", "visible");
  if (requireAck) {
    state.outcomeAckRequired = true;
    battleOutcomeEl.classList.add("ack-required");
    return;
  }
  battleOutcomeTimer = setTimeout(() => {
    clearBattleOutcome(false);
  }, 2400);
}

function clampNumber(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function isMobileLikeUI() {
  return (
    window.matchMedia("(max-width: 980px)").matches ||
    window.matchMedia("(pointer: coarse)").matches
  );
}

function applyMapCamera() {
  const mobileLike = isMobileLikeUI();
  const safeScale = Math.max(1, mapCamera.scale);
  const labelMobileBoost = mobileLike ? 1.44 : 1.02;

  const labelScreenMin = mobileLike ? 21.2 : 11.6;
  const labelScreenMax = mobileLike ? 30.0 : 15.4;
  const labelShrinkPower = mobileLike ? 0.0 : 0.05;

  const chipWidth = mobileLike ? 92 : 44;
  const chipHeight = mobileLike ? 42 : 19;
  const chipOffsetX = mobileLike ? 63 : 32;
  const chipTextOffset = mobileLike ? 19.0 : 9.5;
  const chipTextFont = mobileLike ? 27 : 13.2;
  const chipTextStroke = mobileLike ? 1.86 : 1.0;
  const chipBorderStroke = mobileLike ? 1.95 : 1.05;
  const pinShadowR = mobileLike ? 19.6 : 10.7;
  const pinRingR = mobileLike ? 16.9 : 9.0;
  const pinFillR = mobileLike ? 14.1 : 7.5;
  const pinShift = mobileLike ? 2.0 : 1.0;
  const crownFont = mobileLike ? 14.5 : 7.8;

  worldMapEl.setAttribute(
    "viewBox",
    `${mapCamera.x.toFixed(2)} ${mapCamera.y.toFixed(2)} ${mapCamera.w.toFixed(2)} ${mapCamera.h.toFixed(2)}`
  );
  const routeScreenStroke = mobileLike ? 1.0 : 1.2;
  const routeDashA = mobileLike ? 4.4 : 5;
  const routeDashB = mobileLike ? 4.4 : 5;
  routeEls.forEach((routeLine) => {
    routeLine.style.strokeWidth = `${(routeScreenStroke / safeScale).toFixed(3)}px`;
    routeLine.style.strokeDasharray = `${(routeDashA / safeScale).toFixed(3)} ${(routeDashB / safeScale).toFixed(3)}`;
  });
  if (aimLineEl) {
    const aimStroke = mobileLike ? 3.0 : 3.5;
    aimLineEl.style.strokeWidth = `${(aimStroke / safeScale).toFixed(3)}px`;
    aimLineEl.style.strokeDasharray = `${(12 / safeScale).toFixed(3)} ${(8 / safeScale).toFixed(3)}`;
  }
  if (moveLineEl) {
    const moveStroke = mobileLike ? 3.4 : 4.5;
    moveLineEl.style.strokeWidth = `${(moveStroke / safeScale).toFixed(3)}px`;
    moveLineEl.style.strokeDasharray = `${(16 / safeScale).toFixed(3)} ${(10 / safeScale).toFixed(3)}`;
  }
  const chipBoxes = Object.values(territoryEls).map((entry) => {
    const side = entry.chipSide || 1;
    return {
      name: entry.name,
      cx: entry.tokenX + ((chipOffsetX * side) / safeScale),
      cy: entry.tokenY,
      halfW: (chipWidth / 2) / safeScale,
      halfH: (chipHeight / 2) / safeScale
    };
  });
  Object.values(territoryEls).forEach((entry) => {
    const {
      name,
      polygon,
      army,
      label,
      labelLine,
      troopIcon,
      shipCount,
      statsPlate,
      statsDivider,
      armyFill,
      armyRing,
      pinShadow,
      chipSide,
      labelBaseX,
      labelBaseY,
      tokenX,
      tokenY
    } = entry;
    const territory = state.territories[name];
    const emphasized =
      state.selection.from === name ||
      state.selection.to === name ||
      movementCue?.from === name ||
      movementCue?.to === name;

    const side = chipSide || 1;
    const chipCenterX = tokenX + ((chipOffsetX * side) / safeScale);
    const chipCenterY = tokenY;
    const chipMapW = chipWidth / safeScale;
    const chipMapH = chipHeight / safeScale;
    const chipMapHalfText = chipTextOffset / safeScale;
    const showCapitalMarker = hasCapitalIcon(name);

    const localDensity = Number.parseFloat(label?.dataset.localDensity || "0");
    const densityStep = mobileLike ? 0.01 : 0.035;
    const densityFloor = mobileLike ? 0.97 : 0.88;
    const densityScale = clampNumber(1 - (localDensity * densityStep), densityFloor, 1);
    const emphasisScale = emphasized ? 1.12 : 1;
    const labelBase = Number.parseFloat(label?.dataset.baseFont || "9");
    const screenLabel = clampNumber(
      (labelBase * emphasisScale * labelMobileBoost) / Math.pow(safeScale, labelShrinkPower),
      labelScreenMin,
      labelScreenMax
    );
    const screenLabelStroke = clampNumber(0.72 / Math.pow(safeScale, 0.06), mobileLike ? 0.5 : 0.2, 0.9);
    const labelMapUnits = (screenLabel * densityScale) / safeScale;

    const baseLabelX = Number.isFinite(labelBaseX) ? labelBaseX : tokenX;
    const baseLabelY = Number.isFinite(labelBaseY) ? labelBaseY : tokenY;
    let effectiveLabelX = baseLabelX;
    let effectiveLabelY = baseLabelY;
    let labelWasNudged = false;
    if (label) {
      const labelText = (label.textContent || "").trim();
      const labelCharCount = Math.max(3, labelText.length);
      const labelHalfW = ((labelCharCount * screenLabel * (mobileLike ? 0.27 : 0.24)) + (mobileLike ? 12 : 8)) / safeScale;
      const labelHalfH = ((screenLabel * 0.62) + (mobileLike ? 8 : 5)) / safeScale;
      const boundsMargin = (mobileLike ? 10 : 8) / safeScale;
      const verticalStep = ((chipHeight * 0.9) + (mobileLike ? 18 : 10)) / safeScale;
      const lateralStep = ((chipWidth * 0.55) + (mobileLike ? 18 : 10)) / safeScale;
      const candidates = [
        { x: baseLabelX, y: baseLabelY },
        { x: baseLabelX, y: baseLabelY - verticalStep },
        { x: baseLabelX, y: baseLabelY + verticalStep },
        { x: baseLabelX - (lateralStep * side), y: baseLabelY - (verticalStep * 0.35) },
        { x: baseLabelX - (lateralStep * side), y: baseLabelY + (verticalStep * 0.35) },
        { x: baseLabelX + (lateralStep * side * 0.32), y: baseLabelY - (verticalStep * 1.25) },
        { x: baseLabelX + (lateralStep * side * 0.32), y: baseLabelY + (verticalStep * 1.25) }
      ];

      const scoreCandidate = (candidateX, candidateY) => {
        let overlapScore = 0;
        chipBoxes.forEach((chipBox) => {
          const dx = Math.abs(candidateX - chipBox.cx) - (chipBox.halfW + labelHalfW);
          const dy = Math.abs(candidateY - chipBox.cy) - (chipBox.halfH + labelHalfH);
          if (dx < 0 && dy < 0) overlapScore += Math.abs(dx) + Math.abs(dy);
        });
        return overlapScore;
      };

      let bestX = clampNumber(
        baseLabelX,
        MAP_BASE_VIEWBOX.x + labelHalfW + boundsMargin,
        MAP_BASE_VIEWBOX.x + MAP_BASE_VIEWBOX.w - labelHalfW - boundsMargin
      );
      let bestY = clampNumber(
        baseLabelY,
        MAP_BASE_VIEWBOX.y + labelHalfH + boundsMargin,
        MAP_BASE_VIEWBOX.y + MAP_BASE_VIEWBOX.h - labelHalfH - boundsMargin
      );
      let bestOverlap = scoreCandidate(bestX, bestY);
      let bestShift = Math.hypot(bestX - baseLabelX, bestY - baseLabelY);

      for (const candidate of candidates) {
        const candidateX = clampNumber(
          candidate.x,
          MAP_BASE_VIEWBOX.x + labelHalfW + boundsMargin,
          MAP_BASE_VIEWBOX.x + MAP_BASE_VIEWBOX.w - labelHalfW - boundsMargin
        );
        const candidateY = clampNumber(
          candidate.y,
          MAP_BASE_VIEWBOX.y + labelHalfH + boundsMargin,
          MAP_BASE_VIEWBOX.y + MAP_BASE_VIEWBOX.h - labelHalfH - boundsMargin
        );
        const overlap = scoreCandidate(candidateX, candidateY);
        const shift = Math.hypot(candidateX - baseLabelX, candidateY - baseLabelY);
        const isBetter = overlap < bestOverlap - 0.0001 || (Math.abs(overlap - bestOverlap) <= 0.0001 && shift < bestShift);
        if (isBetter) {
          bestX = candidateX;
          bestY = candidateY;
          bestOverlap = overlap;
          bestShift = shift;
        }
        if (bestOverlap <= 0.0001 && bestShift <= (1.0 / safeScale)) break;
      }

      effectiveLabelX = bestX;
      effectiveLabelY = bestY;
      labelWasNudged = Math.hypot(effectiveLabelX - baseLabelX, effectiveLabelY - baseLabelY) > (1.0 / safeScale);
    }

    if (label) {
      label.setAttribute("x", effectiveLabelX.toFixed(3));
      label.setAttribute("y", effectiveLabelY.toFixed(3));
      label.style.fontSize = `${labelMapUnits.toFixed(2)}px`;
      label.style.strokeWidth = `${(screenLabelStroke / safeScale).toFixed(2)}px`;
      label.style.opacity = emphasized ? "1" : "0.94";
    }
    if (labelLine) {
      const external = label?.dataset.external === "1" || labelWasNudged;
      const baseLineStroke = external ? (mobileLike ? 1.08 : 0.92) : 0.7;
      const lineStroke = clampNumber(baseLineStroke / Math.pow(safeScale, 0.1), mobileLike ? 0.48 : 0.36, 1.2);
      labelLine.setAttribute("x1", tokenX.toFixed(3));
      labelLine.setAttribute("y1", (tokenY - (tokenRadiusFor(name) * 0.35)).toFixed(3));
      labelLine.setAttribute("x2", effectiveLabelX.toFixed(3));
      labelLine.setAttribute("y2", effectiveLabelY.toFixed(3));
      labelLine.style.strokeWidth = `${(lineStroke / safeScale).toFixed(2)}px`;
      labelLine.style.opacity = external ? (emphasized ? "0.92" : "0.72") : "0";
    }

    if (polygon) {
      const highlighted = state.selection.from === name || state.selection.to === name;
      const fortified = territory?.fortified > 0;
      const openingSeason =
        isLocalTurnOwner() &&
        state.phase === "reinforce" &&
        state.year === 1850 &&
        state.seasonIndex === 0 &&
        state.homeBase === name;
      let strokeScreen = mobileLike ? 1.52 : 1.8;
      if (fortified) strokeScreen = Math.max(strokeScreen, mobileLike ? 2.5 : 2.7);
      if (openingSeason) strokeScreen = Math.max(strokeScreen, mobileLike ? 3.0 : 3.2);
      if (highlighted) strokeScreen = Math.max(strokeScreen, mobileLike ? 4.3 : 4.0);
      polygon.style.strokeWidth = `${(strokeScreen / safeScale).toFixed(3)}px`;
    }

    if (!army) return;

    if (statsPlate) {
      statsPlate.setAttribute("x", (chipCenterX - (chipMapW / 2)).toFixed(3));
      statsPlate.setAttribute("y", (chipCenterY - (chipMapH / 2)).toFixed(3));
      statsPlate.setAttribute("width", chipMapW.toFixed(3));
      statsPlate.setAttribute("height", chipMapH.toFixed(3));
      statsPlate.setAttribute("rx", (3.7 / safeScale).toFixed(3));
      statsPlate.setAttribute("ry", (3.7 / safeScale).toFixed(3));
      statsPlate.style.strokeWidth = `${(chipBorderStroke / safeScale).toFixed(2)}px`;
    }
    if (statsDivider) {
      statsDivider.setAttribute("x1", chipCenterX.toFixed(3));
      statsDivider.setAttribute("y1", (chipCenterY - (chipMapH * 0.42)).toFixed(3));
      statsDivider.setAttribute("x2", chipCenterX.toFixed(3));
      statsDivider.setAttribute("y2", (chipCenterY + (chipMapH * 0.42)).toFixed(3));
      statsDivider.style.strokeWidth = `${(0.9 / safeScale).toFixed(2)}px`;
    }

    army.style.fontSize = `${(chipTextFont / safeScale).toFixed(2)}px`;
    army.style.strokeWidth = `${(chipTextStroke / safeScale).toFixed(2)}px`;
    army.setAttribute("x", (chipCenterX - chipMapHalfText).toFixed(3));
    army.setAttribute("y", chipCenterY.toFixed(3));

    if (troopIcon) {
      troopIcon.style.display = showCapitalMarker ? "block" : "none";
      if (showCapitalMarker) {
        troopIcon.style.fontSize = `${(crownFont / safeScale).toFixed(2)}px`;
        troopIcon.style.strokeWidth = `${(0.42 / safeScale).toFixed(2)}px`;
        troopIcon.setAttribute("x", tokenX.toFixed(3));
        troopIcon.setAttribute("y", tokenY.toFixed(3));
      }
    }

    if (shipCount) {
      shipCount.style.fontSize = `${(chipTextFont / safeScale).toFixed(2)}px`;
      shipCount.style.strokeWidth = `${(chipTextStroke / safeScale).toFixed(2)}px`;
      shipCount.setAttribute("x", (chipCenterX + chipMapHalfText).toFixed(3));
      shipCount.setAttribute("y", chipCenterY.toFixed(3));
    }

    if (pinShadow) {
      pinShadow.style.display = showCapitalMarker ? "block" : "none";
      if (showCapitalMarker) {
        pinShadow.setAttribute("cx", (tokenX + (pinShift / safeScale)).toFixed(3));
        pinShadow.setAttribute("cy", (tokenY + (pinShift / safeScale)).toFixed(3));
        pinShadow.setAttribute("r", (pinShadowR / safeScale).toFixed(3));
        pinShadow.style.strokeWidth = `${(0.58 / safeScale).toFixed(2)}px`;
      }
    }
    if (armyRing) {
      armyRing.style.display = showCapitalMarker ? "block" : "none";
      if (showCapitalMarker) {
        armyRing.setAttribute("cx", tokenX.toFixed(3));
        armyRing.setAttribute("cy", tokenY.toFixed(3));
        armyRing.setAttribute("r", (pinRingR / safeScale).toFixed(3));
        armyRing.style.strokeWidth = `${(1.0 / safeScale).toFixed(2)}px`;
      }
    }
    if (armyFill) {
      armyFill.style.display = showCapitalMarker ? "block" : "none";
      if (showCapitalMarker) {
        armyFill.setAttribute("cx", tokenX.toFixed(3));
        armyFill.setAttribute("cy", tokenY.toFixed(3));
        armyFill.setAttribute("r", (pinFillR / safeScale).toFixed(3));
        armyFill.style.strokeWidth = `${(0.7 / safeScale).toFixed(2)}px`;
      }
    }
  });
}

function clampMapCameraPosition() {
  const maxX = MAP_BASE_VIEWBOX.x + MAP_BASE_VIEWBOX.w - mapCamera.w;
  const maxY = MAP_BASE_VIEWBOX.y + MAP_BASE_VIEWBOX.h - mapCamera.h;
  mapCamera.x = clampNumber(mapCamera.x, MAP_BASE_VIEWBOX.x, maxX);
  mapCamera.y = clampNumber(mapCamera.y, MAP_BASE_VIEWBOX.y, maxY);
}

function pointRatioInMap(clientX, clientY) {
  const rect = worldMapEl.getBoundingClientRect();
  if (rect.width <= 0 || rect.height <= 0) return null;
  return {
    rect,
    rx: clampNumber((clientX - rect.left) / rect.width, 0, 1),
    ry: clampNumber((clientY - rect.top) / rect.height, 0, 1)
  };
}

function setMapScale(nextScale, clientX, clientY) {
  const scale = clampNumber(nextScale, mapCamera.minScale, mapCamera.maxScale);
  const point = pointRatioInMap(clientX, clientY);
  if (!point) return;

  const anchorWorldX = mapCamera.x + (point.rx * mapCamera.w);
  const anchorWorldY = mapCamera.y + (point.ry * mapCamera.h);
  const nextWidth = MAP_BASE_VIEWBOX.w / scale;
  const nextHeight = MAP_BASE_VIEWBOX.h / scale;

  mapCamera.scale = scale;
  mapCamera.w = nextWidth;
  mapCamera.h = nextHeight;
  mapCamera.x = anchorWorldX - (point.rx * nextWidth);
  mapCamera.y = anchorWorldY - (point.ry * nextHeight);
  clampMapCameraPosition();
  applyMapCamera();
}

function zoomMapBy(multiplier, clientX = null, clientY = null) {
  const rect = worldMapEl.getBoundingClientRect();
  const cx = clientX ?? (rect.left + (rect.width / 2));
  const cy = clientY ?? (rect.top + (rect.height / 2));
  setMapScale(mapCamera.scale * multiplier, cx, cy);
}

function resetMapCamera() {
  mapCamera.minScale = isMobileLikeUI() ? 3.2 : 1.26;
  mapCamera.maxScale = isMobileLikeUI() ? 9.8 : 7.4;
  mapCamera.scale = mapCamera.minScale;
  mapCamera.w = MAP_BASE_VIEWBOX.w / mapCamera.scale;
  mapCamera.h = MAP_BASE_VIEWBOX.h / mapCamera.scale;
  mapCamera.x = MAP_BASE_VIEWBOX.x + ((MAP_BASE_VIEWBOX.w - mapCamera.w) / 2);
  mapCamera.y = MAP_BASE_VIEWBOX.y + ((MAP_BASE_VIEWBOX.h - mapCamera.h) / 2);
  mapCamera.activePointerId = null;
  mapCamera.dragStart = null;
  mapCamera.pointers.clear();
  mapCamera.pinchStart = null;
  worldMapEl.classList.remove("dragging");
  applyMapCamera();
}

function focusMapOnTerritory(name, desiredScale = null) {
  const layout = MAP_LAYOUT[name];
  if (!layout) return;
  const defaultScale = isMobileLikeUI() ? 4.8 : 2.7;
  const scale = clampNumber(desiredScale ?? defaultScale, mapCamera.minScale, mapCamera.maxScale);
  mapCamera.scale = scale;
  mapCamera.w = MAP_BASE_VIEWBOX.w / scale;
  mapCamera.h = MAP_BASE_VIEWBOX.h / scale;
  mapCamera.x = layout.token.x - (mapCamera.w / 2);
  mapCamera.y = layout.token.y - (mapCamera.h / 2);
  mapCamera.activePointerId = null;
  mapCamera.dragStart = null;
  mapCamera.pointers.clear();
  mapCamera.pinchStart = null;
  worldMapEl.classList.remove("dragging");
  clampMapCameraPosition();
  applyMapCamera();
}

function markMapClickSuppressed() {
  const delay = isMobileLikeUI() ? 240 : 140;
  mapCamera.suppressClickUntil = performance.now() + delay;
}

function shouldIgnoreMapClick() {
  return performance.now() < mapCamera.suppressClickUntil;
}

function setupMapInteractions() {
  if (mapCamera.interactionsBound) return;
  mapCamera.interactionsBound = true;
  resetMapCamera();

  worldMapEl.addEventListener("wheel", (event) => {
    event.preventDefault();
    const factor = Math.exp((-event.deltaY) * 0.0015);
    setMapScale(mapCamera.scale * factor, event.clientX, event.clientY);
  }, { passive: false });

  worldMapEl.addEventListener("dblclick", (event) => {
    event.preventDefault();
    resetMapCamera();
  });

  const releaseCapture = (pointerId) => {
    if (
      typeof worldMapEl.hasPointerCapture === "function" &&
      typeof worldMapEl.releasePointerCapture === "function" &&
      worldMapEl.hasPointerCapture(pointerId)
    ) {
      worldMapEl.releasePointerCapture(pointerId);
    }
  };

  const stopPan = (pointerId) => {
    if (pointerId !== mapCamera.activePointerId) return;
    const moved = Boolean(mapCamera.dragStart?.moved);
    if (mapCamera.dragStart?.captured) releaseCapture(pointerId);
    mapCamera.activePointerId = null;
    mapCamera.dragStart = null;
    worldMapEl.classList.remove("dragging");
    if (moved) markMapClickSuppressed();
  };

  const beginPinch = () => {
    if (mapCamera.pointers.size < 2) return;
    const entries = Array.from(mapCamera.pointers.entries()).slice(0, 2);
    const [idA, a] = entries[0];
    const [idB, b] = entries[1];
    const distance = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
    const minDistance = isMobileLikeUI() ? 6.5 : 3.2;
    if (distance < minDistance) return;
    mapCamera.pinchStart = {
      ids: [idA, idB],
      distance,
      scale: mapCamera.scale,
      lastDistance: distance,
      lastScale: mapCamera.scale,
      lastCenterX: (a.clientX + b.clientX) / 2,
      lastCenterY: (a.clientY + b.clientY) / 2,
      moved: false
    };
    mapCamera.activePointerId = null;
    mapCamera.dragStart = null;
    worldMapEl.classList.remove("dragging");
    if (typeof worldMapEl.setPointerCapture === "function") {
      for (const id of mapCamera.pinchStart.ids) {
        try {
          worldMapEl.setPointerCapture(id);
        } catch (_) {
          // ignore per-pointer capture failures
        }
      }
    }
  };

  const stopPinch = () => {
    if (!mapCamera.pinchStart) return;
    for (const id of mapCamera.pinchStart.ids) {
      releaseCapture(id);
    }
    if (mapCamera.pinchStart.moved) markMapClickSuppressed();
    mapCamera.pinchStart = null;
  };

  worldMapEl.addEventListener("pointerdown", (event) => {
    if (event.pointerType === "mouse" && event.button !== 0) return;
    if (event.pointerType !== "mouse") event.preventDefault();
    mapCamera.pointers.set(event.pointerId, {
      clientX: event.clientX,
      clientY: event.clientY
    });

    if (mapCamera.pointers.size >= 2 && event.pointerType !== "mouse") {
      beginPinch();
      return;
    }

    if (mapCamera.pinchStart) return;
    if (mapCamera.activePointerId !== null && mapCamera.activePointerId !== event.pointerId) return;
    const rect = worldMapEl.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return;

    mapCamera.activePointerId = event.pointerId;
    mapCamera.dragStart = {
      clientX: event.clientX,
      clientY: event.clientY,
      x: mapCamera.x,
      y: mapCamera.y,
      w: mapCamera.w,
      h: mapCamera.h,
      moved: false,
      captured: false
    };

    if (event.pointerType !== "mouse" && typeof worldMapEl.setPointerCapture === "function") {
      try {
        worldMapEl.setPointerCapture(event.pointerId);
        mapCamera.dragStart.captured = true;
      } catch (_) {
        mapCamera.dragStart.captured = false;
      }
    }
  });

  worldMapEl.addEventListener("pointermove", (event) => {
    if (mapCamera.pointers.has(event.pointerId)) {
      mapCamera.pointers.set(event.pointerId, {
        clientX: event.clientX,
        clientY: event.clientY
      });
    }
    if (event.pointerType !== "mouse" && (mapCamera.pinchStart || mapCamera.activePointerId === event.pointerId)) {
      event.preventDefault();
    }

    if (mapCamera.pinchStart) {
      const [idA, idB] = mapCamera.pinchStart.ids;
      const a = mapCamera.pointers.get(idA);
      const b = mapCamera.pointers.get(idB);
      if (!a || !b) return;
      const distance = Math.hypot(b.clientX - a.clientX, b.clientY - a.clientY);
      const minDistance = isMobileLikeUI() ? 6.5 : 3.2;
      if (distance < minDistance) return;
      const centerX = (a.clientX + b.clientX) / 2;
      const centerY = (a.clientY + b.clientY) / 2;
      const rect = worldMapEl.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return;
      const pinch = mapCamera.pinchStart;
      const centerDx = centerX - pinch.lastCenterX;
      const centerDy = centerY - pinch.lastCenterY;
      const centerTravel = Math.hypot(centerDx, centerDy);
      if (centerTravel > (isMobileLikeUI() ? 1.2 : 0.8)) {
        mapCamera.x -= (centerDx / rect.width) * mapCamera.w;
        mapCamera.y -= (centerDy / rect.height) * mapCamera.h;
        clampMapCameraPosition();
      }

      const ratio = distance / pinch.lastDistance;
      const pinchCurve = isMobileLikeUI() ? 1.0 : 1;
      const zoomDeadzone = isMobileLikeUI() ? 0.085 : 0.025;
      const prevScale = mapCamera.scale;
      if (Math.abs(ratio - 1) > zoomDeadzone) {
        setMapScale(mapCamera.scale * Math.pow(ratio, pinchCurve), centerX, centerY);
      } else {
        applyMapCamera();
      }

      if (
        !pinch.moved &&
        (centerTravel > (isMobileLikeUI() ? 3.2 : 2.2) || Math.abs(prevScale - mapCamera.scale) > 0.01)
      ) {
        pinch.moved = true;
      }
      pinch.lastCenterX = centerX;
      pinch.lastCenterY = centerY;
      pinch.lastDistance = distance;
      pinch.lastScale = mapCamera.scale;
      return;
    }

    if (event.pointerId !== mapCamera.activePointerId || !mapCamera.dragStart) return;
    const rect = worldMapEl.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return;

    const dx = event.clientX - mapCamera.dragStart.clientX;
    const dy = event.clientY - mapCamera.dragStart.clientY;
    const panThreshold = isMobileLikeUI() ? 4.8 : 4;
    if (!mapCamera.dragStart.moved) {
      if (Math.hypot(dx, dy) <= panThreshold) return;
      mapCamera.dragStart.moved = true;
      worldMapEl.classList.add("dragging");
      if (typeof worldMapEl.setPointerCapture === "function") {
        try {
          worldMapEl.setPointerCapture(event.pointerId);
          mapCamera.dragStart.captured = true;
        } catch (_) {
          mapCamera.dragStart.captured = false;
        }
      }
    }

    mapCamera.x = mapCamera.dragStart.x - ((dx / rect.width) * mapCamera.dragStart.w);
    mapCamera.y = mapCamera.dragStart.y - ((dy / rect.height) * mapCamera.dragStart.h);
    clampMapCameraPosition();
    applyMapCamera();
  });

  const endPointer = (event) => {
    const endedPinchPointer = Boolean(mapCamera.pinchStart?.ids.includes(event.pointerId));
    stopPan(event.pointerId);
    mapCamera.pointers.delete(event.pointerId);

    if (endedPinchPointer) {
      stopPinch();
      if (mapCamera.pointers.size === 1) {
        const [id, pointer] = Array.from(mapCamera.pointers.entries())[0];
        mapCamera.activePointerId = id;
        mapCamera.dragStart = {
          clientX: pointer.clientX,
          clientY: pointer.clientY,
          x: mapCamera.x,
          y: mapCamera.y,
          w: mapCamera.w,
          h: mapCamera.h,
          moved: false,
          captured: false
        };
      }
      return;
    }

    if (mapCamera.pinchStart && mapCamera.pointers.size < 2) {
      stopPinch();
    }
  };

  worldMapEl.addEventListener("pointerup", endPointer);
  worldMapEl.addEventListener("pointercancel", endPointer);

  if (zoomInBtn) {
    zoomInBtn.addEventListener("click", () => zoomMapBy(1.2));
  }
  if (zoomOutBtn) {
    zoomOutBtn.addEventListener("click", () => zoomMapBy(1 / 1.2));
  }
  if (zoomResetBtn) {
    zoomResetBtn.addEventListener("click", () => {
      const capitalFocus = ownerCapitalTerritory(localHumanOwner()) || state.homeBase || firstPlayerTerritoryName();
      if (capitalFocus) {
        focusMapOnTerritory(capitalFocus);
      } else {
        resetMapCamera();
      }
    });
  }
}

function getAudioContext() {
  if (!audioState.supported) return null;
  if (audioState.context) return audioState.context;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if (!Ctx) return null;
  audioState.context = new Ctx();
  audioState.masterGain = audioState.context.createGain();
  audioState.masterGain.gain.value = audioState.volume;
  audioState.masterGain.connect(audioState.context.destination);
  return audioState.context;
}

async function unlockAudio() {
  const ctx = getAudioContext();
  if (!ctx) return;
  if (ctx.state === "suspended") {
    try {
      await ctx.resume();
    } catch (_) {
      return;
    }
  }
  if (audioState.enabled) startBackgroundMusic();
}

function playTone(freq, options = {}) {
  if (!audioState.enabled) return;
  const ctx = getAudioContext();
  if (!ctx) return;
  if (ctx.state !== "running") {
    ctx.resume().then(() => playTone(freq, options)).catch(() => {});
    return;
  }

  const {
    delay = 0,
    duration = 0.11,
    gain = 0.07,
    type = "triangle",
    attack = 0.005,
    release = 0.08
  } = options;

  const now = ctx.currentTime + delay;
  const osc = ctx.createOscillator();
  const env = ctx.createGain();

  osc.type = type;
  osc.frequency.setValueAtTime(freq, now);

  env.gain.setValueAtTime(0.0001, now);
  env.gain.linearRampToValueAtTime(gain, now + attack);
  env.gain.exponentialRampToValueAtTime(0.0001, now + duration + release);

  osc.connect(env);
  env.connect(audioState.masterGain || ctx.destination);
  osc.start(now);
  osc.stop(now + duration + release + 0.01);
}

function scheduleMusicBar() {
  if (!audioState.enabled) return;
  const beat = MUSIC_BEAT_SECONDS;
  MUSIC_BARS.forEach((bar, index) => {
    const start = index * beat * 2;
    playTone(bar.bass, {
      delay: start,
      type: "sine",
      duration: beat * 1.72,
      gain: 0.019,
      attack: 0.03,
      release: 0.24
    });
    playTone(bar.upper1, {
      delay: start + 0.04,
      type: "triangle",
      duration: beat * 1.45,
      gain: 0.015,
      attack: 0.024,
      release: 0.18
    });
    playTone(bar.upper2, {
      delay: start + 0.08,
      type: "triangle",
      duration: beat * 1.25,
      gain: 0.012,
      attack: 0.024,
      release: 0.18
    });
    playTone(bar.lead, {
      delay: start + (beat * 1.04),
      type: "triangle",
      duration: beat * 0.42,
      gain: 0.017,
      attack: 0.01,
      release: 0.11
    });
  });
}

function stopBackgroundMusic() {
  if (audioState.musicTimer !== null) {
    window.clearTimeout(audioState.musicTimer);
    audioState.musicTimer = null;
  }
}

function startBackgroundMusic() {
  if (!audioState.enabled || !audioState.supported) return;
  if (audioState.musicTimer !== null) return;
  const loop = () => {
    if (!audioState.enabled) {
      stopBackgroundMusic();
      return;
    }
    scheduleMusicBar();
    audioState.musicTimer = window.setTimeout(loop, MUSIC_BAR_MS);
  };
  loop();
}

function playSound(effect) {
  switch (effect) {
    case "select":
      playTone(620, { duration: 0.05, gain: 0.045 });
      break;
    case "land-move":
      playTone(246, { type: "triangle", duration: 0.08, gain: 0.068 });
      playTone(310, { delay: 0.07, type: "triangle", duration: 0.075, gain: 0.064 });
      break;
    case "ship-move":
      playTone(178, { type: "sine", duration: 0.12, gain: 0.06 });
      playTone(224, { delay: 0.09, type: "triangle", duration: 0.1, gain: 0.056 });
      playTone(280, { delay: 0.17, type: "sine", duration: 0.08, gain: 0.05 });
      break;
    case "attack-success":
      playTone(294, { type: "square", duration: 0.07, gain: 0.072 });
      playTone(392, { delay: 0.075, type: "triangle", duration: 0.08, gain: 0.078 });
      playTone(523, { delay: 0.16, type: "triangle", duration: 0.1, gain: 0.08 });
      break;
    case "attack-fail":
      playTone(220, { type: "sawtooth", duration: 0.08, gain: 0.07 });
      playTone(184, { delay: 0.07, type: "square", duration: 0.085, gain: 0.067 });
      playTone(146, { delay: 0.14, type: "sawtooth", duration: 0.09, gain: 0.064 });
      break;
    case "invalid":
      playTone(160, { type: "sawtooth", duration: 0.1, gain: 0.055 });
      break;
    case "turn":
      playTone(420, { duration: 0.08, gain: 0.052 });
      playTone(530, { delay: 0.08, duration: 0.09, gain: 0.052 });
      break;
    case "ding":
      playTone(740, { type: "triangle", duration: 0.08, gain: 0.06 });
      playTone(988, { delay: 0.07, type: "triangle", duration: 0.1, gain: 0.064 });
      break;
    case "test":
      playSound("land-move");
      playSound("ship-move");
      playSound("attack-success");
      playSound("ding");
      break;
    default:
      break;
  }
}

function getSaveStorage() {
  try {
    return window.localStorage;
  } catch (error) {
    return null;
  }
}

function formatSavedTimestamp(savedAt) {
  if (typeof savedAt !== "string") return "unknown time";
  const parsed = new Date(savedAt);
  if (Number.isNaN(parsed.getTime())) return "unknown time";
  return parsed.toLocaleString([], {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  });
}

function normalizeSetupOptions(options) {
  const source = options && typeof options === "object" ? options : {};
  return {
    playMode: setupModeById(source.playMode).id,
    mapPreset: setupMapPresetById(source.mapPreset).id,
    rulesPreset: setupRulesPresetById(source.rulesPreset).id,
    difficulty: setupDifficultyById(source.difficulty).id,
    campaignMode: setupCampaignModeById(source.campaignMode).id,
    passPlayers: Math.max(2, Math.min(6, Number.parseInt(source.passPlayers, 10) || 2))
  };
}

function readSavedGamePayload() {
  const storage = getSaveStorage();
  if (!storage) return null;
  const raw = storage.getItem(SAVE_STORAGE_KEY);
  if (!raw) return null;
  try {
    const payload = JSON.parse(raw);
    if (!payload || typeof payload !== "object") return null;
    if (!payload.game || typeof payload.game !== "object") return null;
    return payload;
  } catch (error) {
    return null;
  }
}

function updateSavedGameMenuUI() {
  const payload = readSavedGamePayload();
  const saveAllowed = !state.setupOpen && !state.animating;
  if (mobileMenuSaveBtn) mobileMenuSaveBtn.disabled = !saveAllowed;
  if (mobileMenuLoadBtn) mobileMenuLoadBtn.disabled = !payload;
  if (mobileMenuSaveStatus) {
    if (!payload) {
      mobileMenuSaveStatus.textContent = "No saved game.";
    } else {
      mobileMenuSaveStatus.textContent = `Saved: ${formatSavedTimestamp(payload.savedAt)}`;
    }
  }
}

function captureGameSaveSnapshot() {
  ensureTreasuryLedger();
  const territorySnapshot = {};
  Object.keys(TERRITORIES).forEach((name) => {
    const territory = state.territories[name] || {};
    const owner = VALID_OWNER_SET.has(territory.owner) ? territory.owner : "neutral";
    territorySnapshot[name] = {
      owner,
      armies: Math.max(0, Math.round(Number(territory.armies) || 0)),
      fortified: Math.max(0, Math.round(Number(territory.fortified) || 0))
    };
  });
  return {
    territories: territorySnapshot,
    turn: state.turn,
    phase: state.phase,
    reinforcementsLeft: state.reinforcementsLeft,
    attackForce: state.attackForce,
    attackShips: state.attackShips,
    selection: { from: state.selection.from, to: state.selection.to },
    homeBase: state.homeBase,
    ships: state.ships,
    playerShipLocations: { ...state.playerShipLocations },
    aiShips: { ...state.aiShips },
    gameOver: state.gameOver,
    seasonIndex: state.seasonIndex,
    year: state.year,
    lastIncomeYear: state.lastIncomeYear,
    treasury: getOwnerTreasury(localHumanOwner()),
    treasuryByOwner: { ...state.treasuryByOwner },
    firstRound: state.firstRound,
    playerCountryId: state.playerCountryId,
    setupOptions: normalizeSetupOptions(state.setupOptions),
    commanderIndex: Math.max(0, Math.floor(state.multiplayer.commanderIndex || 0)),
    forceMenuHidden: state.forceMenuHidden,
    mapCamera: {
      x: mapCamera.x,
      y: mapCamera.y,
      scale: mapCamera.scale
    }
  };
}

function saveGameToStorage() {
  if (state.setupOpen) {
    return { ok: false, message: "Start a campaign before saving." };
  }

  if (isNetworkInputLocked()) {
    return { ok: false, message: "Wait for your network turn before saving." };
  }
  if (state.animating) {
    return { ok: false, message: "Wait for animations to finish before saving." };
  }
  const storage = getSaveStorage();
  if (!storage) {
    return { ok: false, message: "This browser does not allow local saves." };
  }
  const payload = {
    version: SAVE_FORMAT_VERSION,
    savedAt: new Date().toISOString(),
    game: captureGameSaveSnapshot()
  };
  try {
    storage.setItem(SAVE_STORAGE_KEY, JSON.stringify(payload));
    updateSavedGameMenuUI();
    return { ok: true, savedAt: payload.savedAt };
  } catch (error) {
    return { ok: false, message: "Save failed. Storage may be full or blocked." };
  }
}

function normalizeOwner(owner) {
  return VALID_OWNER_SET.has(owner) ? owner : "neutral";
}

function normalizeTerritoryName(name) {
  return typeof name === "string" && Object.prototype.hasOwnProperty.call(TERRITORIES, name) ? name : null;
}

function loadGameFromStorage() {
  const payload = readSavedGamePayload();
  if (!payload) {
    return { ok: false, message: "No saved game found." };
  }
  if (payload.version !== SAVE_FORMAT_VERSION) {
    return { ok: false, message: "Saved game format is outdated." };
  }
  const data = payload.game;
  if (!data || typeof data !== "object") {
    return { ok: false, message: "Saved game data is invalid." };
  }

  if (!aimLineEl) buildMap();

  const territoryNames = Object.keys(TERRITORIES);
  const restoredTerritories = {};
  territoryNames.forEach((name) => {
    const territory = data.territories && typeof data.territories === "object" ? data.territories[name] : null;
    restoredTerritories[name] = {
      owner: normalizeOwner(territory?.owner),
      armies: Math.max(0, Math.round(Number(territory?.armies) || 0)),
      fortified: Math.max(0, Math.round(Number(territory?.fortified) || 0))
    };
  });
  const validTurnOwners = new Set(["player", ...AI_OWNERS]);
  const hasOwnedTerritory = territoryNames.some((name) => validTurnOwners.has(restoredTerritories[name].owner));
  if (!hasOwnedTerritory) {
    return { ok: false, message: "Saved game is missing controllable territory ownership." };
  }

  state.territories = restoredTerritories;
  state.turn = validTurnOwners.has(data.turn) ? data.turn : "player";
  state.phase = data.phase === "attack" ? "attack" : "reinforce";
  state.reinforcementsLeft = Math.max(0, Math.round(Number(data.reinforcementsLeft) || 0));
  state.attackForce = Math.max(1, Math.round(Number(data.attackForce) || 1));
  state.attackShips = Math.max(0, Math.round(Number(data.attackShips) || 0));
  state.selection = {
    from: normalizeTerritoryName(data.selection?.from),
    to: normalizeTerritoryName(data.selection?.to)
  };
  state.homeBase = normalizeTerritoryName(data.homeBase) || firstPlayerTerritoryName();
  if (!state.homeBase) {
    return { ok: false, message: "Saved game does not include a valid home base." };
  }
  state.ships = Math.max(0, Math.round(Number(data.ships) || 0));
  const restoredShips = {};
  if (data.playerShipLocations && typeof data.playerShipLocations === "object") {
    territoryNames.forEach((name) => {
      const ships = Math.max(0, Math.round(Number(data.playerShipLocations[name]) || 0));
      if (ships > 0) restoredShips[name] = ships;
    });
  }
  if (Object.keys(restoredShips).length === 0 && state.ships > 0) {
    restoredShips[state.homeBase] = state.ships;
  }
  state.playerShipLocations = restoredShips;
  state.aiShips = AI_OWNERS.reduce((acc, owner) => {
    const ships = data.aiShips && typeof data.aiShips === "object"
      ? Math.round(Number(data.aiShips[owner]) || 0)
      : 0;
    acc[owner] = Math.max(0, ships);
    return acc;
  }, {});
  state.gameOver = Boolean(data.gameOver);
  state.seasonIndex = clampNumber(Math.round(Number(data.seasonIndex) || 0), 0, 3);
  state.year = Math.max(1800, Math.round(Number(data.year) || 1850));
  state.lastIncomeYear = Math.min(
    state.year,
    Math.max(1800, Math.round(Number(data.lastIncomeYear) || state.year))
  );
  const restoredTreasuryByOwner = {};
  if (data.treasuryByOwner && typeof data.treasuryByOwner === "object") {
    Object.entries(data.treasuryByOwner).forEach(([owner, value]) => {
      if (owner !== "player" && !AI_OWNERS.includes(owner)) return;
      restoredTreasuryByOwner[owner] = Math.max(0, Math.round(Number(value) || 0));
    });
  }
  if (Object.keys(restoredTreasuryByOwner).length < 1) {
    restoredTreasuryByOwner.player = Math.max(0, Math.round(Number(data.treasury) || STARTING_TREASURY));
  }
  state.treasuryByOwner = restoredTreasuryByOwner;
  syncDisplayedTreasury();
  state.firstRound = Boolean(data.firstRound);
  state.setupOpen = false;
  state.setupStep = "create";
  state.setupTab = "map";
  state.setupOptions = normalizeSetupOptions(data.setupOptions);
  const restoredCommanderIndex = Math.max(0, Math.floor(Number(data.commanderIndex) || 0));
  const commanderCount = Math.max(1, multiplayerCommanderCount());
  state.multiplayer.commanderIndex = restoredCommanderIndex % commanderCount;
  state.playerCountryId = STARTING_COUNTRY_POOL.some((country) => country.id === data.playerCountryId)
    ? data.playerCountryId
    : state.playerCountryId;
  state.forceMenuHidden = Boolean(data.forceMenuHidden);
  state.economyPanelOpen = false;
  state.animating = false;
  state.outcomeAckRequired = false;
  state.outcomeAckWaiters = [];
  attackOddsCacheKey = "";
  attackOddsCacheValue = null;

  if (logEl) logEl.innerHTML = "";
  clearMovementCue();
  clearBattleOutcome(true);
  hideCountryPicker();

  resetMapCamera();
  const savedCamera = data.mapCamera;
  if (
    savedCamera &&
    Number.isFinite(savedCamera.scale) &&
    Number.isFinite(savedCamera.x) &&
    Number.isFinite(savedCamera.y)
  ) {
    mapCamera.scale = clampNumber(savedCamera.scale, mapCamera.minScale, mapCamera.maxScale);
    mapCamera.w = MAP_BASE_VIEWBOX.w / mapCamera.scale;
    mapCamera.h = MAP_BASE_VIEWBOX.h / mapCamera.scale;
    mapCamera.x = savedCamera.x;
    mapCamera.y = savedCamera.y;
    mapCamera.activePointerId = null;
    mapCamera.dragStart = null;
    mapCamera.pointers.clear();
    mapCamera.pinchStart = null;
    clampMapCameraPosition();
    applyMapCamera();
  } else {
    const focusName = state.selection.from || state.homeBase || firstPlayerTerritoryName();
    if (focusName) focusMapOnTerritory(focusName, isMobileLikeUI() ? 5.1 : 2.85);
  }

  render();
  updateSavedGameMenuUI();
  return { ok: true, savedAt: payload.savedAt };
}

function setMobileTopMenuOpen(open) {
  const shouldOpen = Boolean(open);
  mobileTopMenuOpen = shouldOpen;
  if (mobileTopMenuEl) {
    mobileTopMenuEl.classList.toggle("visible", shouldOpen);
    mobileTopMenuEl.setAttribute("aria-hidden", shouldOpen ? "false" : "true");
  }
}

function updateMobileTopMenuUI() {
  if (mobileMenuTurnPill && turnPill) {
    mobileMenuTurnPill.textContent = turnPill.textContent;
  }
  updateSavedGameMenuUI();
}

function updateSoundToggle() {
  if (!audioState.supported) {
    soundToggleBtn.textContent = "SFX N/A";
    soundToggleBtn.setAttribute("aria-pressed", "false");
    soundToggleBtn.disabled = true;
    soundTestBtn.disabled = true;
    if (mobileMenuSfxBtn) {
      mobileMenuSfxBtn.textContent = "SFX N/A";
      mobileMenuSfxBtn.setAttribute("aria-pressed", "false");
      mobileMenuSfxBtn.disabled = true;
    }
    if (mobileMenuTestBtn) mobileMenuTestBtn.disabled = true;
    return;
  }
  soundToggleBtn.textContent = audioState.enabled ? "SFX ON" : "SFX OFF";
  soundToggleBtn.setAttribute("aria-pressed", String(audioState.enabled));
  soundToggleBtn.disabled = false;
  soundTestBtn.disabled = false;
  if (mobileMenuSfxBtn) {
    mobileMenuSfxBtn.textContent = audioState.enabled ? "SFX ON" : "SFX OFF";
    mobileMenuSfxBtn.setAttribute("aria-pressed", String(audioState.enabled));
    mobileMenuSfxBtn.disabled = false;
  }
  if (mobileMenuTestBtn) mobileMenuTestBtn.disabled = false;
}

function maxAttackForceFor(name) {
  const territory = state.territories[name];
  if (!territory || territory.owner !== localHumanOwner()) return 1;
  return Math.max(1, territory.armies - 1);
}

function maxTransferArmiesFor(name) {
  const territory = state.territories[name];
  if (!territory || territory.owner !== localHumanOwner()) return 0;
  return Math.max(0, territory.armies - 1);
}

function firstPlayerTerritoryName() {
  const owner = localHumanOwner();
  return Object.keys(state.territories).find((name) => state.territories[name].owner === owner) || null;
}

function defaultPurchaseTerritory() {
  const owner = localHumanOwner();
  if (state.selection.from && state.territories[state.selection.from]?.owner === owner) return state.selection.from;
  if (state.homeBase && state.territories[state.homeBase]?.owner === owner) return state.homeBase;
  return firstPlayerTerritoryName();
}

function capitalPurchaseTerritory() {
  const capital = ownerCapitalTerritory(localHumanOwner());
  if (!capital) return null;
  return state.territories[capital]?.owner === localHumanOwner() ? capital : null;
}

function normalizePlayableOwner(owner) {
  return owner && (owner === "player" || AI_OWNERS.includes(owner)) ? owner : "player";
}

function ensureShipLedger() {
  if (!state.shipsByOwner || typeof state.shipsByOwner !== "object") {
    state.shipsByOwner = {};
  }
  if (!state.shipLocationsByOwner || typeof state.shipLocationsByOwner !== "object") {
    state.shipLocationsByOwner = {};
  }

  const legacyShips = Math.max(0, Math.round(Number(state.ships) || 0));
  const legacyLocations = state.playerShipLocations && typeof state.playerShipLocations === "object"
    ? state.playerShipLocations
    : {};

  if (Object.keys(state.shipsByOwner).length < 1) {
    state.shipsByOwner.player = legacyShips;
  }
  if (Object.keys(state.shipLocationsByOwner).length < 1) {
    const migrated = {};
    Object.entries(legacyLocations).forEach(([name, value]) => {
      if (!Object.prototype.hasOwnProperty.call(TERRITORIES, name)) return;
      const ships = Math.max(0, Math.round(Number(value) || 0));
      if (ships > 0) migrated[name] = ships;
    });
    if (Object.keys(migrated).length > 0) {
      state.shipLocationsByOwner.player = migrated;
    }
  }

  Object.keys(state.shipsByOwner).forEach((owner) => {
    if (owner !== "player" && !AI_OWNERS.includes(owner)) {
      delete state.shipsByOwner[owner];
      return;
    }
    state.shipsByOwner[owner] = Math.max(0, Math.round(Number(state.shipsByOwner[owner]) || 0));
  });

  Object.keys(state.shipLocationsByOwner).forEach((owner) => {
    if (owner !== "player" && !AI_OWNERS.includes(owner)) {
      delete state.shipLocationsByOwner[owner];
      return;
    }
    const source = state.shipLocationsByOwner[owner];
    if (!source || typeof source !== "object") {
      state.shipLocationsByOwner[owner] = {};
      return;
    }
    const normalized = {};
    Object.entries(source).forEach(([name, value]) => {
      if (!Object.prototype.hasOwnProperty.call(TERRITORIES, name)) return;
      const ships = Math.max(0, Math.round(Number(value) || 0));
      if (ships > 0) normalized[name] = ships;
    });
    state.shipLocationsByOwner[owner] = normalized;
  });

  Object.keys(state.shipsByOwner).forEach((owner) => {
    if (!state.shipLocationsByOwner[owner]) {
      state.shipLocationsByOwner[owner] = {};
    }
    const locations = state.shipLocationsByOwner[owner];
    const docked = Object.values(locations).reduce(
      (sum, value) => sum + Math.max(0, Math.round(Number(value) || 0)),
      0
    );
    if (docked > state.shipsByOwner[owner]) {
      state.shipsByOwner[owner] = docked;
    }
    if (docked < 1 && state.shipsByOwner[owner] > 0) {
      const fallbackDock = ownerCapitalTerritory(owner) || (owner === "player" ? state.homeBase : null);
      if (fallbackDock && Object.prototype.hasOwnProperty.call(TERRITORIES, fallbackDock)) {
        locations[fallbackDock] = state.shipsByOwner[owner];
      }
    }
  });
}

function getOwnerShipLocations(owner = localHumanOwner()) {
  ensureShipLedger();
  const key = normalizePlayableOwner(owner);
  if (!state.shipLocationsByOwner[key] || typeof state.shipLocationsByOwner[key] !== "object") {
    state.shipLocationsByOwner[key] = {};
  }
  return state.shipLocationsByOwner[key];
}

function getOwnerShips(owner = localHumanOwner()) {
  ensureShipLedger();
  const key = normalizePlayableOwner(owner);
  const docked = Object.values(getOwnerShipLocations(key)).reduce(
    (sum, value) => sum + Math.max(0, Math.round(Number(value) || 0)),
    0
  );
  const recorded = Math.max(0, Math.round(Number(state.shipsByOwner[key]) || 0));
  const total = Math.max(recorded, docked);
  state.shipsByOwner[key] = total;
  return total;
}

function setOwnerShips(owner, amount) {
  ensureShipLedger();
  const key = normalizePlayableOwner(owner);
  const docked = Object.values(getOwnerShipLocations(key)).reduce(
    (sum, value) => sum + Math.max(0, Math.round(Number(value) || 0)),
    0
  );
  const next = Math.max(docked, Math.round(Number(amount) || 0));
  state.shipsByOwner[key] = next;
  if (key === localHumanOwner()) {
    state.ships = next;
  }
}

function syncDisplayedShips() {
  const key = localHumanOwner();
  state.ships = getOwnerShips(key);
  state.playerShipLocations = { ...getOwnerShipLocations(key) };
}

function ownerShipsAt(owner, name) {
  if (!name) return 0;
  return Math.max(0, getOwnerShipLocations(owner)[name] || 0);
}

function setOwnerShipsAt(owner, name, count) {
  if (!name) return;
  const key = normalizePlayableOwner(owner);
  const locations = getOwnerShipLocations(key);
  const next = Math.max(0, Math.floor(Number(count) || 0));
  if (next > 0) {
    locations[name] = next;
  } else {
    delete locations[name];
  }
  const total = Object.values(locations).reduce(
    (sum, value) => sum + Math.max(0, Math.round(Number(value) || 0)),
    0
  );
  setOwnerShips(key, total);
}

function moveOwnerShips(owner, fromName, toName, count) {
  const available = ownerShipsAt(owner, fromName);
  const toMove = Math.max(0, Math.min(Math.floor(Number(count) || 0), available));
  if (toMove < 1) return 0;
  setOwnerShipsAt(owner, fromName, available - toMove);
  setOwnerShipsAt(owner, toName, ownerShipsAt(owner, toName) + toMove);
  return toMove;
}

function playerShipsAt(name) {
  return ownerShipsAt(localHumanOwner(), name);
}

function territoryShipCount(name) {
  const territory = state.territories[name];
  if (!territory || territory.owner !== localHumanOwner()) return 0;
  return playerShipsAt(name);
}

function setPlayerShipsAt(name, count) {
  setOwnerShipsAt(localHumanOwner(), name, count);
}

function movePlayerShips(fromName, toName, count) {
  return moveOwnerShips(localHumanOwner(), fromName, toName, count);
}

function ensureTreasuryLedger() {
  if (!state.treasuryByOwner || typeof state.treasuryByOwner !== "object") {
    state.treasuryByOwner = {};
  }
  const ledger = state.treasuryByOwner;
  if (Object.keys(ledger).length < 1) {
    ledger.player = Math.max(0, Math.round(Number(state.treasury) || STARTING_TREASURY));
  }
  Object.keys(ledger).forEach((owner) => {
    if (owner !== "player" && !AI_OWNERS.includes(owner)) {
      delete ledger[owner];
      return;
    }
    ledger[owner] = Math.max(0, Math.round(Number(ledger[owner]) || 0));
  });
}

function getOwnerTreasury(owner = localHumanOwner()) {
  ensureTreasuryLedger();
  const key = owner && (owner === "player" || AI_OWNERS.includes(owner)) ? owner : "player";
  const existing = state.treasuryByOwner[key];
  if (!Number.isFinite(existing)) {
    const fallback = key === "player"
      ? Math.max(0, Math.round(Number(state.treasury) || STARTING_TREASURY))
      : STARTING_TREASURY;
    state.treasuryByOwner[key] = fallback;
  }
  return Math.max(0, Math.round(Number(state.treasuryByOwner[key]) || 0));
}

function setOwnerTreasury(owner, amount) {
  ensureTreasuryLedger();
  const key = owner && (owner === "player" || AI_OWNERS.includes(owner)) ? owner : "player";
  const next = Math.max(0, Math.round(Number(amount) || 0));
  state.treasuryByOwner[key] = next;
  if (key === localHumanOwner()) {
    state.treasury = next;
  }
}

function syncDisplayedTreasury() {
  state.treasury = getOwnerTreasury(localHumanOwner());
}

function canIssueOrders() {
  return isLocalTurnOwner() &&
    !state.gameOver &&
    !state.animating &&
    !state.setupOpen &&
    !isNetworkInputLocked();
}

function canSpendTreasuryNow() {
  return canIssueOrders() && state.phase === "reinforce" && state.seasonIndex === 0;
}

function currentTurnActionInstruction() {
  if (state.phase === "reinforce") {
    if (state.reinforcementsLeft > 0) {
      return `Deploy ${state.reinforcementsLeft} reinforcements, then begin offensive.`;
    }
    return "Begin offensive, then issue attacks or transfers.";
  }
  if (state.phase === "attack") {
    if (!state.selection.from) {
      return "Select one of your territories with armies or ships to begin.";
    }
    if (!state.selection.to) {
      return "Select a target territory, then resolve battle or transfer.";
    }
    return "Resolve your selected order, then end turn when done.";
  }
  return "Issue your orders and end your turn.";
}

function spendTreasury(amount) {
  const owner = localHumanOwner();
  const current = getOwnerTreasury(owner);
  if (current < amount) return false;
  setOwnerTreasury(owner, current - amount);
  return true;
}

function buyArmiesBundle() {
  if (!canIssueOrders()) return;
  if (!canSpendTreasuryNow()) {
    addLog("Treasury spending is locked. You can only spend during Spring reinforcement.");
    playSound("invalid");
    render();
    return;
  }
  const deployTo = capitalPurchaseTerritory();
  if (!deployTo) {
    const capitalLabel = territoryLabel(ownerCapitalTerritory(localHumanOwner()) || state.homeBase, "your capital");
    addLog(`${capitalLabel} is not under your control. Recapture your capital to buy armies.`);
    playSound("invalid");
    render();
    return;
  }
  if (!spendTreasury(ECONOMY.armiesCost)) {
    addLog("Insufficient treasury to buy armies.");
    playSound("invalid");
    render();
    return;
  }
  state.territories[deployTo].armies += ECONOMY.armiesBundle;
  addLog(`Purchased ${ECONOMY.armiesBundle} armies and deployed to ${territoryLabel(deployTo)}.`);
  playSound("land-move");
  render();
}

function buyShipsBundle() {
  if (!canIssueOrders()) return;
  if (!canSpendTreasuryNow()) {
    addLog("Treasury spending is locked. You can only spend during Spring reinforcement.");
    playSound("invalid");
    render();
    return;
  }
  const deployTo = capitalPurchaseTerritory();
  if (!deployTo) {
    const capitalLabel = territoryLabel(ownerCapitalTerritory(localHumanOwner()) || state.homeBase, "your capital");
    addLog(`${capitalLabel} is not under your control. Recapture your capital to buy ships.`);
    playSound("invalid");
    render();
    return;
  }
  if (!spendTreasury(ECONOMY.shipsCost)) {
    addLog("Insufficient treasury to buy ships.");
    playSound("invalid");
    render();
    return;
  }
  state.ships += ECONOMY.shipsBundle;
  setPlayerShipsAt(deployTo, playerShipsAt(deployTo) + ECONOMY.shipsBundle);
  addLog(
    `Purchased ${ECONOMY.shipsBundle} ships for ${territoryLabel(deployTo)}. Fleet now at ${state.ships}.`
  );
  playSound("ship-move");
  render();
}

function fortifyTerritory() {
  if (!canIssueOrders()) return;
  if (!canSpendTreasuryNow()) {
    addLog("Fortify is locked. You can fortify only during Spring reinforcement.");
    playSound("invalid");
    render();
    return;
  }
  const target = defaultPurchaseTerritory();
  if (!target) {
    addLog("No friendly territory available to fortify.");
    playSound("invalid");
    render();
    return;
  }
  const territory = state.territories[target];
  if (territory.fortified > 0) {
    addLog(`${territoryLabel(target)} is already fortified.`);
    playSound("invalid");
    render();
    return;
  }
  if (!spendTreasury(ECONOMY.fortifyCost)) {
    addLog("Insufficient treasury to fortify territory.");
    playSound("invalid");
    render();
    return;
  }
  territory.fortified = 1;
  addLog(`${territoryLabel(target)} fortified for the next defense.`);
  playSound("select");
  render();
}

function setForceControls(sliderEl, valueEl, hintEl, config) {
  if (!sliderEl || !valueEl || !hintEl) return;
  sliderEl.min = String(config.min);
  sliderEl.max = String(config.max);
  sliderEl.value = String(config.value);
  sliderEl.disabled = Boolean(config.disabled);
  valueEl.textContent = `${config.value} / ${config.max}`;
  hintEl.textContent = config.hint;
}

function maxShipForceFor(fromName = state.selection.from, toName = state.selection.to) {
  if (!canUseShipsOnRoute(fromName, toName)) return 0;
  return Math.max(0, Math.min(playerShipsAt(fromName), state.ships));
}

function navalTroopCapacityForShips(shipCount) {
  const ships = Math.max(0, Math.floor(Number(shipCount) || 0));
  return Math.max(0, Math.floor(ships * WATER_TRANSPORT_TROOPS_PER_SHIP));
}

function requiredShipsForNavalTroops(troopCount) {
  const troops = Math.max(0, Math.floor(Number(troopCount) || 0));
  if (troops < 1) return 0;
  return Math.ceil(troops / WATER_TRANSPORT_TROOPS_PER_SHIP);
}

function runBattleSimulation(attackingArmies, defendingArmies, committedShips = 0, fortified = false) {
  let attackerPool = Math.max(1, attackingArmies);
  let defenderPool = Math.max(1, defendingArmies);
  let attackerLosses = 0;
  let defenderLosses = 0;
  let fortificationActive = Boolean(fortified);
  const shipBonus = committedShips > 0 ? Math.min(4, 1 + Math.floor(committedShips / 2)) : 0;

  while (attackerPool > 0 && defenderPool > 0) {
    const attackDice = Math.min(3, attackerPool);
    const defendDice = Math.min(2 + (fortificationActive ? 1 : 0), defenderPool, 3);
    const aRoll = rollDice(attackDice).map((roll) => roll + shipBonus);
    const dRoll = rollDice(defendDice);
    const pairs = Math.min(aRoll.length, dRoll.length);
    for (let i = 0; i < pairs; i += 1) {
      if (aRoll[i] > dRoll[i]) {
        defenderPool -= 1;
        defenderLosses += 1;
      } else {
        attackerPool -= 1;
        attackerLosses += 1;
      }
      if (attackerPool < 1 || defenderPool < 1) break;
    }
    fortificationActive = false;
  }

  return {
    attackerRemaining: Math.max(0, attackerPool),
    defenderRemaining: Math.max(0, defenderPool),
    attackerLosses,
    defenderLosses
  };
}

function estimateAttackSuccessProbability(fromName, toName, armies, ships) {
  if (!fromName || !toName) return null;
  const attacker = state.territories[fromName];
  const defender = state.territories[toName];
  if (!attacker || !defender) return null;

  const commit = Math.max(1, Math.min(armies, Math.max(1, attacker.armies - 1)));
  const maxShipsOnRoute = maxShipForceFor(fromName, toName);
  const shipCommit = Math.max(0, Math.min(ships, maxShipsOnRoute));
  const cacheKey = [
    fromName,
    toName,
    attacker.armies,
    defender.armies,
    defender.fortified,
    commit,
    shipCommit
  ].join("|");
  if (attackOddsCacheKey === cacheKey && attackOddsCacheValue != null) {
    return attackOddsCacheValue;
  }

  const trials = 120;
  let captures = 0;
  for (let i = 0; i < trials; i += 1) {
    const sim = runBattleSimulation(commit, defender.armies, shipCommit, defender.fortified > 0);
    if (sim.defenderRemaining <= 0) captures += 1;
  }
  const probability = clampNumber(captures / trials, 0.03, 0.99);
  attackOddsCacheKey = cacheKey;
  attackOddsCacheValue = probability;
  return probability;
}

function updateAttackSuccessLabels() {
  const fromName = state.selection.from;
  const toName = state.selection.to;
  const target = toName ? state.territories[toName] : null;
  if (fromName && toName && target?.owner === localHumanOwner()) {
    const navalRoute = canUseShipsOnRoute(fromName, toName);
    const adjacent = isLandRouteAvailable(fromName, toName);
    const mountainBlocked = isMountainBlockedRoute(fromName, toName);
    const waterOnlyRoute = !adjacent && navalRoute;
    const moveArmies = clampNumber(state.attackForce, 0, maxTransferArmiesFor(fromName));
    const moveShips = clampNumber(state.attackShips, 0, maxShipForceFor(fromName, toName));
    const requiredShips = waterOnlyRoute ? requiredShipsForNavalTroops(moveArmies) : 0;
    const text = (
      !adjacent && !navalRoute
        ? (
          mountainBlocked
            ? "Mountain range blocks this route. Pick another target."
            : "No valid route between these regions."
        )
        : (!adjacent && navalRoute && moveShips < 1)
          ? (
            mountainBlocked
              ? "Mountains block land travel. Set ship force for coastal transfer."
              : "Set ship force to move across open water."
          )
          : (waterOnlyRoute && moveArmies > 0 && moveShips < requiredShips)
            ? `Need ${requiredShips} ships to move ${moveArmies} armies across water (35 troops per 5 ships).`
          : navalRoute
            ? `Transfer order: ${moveArmies} armies, ${moveShips} ships.`
            : `Transfer order: ${moveArmies} armies. Ships unavailable on land route.`
    );
    if (attackSuccessLabel) attackSuccessLabel.textContent = text;
    if (mobileAttackSuccessLabel) mobileAttackSuccessLabel.textContent = text;
    return;
  }

  const prob = estimateAttackSuccessProbability(
    fromName,
    toName,
    state.attackForce,
    state.attackShips
  );
  const text = prob == null ? "Success chance: select target" : `Success chance: ${Math.round(prob * 100)}%`;
  if (attackSuccessLabel) attackSuccessLabel.textContent = text;
  if (mobileAttackSuccessLabel) mobileAttackSuccessLabel.textContent = text;
}

function updateAttackForceUI() {
  const canConfigure =
    isLocalTurnOwner() &&
    state.phase === "attack" &&
    !!state.selection.from &&
    !state.gameOver;
  const showForcePanel =
    isLocalTurnOwner() &&
    state.phase === "attack" &&
    Boolean(state.selection.from) &&
    Boolean(state.selection.to) &&
    !state.gameOver;

  if (attackForcePanel) {
    attackForcePanel.classList.toggle("hidden", !showForcePanel);
  }

  if (!canConfigure) {
    state.attackForce = 0;
    state.attackShips = 0;
    const baseConfig = {
      min: 0,
      max: 1,
      value: 0,
      disabled: true,
      hint: "Select your territory to set movement/attack force."
    };
    setForceControls(armySendSlider, armySendValue, armySendHint, baseConfig);
    setForceControls(mobileArmySendSlider, mobileArmySendValue, mobileArmySendHint, baseConfig);
    const shipConfig = {
      min: 0,
      max: 0,
      value: 0,
      disabled: true,
      hint: "Ships amplify your strike power."
    };
    setForceControls(shipSendSlider, shipSendValue, shipSendHint, shipConfig);
    setForceControls(mobileShipSendSlider, mobileShipSendValue, mobileShipSendHint, shipConfig);
    updateAttackSuccessLabels();
    if (mobileResolveBtn) mobileResolveBtn.disabled = true;
    return;
  }

  const toTerritory = state.selection.to ? state.territories[state.selection.to] : null;
  const isFriendlyTransfer = Boolean(toTerritory && toTerritory.owner === localHumanOwner());
  const transferCapacity = maxTransferArmiesFor(state.selection.from);
  const fromHasOnlyShips =
    !state.selection.to &&
    transferCapacity === 0 &&
    playerShipsAt(state.selection.from) > 0;
  const maxForce = (isFriendlyTransfer || fromHasOnlyShips)
    ? transferCapacity
    : maxAttackForceFor(state.selection.from);
  const minForce = (isFriendlyTransfer || fromHasOnlyShips) ? 0 : 1;
  const hasLandRoute = isLandRouteAvailable(state.selection.from, state.selection.to);
  const mountainBlocked = isMountainBlockedRoute(state.selection.from, state.selection.to);
  const routeSupportsShips = canUseShipsOnRoute(state.selection.from, state.selection.to);
  const waterOnlyRoute = !hasLandRoute && routeSupportsShips;
  const maxShipForce = maxShipForceFor(state.selection.from, state.selection.to);
  const navalTroopCapacity = waterOnlyRoute ? navalTroopCapacityForShips(maxShipForce) : maxForce;
  const cappedMaxForce = waterOnlyRoute ? Math.min(maxForce, navalTroopCapacity) : maxForce;
  const noNavalCapacity = waterOnlyRoute && cappedMaxForce < minForce;
  const clampedMaxForce = Math.max(minForce, cappedMaxForce);
  state.attackForce = Math.max(minForce, Math.min(state.attackForce, clampedMaxForce));
  const requiredShipsForForce = waterOnlyRoute ? requiredShipsForNavalTroops(state.attackForce) : 0;
  const minimumShipsForSelection = waterOnlyRoute ? requiredShipsForForce : 0;
  state.attackShips = Math.max(
    0,
    Math.min(maxShipForce, Math.max(state.attackShips, minimumShipsForSelection))
  );
  const fromLabel = territoryLabel(state.selection.from);
  const toLabel = state.selection.to ? territoryLabel(state.selection.to) : "";
  const hint = !state.selection.to
    ? `From ${fromLabel}, tap your region to transfer or enemy region to attack.`
    : isFriendlyTransfer
      ? waterOnlyRoute
        ? `Transfer selected: ${fromLabel} -> ${toLabel}. Sea lift capacity ${navalTroopCapacity} armies (${WATER_TRANSPORT_TROOPS_PER_BATCH} per ${WATER_TRANSPORT_SHIP_BATCH} ships).`
        : `Transfer selected: ${fromLabel} -> ${toLabel}.`
      : waterOnlyRoute
        ? `Attack selected: ${fromLabel} -> ${toLabel}. Sea lift capacity ${navalTroopCapacity} armies (${WATER_TRANSPORT_TROOPS_PER_BATCH} per ${WATER_TRANSPORT_SHIP_BATCH} ships).`
        : `Attack selected: ${fromLabel} -> ${toLabel}.`;
  const config = {
    min: minForce,
    max: clampedMaxForce,
    value: state.attackForce,
    disabled: state.animating || noNavalCapacity || (isFriendlyTransfer && clampedMaxForce < 1 && maxShipForce < 1),
    hint
  };
  setForceControls(armySendSlider, armySendValue, armySendHint, config);
  setForceControls(mobileArmySendSlider, mobileArmySendValue, mobileArmySendHint, config);
  const shipConfig = {
    min: 0,
    max: maxShipForce,
    value: state.attackShips,
    disabled: state.animating || maxShipForce < 1,
    hint: !state.selection.to
      ? `Select a target from ${fromLabel} to set ship movement.`
      : (!hasLandRoute && !routeSupportsShips)
        ? (
          mountainBlocked
            ? "Mountain range blocks this route. Choose another border."
            : "No valid route to this target."
        )
      : routeSupportsShips
        ? (
          maxShipForce > 0
            ? waterOnlyRoute
              ? `${maxShipForce} ships available. Need ${requiredShipsForForce} ships for ${state.attackForce} armies (35 troops per 5 ships).`
              : `${maxShipForce} docked ships available for this coastal route.`
            : `Coastal route detected, but ${fromLabel} has no docked ships.`
        )
        : "Land route only. Ships cannot move or attack here."
  };
  setForceControls(shipSendSlider, shipSendValue, shipSendHint, shipConfig);
  setForceControls(mobileShipSendSlider, mobileShipSendValue, mobileShipSendHint, shipConfig);
  updateAttackSuccessLabels();
  if (mobileResolveBtn) mobileResolveBtn.disabled = !canResolveSelectedOrder() || state.animating;
}

function canResolveSelectedOrder() {
  if (
    !isLocalTurnOwner() ||
    state.phase !== "attack" ||
    !state.selection.from ||
    !state.selection.to
  ) {
    return false;
  }
  const from = state.territories[state.selection.from];
  const to = state.territories[state.selection.to];
  if (!from || !to) return false;
  const adjacent = isLandRouteAvailable(state.selection.from, state.selection.to);
  const navalRange = canUseShipsOnRoute(state.selection.from, state.selection.to);
  const waterOnlyRoute = !adjacent && navalRange;
  const ships = clampNumber(state.attackShips, 0, maxShipForceFor(state.selection.from, state.selection.to));

  if (to.owner !== localHumanOwner()) {
    if (!adjacent && !navalRange) return false;
    if (from.armies < 2) return false;
    const committedArmies = clampNumber(state.attackForce, 1, maxAttackForceFor(state.selection.from));
    const requiredShips = waterOnlyRoute ? requiredShipsForNavalTroops(committedArmies) : 0;
    if (waterOnlyRoute && ships < requiredShips) return false;
    return true;
  }

  if (!adjacent && !navalRange) return false;
  const armies = clampNumber(state.attackForce, 0, maxTransferArmiesFor(state.selection.from));
  const requiredShips = waterOnlyRoute ? requiredShipsForNavalTroops(armies) : 0;
  if (waterOnlyRoute && armies > 0 && ships < requiredShips) return false;
  if (!adjacent && ships < 1 && armies < 1) return false;
  return armies > 0 || ships > 0;
}

function currentActionStep() {
  if (state.setupOpen || state.gameOver || state.animating || !isLocalTurnOwner() || isNetworkInputLocked()) return "idle";
  if (state.phase === "reinforce") {
    return state.reinforcementsLeft > 0 ? "map-reinforce" : "begin-offensive";
  }
  if (state.phase === "attack") {
    if (!state.selection.from) return "pick-source";
    if (!state.selection.to) return "pick-target";
    return "resolve-battle";
  }
  return "idle";
}

function updateActionGuidance() {
  const step = currentActionStep();
  startAttackBtn.classList.remove("attention");
  attackBtn.classList.remove("attention");
  if (mobileResolveBtn) mobileResolveBtn.classList.remove("attention");
  ribbonText.classList.remove("urgent");
  worldMapEl.classList.remove("action-map");

  if (step !== "idle") ribbonText.classList.add("urgent");
  if (step === "map-reinforce" || step === "pick-source" || step === "pick-target") {
    worldMapEl.classList.add("action-map");
  }
  if (step === "begin-offensive" && !startAttackBtn.disabled) {
    startAttackBtn.classList.add("attention");
  }
  if (step === "resolve-battle") {
    if (!attackBtn.disabled) attackBtn.classList.add("attention");
    if (mobileResolveBtn && !mobileResolveBtn.disabled) mobileResolveBtn.classList.add("attention");
  }
}

function updateMobileForcePopup() {
  if (!mobileForcePopupEl || !mapStageEl) return;
  const popupEligible =
    isMobileLikeUI() &&
    isLocalTurnOwner() &&
    state.phase === "attack" &&
    Boolean(state.selection.from) &&
    Boolean(state.selection.to) &&
    !state.gameOver;
  if (!popupEligible) {
    state.forceMenuHidden = false;
  }
  const showPopup = popupEligible && !state.forceMenuHidden;

  mobileForcePopupEl.classList.toggle("visible", showPopup);
  mapStageEl.classList.toggle("force-popup-active", showPopup);
  if (mobileForceOpenBtn) {
    mobileForceOpenBtn.classList.toggle("visible", popupEligible && state.forceMenuHidden);
    mobileForceOpenBtn.disabled = !(popupEligible && state.forceMenuHidden);
  }

  if (showPopup && ordersPanel && closePanelBtn) {
    ordersPanel.classList.add("collapsed");
    closePanelBtn.textContent = ">";
  }
}

function updateEconomyUI() {
  const activeTerritoryName = defaultPurchaseTerritory();
  const activeTerritoryLabel = activeTerritoryName ? territoryLabel(activeTerritoryName) : "a friendly territory";
  const activeTerritory = activeTerritoryName ? state.territories[activeTerritoryName] : null;
  const capitalTerritoryName = capitalPurchaseTerritory();
  const ownerTreasury = getOwnerTreasury(localHumanOwner());
  const capitalLabel = territoryLabel(state.homeBase, "your capital");
  const canBuyNow = canSpendTreasuryNow();
  const nextSpendYear = state.year + 1;
  const spendingWindowNote = canBuyNow
    ? "Spring budget window open."
    : `Budget locked until Spring ${nextSpendYear}.`;

  if (buyArmiesInfo) {
    if (capitalTerritoryName) {
      const capitalTargetLabel = territoryLabel(capitalTerritoryName);
      buyArmiesInfo.textContent = `${ECONOMY.armiesBundle} armies cost $${ECONOMY.armiesCost}. Deploys to ${capitalTargetLabel} (capital). ${spendingWindowNote}`;
    } else {
      buyArmiesInfo.textContent = `${ECONOMY.armiesBundle} armies cost $${ECONOMY.armiesCost}. Capital ${capitalLabel} is occupied. Recapture it to purchase armies. ${spendingWindowNote}`;
    }
  }
  if (buyShipsInfo) {
    if (capitalTerritoryName) {
      const docked = playerShipsAt(capitalTerritoryName);
      const capitalTargetLabel = territoryLabel(capitalTerritoryName);
      buyShipsInfo.textContent = `${ECONOMY.shipsBundle} ships cost $${ECONOMY.shipsCost}. Fleet: ${state.ships}. Docked at ${capitalTargetLabel}: ${docked}. ${spendingWindowNote}`;
    } else {
      buyShipsInfo.textContent = `${ECONOMY.shipsBundle} ships cost $${ECONOMY.shipsCost}. Fleet: ${state.ships}. Capital ${capitalLabel} is occupied. Recapture it to purchase ships. ${spendingWindowNote}`;
    }
  }
  if (fortifyInfo) {
    if (!activeTerritory) {
      fortifyInfo.textContent = "No friendly territory selected to fortify.";
    } else if (activeTerritory.fortified > 0) {
      fortifyInfo.textContent = `${activeTerritoryLabel} already fortified.`;
    } else {
      fortifyInfo.textContent = `Fortify ${activeTerritoryLabel}. Defends with +1 die once.`;
    }
  }

  const canBuyArmies = canBuyNow && Boolean(capitalTerritoryName) && ownerTreasury >= ECONOMY.armiesCost;
  const canBuyShips = canBuyNow && Boolean(capitalTerritoryName) && ownerTreasury >= ECONOMY.shipsCost;
  const canFortify =
    canBuyNow &&
    Boolean(activeTerritory) &&
    activeTerritory.fortified < 1 &&
    ownerTreasury >= ECONOMY.fortifyCost;
  const canAnyEconomyAction = canBuyArmies || canBuyShips || canFortify;
  const canOpenEconomyPanel = canIssueOrders() && canBuyNow && canAnyEconomyAction;

  if (buyArmiesBtn) buyArmiesBtn.disabled = !canBuyArmies;
  if (buyShipsBtn) buyShipsBtn.disabled = !canBuyShips;
  if (fortifyBtn) fortifyBtn.disabled = !canFortify;
  if (mobileBuyArmiesBtn) mobileBuyArmiesBtn.disabled = !canBuyArmies;
  if (mobileBuyShipsBtn) mobileBuyShipsBtn.disabled = !canBuyShips;
  if (mobileFortifyBtn) mobileFortifyBtn.disabled = !canFortify;

  if (!canOpenEconomyPanel) {
    state.economyPanelOpen = false;
  }

  if (economyToggleCard) economyToggleCard.style.display = canOpenEconomyPanel ? "grid" : "none";
  if (economyToggleBtn) {
    economyToggleBtn.textContent = state.economyPanelOpen ? "Hide Economy Actions" : "Open Economy Actions";
    economyToggleBtn.disabled = !canOpenEconomyPanel;
  }
  if (economyToggleNote) {
    economyToggleNote.textContent = canOpenEconomyPanel
      ? "Spring spending window is open. Use this to buy armies, ships, or fortify."
      : "Economy actions are hidden until they are available.";
  }
  if (economyActionsPanel) {
    economyActionsPanel.classList.toggle("visible", canOpenEconomyPanel && state.economyPanelOpen);
  }
  if (opsArmiesCard) opsArmiesCard.classList.toggle("economy-option-hidden", !(canOpenEconomyPanel && canBuyArmies));
  if (opsShipsCard) opsShipsCard.classList.toggle("economy-option-hidden", !(canOpenEconomyPanel && canBuyShips));
  if (opsFortifyCard) opsFortifyCard.classList.toggle("economy-option-hidden", !(canOpenEconomyPanel && canFortify));

  if (mobileShopBarEl) {
    const showShop = isMobileLikeUI() && canOpenEconomyPanel;
    mobileShopBarEl.style.visibility = showShop ? "visible" : "hidden";
    mobileShopBarEl.style.opacity = showShop ? "1" : "0";
    mobileShopBarEl.style.pointerEvents = showShop ? "auto" : "none";
    if (mobileBuyArmiesBtn) mobileBuyArmiesBtn.style.display = showShop && canBuyArmies ? "" : "none";
    if (mobileBuyShipsBtn) mobileBuyShipsBtn.style.display = showShop && canBuyShips ? "" : "none";
    if (mobileFortifyBtn) mobileFortifyBtn.style.display = showShop && canFortify ? "" : "none";
    const visibleButtons = [mobileBuyArmiesBtn, mobileBuyShipsBtn, mobileFortifyBtn]
      .filter((entry) => entry && entry.style.display !== "none")
      .length;
    if (showShop && visibleButtons > 0) {
      mobileShopBarEl.style.gridTemplateColumns = `repeat(${visibleButtons}, minmax(0, 1fr))`;
    } else {
      mobileShopBarEl.style.gridTemplateColumns = "repeat(3, minmax(0, 1fr))";
    }
  }
}

function updateMobileNextStepBar() {
  if (!mobileNextStepEl || !mobileNextText || !mobileNextBtn) return;
  if (!isMobileLikeUI()) {
    mobileNextStepEl.style.display = "none";
    return;
  }
  mobileNextStepEl.style.display = "grid";

  if (state.setupOpen) {
    mobileNextText.textContent = "Choose your starting country to begin.";
    mobileNextBtn.dataset.action = "";
    mobileNextBtn.classList.add("hidden");
    if (mobileEndBtn) {
      mobileEndBtn.disabled = true;
      mobileEndBtn.textContent = "End Turn";
    }
    return;
  }

  const step = currentActionStep();
  let text = statusMessage();
  let action = "";
  let buttonLabel = "";

  if (isAIOwner(state.turn)) {
    text = "Rival is taking its turn. Hold position.";
  } else if (step === "begin-offensive") {
    text = "Next: Start your offensive.";
    action = "begin-offensive";
    buttonLabel = "Begin Offensive";
  } else if (step === "resolve-battle") {
    const isFriendlyTransfer = state.selection.to && state.territories[state.selection.to]?.owner === localHumanOwner();
    if (isFriendlyTransfer) {
      text = `Next: Move ${state.attackForce} armies and ${state.attackShips} ships to your territory.`;
      buttonLabel = "Move Forces";
    } else {
      text = `Next: Resolve battle with ${state.attackForce} armies and ${state.attackShips} ships.`;
      buttonLabel = "Resolve Battle";
    }
    action = "resolve-battle";
  } else if (step === "map-reinforce") {
    text = `Next: Deploy ${state.reinforcementsLeft} reinforcements on your territories.`;
    action = "focus-home";
    buttonLabel = "Center Home Base";
  } else if (step === "pick-source") {
    text = "Next: Tap a friendly territory with armies or docked ships.";
    action = "focus-home";
    buttonLabel = "Center Home Base";
  } else if (step === "pick-target") {
    text = "Next: Tap your region to transfer or an enemy region to attack. Coastal ships can travel farther.";
    action = "focus-home";
    buttonLabel = "Center Source";
  }

  mobileNextText.textContent = text;
  mobileNextBtn.dataset.action = action;
  if (action) {
    mobileNextBtn.textContent = buttonLabel;
    mobileNextBtn.classList.remove("hidden");
    mobileNextBtn.disabled = action === "resolve-battle" ? !canResolveSelectedOrder() : false;
  } else {
    mobileNextBtn.classList.add("hidden");
  }

  if (mobileEndBtn) {
    const canEnd = isLocalTurnOwner() && !state.gameOver && !state.animating && !isNetworkInputLocked();
    mobileEndBtn.disabled = !canEnd;
    mobileEndBtn.textContent = "End Turn";
  }
}

function addLog(message) {
  if (!logEl) return;
  const li = document.createElement("li");
  li.textContent = message;
  logEl.prepend(li);
}

function ownerName(owner) {
  if (isNetworkMode() && isNetworkHumanOwner(owner)) {
    const networkPlayer = networkPlayerForOwner(owner);
    if (networkPlayer?.name) return networkPlayer.name;
  }
  if (owner === "player") return "Player";
  if (owner === "ai1") return "AI Crimson";
  if (owner === "ai2") return "AI Emerald";
  if (owner === "ai3") return "AI Amber";
  if (owner === "ai4") return "AI Azure";
  if (owner === "ai5") return "AI Teal";
  if (owner === "ai6") return "AI Violet";
  if (owner === "ai") return "AI";
  return "Unclaimed";
}

function territoryCount(owner) {
  return Object.values(state.territories).filter((t) => t.owner === owner).length;
}

function claimedArea(owner) {
  return Object.entries(state.territories).reduce((sum, [name, territory]) => {
    if (territory.owner !== owner) return sum;
    return sum + (TERRITORY_AREAS[name] || 1);
  }, 0);
}

function territoryValue(name) {
  if (!name || !TERRITORY_AREAS[name]) return 0;
  const share = TERRITORY_AREAS[name] / TOTAL_MAP_AREA;
  return Math.round(share * ECONOMY.annualIncomeScale);
}

function annualIncomeFor(owner) {
  const areaShare = claimedArea(owner) / TOTAL_MAP_AREA;
  return Math.max(
    ECONOMY.annualIncomeFloor,
    Math.round(areaShare * ECONOMY.annualIncomeScale)
  );
}

function updateControlBar() {
  const names = Object.keys(state.territories);
  const totalArea = names.reduce((sum, name) => sum + (TERRITORY_AREAS[name] || 1), 0) || 1;
  const ownerArea = names.reduce((acc, name) => {
    const owner = state.territories[name].owner;
    const area = TERRITORY_AREAS[name] || 1;
    acc[owner] = (acc[owner] || 0) + area;
    return acc;
  }, {});

  const playerPct = Math.max(0, Math.min(100, ((ownerArea.player || 0) / totalArea) * 100));
  const aiPctByOwner = AI_OWNERS.reduce((acc, owner) => {
    acc[owner] = Math.max(0, Math.min(100, ((ownerArea[owner] || 0) / totalArea) * 100));
    return acc;
  }, {});
  const aiPct = AI_OWNERS.reduce((sum, owner) => sum + (aiPctByOwner[owner] || 0), 0);
  const neutralPct = Math.max(0, Math.min(100, ((ownerArea.neutral || 0) / totalArea) * 100));

  if (powerPlayerEl) powerPlayerEl.style.width = `${playerPct}%`;
  AI_OWNERS.forEach((owner) => {
    const bar = powerAiEls[owner];
    if (!bar) return;
    bar.style.width = `${aiPctByOwner[owner] || 0}%`;
  });
  if (powerAiCoalitionEl) powerAiCoalitionEl.style.width = `${aiPct}%`;
  if (powerNeutralEl) powerNeutralEl.style.width = `${neutralPct}%`;
  if (powerPlayerLabelEl) powerPlayerLabelEl.textContent = `Player ${Math.round(playerPct)}%`;
  if (powerAiLabelEl) powerAiLabelEl.textContent = `AI Total ${Math.round(aiPct)}%`;
  if (powerNeutralLabelEl) powerNeutralLabelEl.textContent = `Unclaimed ${Math.round(neutralPct)}%`;
}

function reinforcementFor(owner) {
  const base = Math.max(3, Math.floor(territoryCount(owner) / 3));
  const difficultyBonus = setupDifficultyForOwner(owner);
  return Math.max(2, base + difficultyBonus);
}

function rollDice(count) {
  const rolls = [];
  for (let i = 0; i < count; i += 1) rolls.push(1 + Math.floor(Math.random() * 6));
  return rolls.sort((a, b) => b - a);
}

function checkGameOver() {
  const humanOwners = isNetworkMode()
    ? Array.from(new Set(Object.values(state.multiplayer.network.ownerByPlayerId || {}))).filter(Boolean)
    : ["player"];
  const aliveHumanOwners = humanOwners.filter((owner) => territoryCount(owner) > 0);
  const aiOpponents = AI_OWNERS.filter((owner) => !humanOwners.includes(owner));
  const aiOwns = aiOpponents.reduce((sum, owner) => sum + territoryCount(owner), 0);
  const noAiOpponents = !state.multiplayer.network.aiEnabled && isNetworkMode();

  if ((noAiOpponents && aliveHumanOwners.length <= 1) || (!noAiOpponents && (aliveHumanOwners.length < 1 || aiOwns === 0))) {
    state.gameOver = true;
    const winner = noAiOpponents
      ? (aliveHumanOwners[0] ? ownerName(aliveHumanOwners[0]) : "No one")
      : (aliveHumanOwners.length > 0 ? "Players" : "AI Coalition");
    addLog(`${winner} eliminated the rival empire. Game over.`);
  }
}

function applyAnnualIncomeIfNeeded() {
  if (state.seasonIndex !== 0) return;
  if (state.year <= state.lastIncomeYear) return;

  const owners = ["player", ...AI_OWNERS];
  owners.forEach((owner) => {
    if (territoryCount(owner) > 0) {
      const income = annualIncomeFor(owner);
      const current = getOwnerTreasury(owner);
      setOwnerTreasury(owner, current + income);

      if (owner === localHumanOwner()) {
        const areaShare = (claimedArea(owner) / TOTAL_MAP_AREA) * 100;
        addLog(`Year ${state.year} revenue: +$${income} from ${Math.round(areaShare)}% land control.`);
      }
    }
  });

  syncDisplayedTreasury();
  state.lastIncomeYear = state.year;
}

function autoDeployPlayerReinforcementsIfNeeded() {
  if (
    !isLocalTurnOwner() ||
    state.phase !== "reinforce" ||
    state.reinforcementsLeft < 1
  ) {
    return false;
  }
  const owner = localHumanOwner();
  const playerOwned = Object.keys(state.territories).filter(
    (name) => state.territories[name].owner === owner
  );
  if (!playerOwned.length) return false;
  if (!state.firstRound && playerOwned.length > 1) return false;

  let target = playerOwned[0];
  if (
    state.homeBase &&
    state.territories[state.homeBase]?.owner === owner &&
    (state.firstRound || playerOwned.length === 1)
  ) {
    target = state.homeBase;
  }

  const deploy = state.reinforcementsLeft;
  state.territories[target].armies += deploy;
  state.reinforcementsLeft = 0;
  const targetLabel = territoryLabel(target);
  if (state.firstRound) {
    addLog(`Opening reinforcements auto-deployed: +${deploy} armies to ${targetLabel}.`);
  } else {
    addLog(`Single territory control: +${deploy} reinforcements auto-deployed to ${targetLabel}.`);
  }
  state.firstRound = false;
  playSound("land-move");
  return true;
}

function advanceCalendar() {
  state.seasonIndex += 1;
  if (state.seasonIndex > 3) {
    state.seasonIndex = 0;
    state.year += 1;
  }
}

function select(territoryName) {
  state.viewedTerritory = territoryName;
  render();

  if (state.setupOpen || !isLocalTurnOwner() || state.gameOver || state.animating || isNetworkInputLocked()) return;
  if (state.phase === "reinforce") {
    reinforce(territoryName);
    return;
  }
  if (state.phase !== "attack") return;

  const owner = localHumanOwner();
  const selected = state.territories[territoryName];
  const fromName = state.selection.from;
  const fromTerritory = fromName ? state.territories[fromName] : null;
  const selectedHasMovableForces =
    selected.owner === owner &&
    (selected.armies > 1 || playerShipsAt(territoryName) > 0);

  if (!fromName) {
    if (!selectedHasMovableForces) {
      playSound("invalid");
      render();
      return;
    }
    state.selection.from = territoryName;
    state.selection.to = null;
    state.attackForce = maxTransferArmiesFor(territoryName);
    state.attackShips = Math.min(Math.max(state.attackShips, 0), playerShipsAt(territoryName));
    state.forceMenuHidden = false;
    playSound("select");
    render();
    return;
  }

  if (territoryName === fromName) {
    if (state.selection.to) {
      state.selection.to = null;
    } else {
      state.selection.from = null;
      state.attackForce = 1;
      state.attackShips = 0;
    }
    state.forceMenuHidden = false;
    playSound("select");
    render();
    return;
  }

  const adjacent = isLandRouteAvailable(fromName, territoryName);
  const sourceShips = playerShipsAt(fromName);
  const navalRange = canUseShipsOnRoute(fromName, territoryName);
  const navalEnabled = navalRange && sourceShips > 0;
  const playerOwnedTarget = selected.owner === owner;
  const friendlyTransferAllowed = playerOwnedTarget && (adjacent || navalEnabled);
  const enemyAttackAllowed =
    !playerOwnedTarget &&
    (
      (fromTerritory?.armies || 0) > 1 &&
      (adjacent || navalEnabled)
    );

  if (friendlyTransferAllowed || enemyAttackAllowed) {
    state.selection.to = territoryName;
    state.forceMenuHidden = false;
    playSound("select");
    render();
    return;
  }

  if (selectedHasMovableForces) {
    state.selection.from = territoryName;
    state.selection.to = null;
    state.attackForce = maxTransferArmiesFor(territoryName);
    state.attackShips = Math.min(Math.max(state.attackShips, 0), playerShipsAt(territoryName));
    state.forceMenuHidden = false;
    playSound("select");
    render();
    return;
  }

  playSound("invalid");
  render();
}

function reinforce(territoryName) {
  if (state.phase !== "reinforce" || state.reinforcementsLeft < 1 || state.animating) return;
  const territory = state.territories[territoryName];
  if (!territory || territory.owner !== localHumanOwner()) return;

  territory.armies += 1;
  state.reinforcementsLeft -= 1;
  addLog(`${ownerName(localHumanOwner())} reinforces ${territoryLabel(territoryName)} (+1).`);
  playSound("land-move");
  if (state.reinforcementsLeft === 0) addLog("Reinforcements complete. Begin offensive or end turn.");
  render();
}

function resolveFriendlyTransfer(fromName, toName, committedArmies = 0, committedShips = 0) {
  const from = state.territories[fromName];
  const to = state.territories[toName];
  const owner = localHumanOwner();
  const adjacent = isLandRouteAvailable(fromName, toName);
  const navalRange = canUseShipsOnRoute(fromName, toName);
  const mountainBlocked = isMountainBlockedRoute(fromName, toName);
  if (
    !from ||
    !to ||
    from.owner !== owner ||
    to.owner !== owner ||
    fromName === toName ||
    (!adjacent && !navalRange)
  ) {
    if (mountainBlocked) {
      addLog("Mountain range blocks this land transfer.");
      showBattleOutcome("Mountain range blocks this route.", false);
    } else {
      addLog("Invalid transfer order.");
      showBattleOutcome("Invalid transfer order.", false);
    }
    playSound("invalid");
    return { valid: false };
  }

  const maxArmies = maxTransferArmiesFor(fromName);
  const maxShips = maxShipForceFor(fromName, toName);
  const armyMove = clampNumber(committedArmies, 0, maxArmies);
  const shipMove = clampNumber(committedShips, 0, maxShips);
  const waterOnlyRoute = !adjacent && navalRange;
  const requiredShips = waterOnlyRoute ? requiredShipsForNavalTroops(armyMove) : 0;

  if (waterOnlyRoute && armyMove > 0 && shipMove < requiredShips) {
    addLog(`Need ${requiredShips} ships to move ${armyMove} armies across water.`);
    showBattleOutcome(`Need ${requiredShips} ships for ${armyMove} armies across water (35 troops per 5 ships).`, false);
    playSound("invalid");
    return { valid: false };
  }

  if (waterOnlyRoute && shipMove < 1) {
    if (mountainBlocked) {
      addLog("Mountains block land transfer. Use ships on this coastal route.");
      showBattleOutcome("Mountains block land transfer. Commit ships.", false);
    } else {
      addLog("Open-water transfer requires at least 1 ship.");
      showBattleOutcome("Set ship force to move across open water.", false);
    }
    playSound("invalid");
    return { valid: false };
  }

  if (armyMove < 1 && shipMove < 1) {
    addLog("No forces selected to move.");
    showBattleOutcome("Select armies or ships to move.", false);
    playSound("invalid");
    return { valid: false };
  }

  if (armyMove > 0) {
    from.armies -= armyMove;
    to.armies += armyMove;
  }
  const movedShips = shipMove > 0 ? movePlayerShips(fromName, toName, shipMove) : 0;
  const fromLabel = territoryLabel(fromName);
  const toLabel = territoryLabel(toName);
  addLog(`Transfer: ${armyMove} armies and ${movedShips} ships from ${fromLabel} to ${toLabel}.`);
  showBattleOutcome(`Forces moved to ${toLabel}.`, true, true);

  state.selection.to = null;
  state.forceMenuHidden = false;
  render();
  return {
    valid: true,
    movedArmies: armyMove,
    movedShips
  };
}

function resolveBattle(attackerName, defenderName, committedArmies = 1, committedShips = 0) {
  const attacker = state.territories[attackerName];
  const defender = state.territories[defenderName];
  const owner = localHumanOwner();
  const adjacent = isLandRouteAvailable(attackerName, defenderName);
  const navalRange = canUseShipsOnRoute(attackerName, defenderName);
  const mountainBlocked = isMountainBlockedRoute(attackerName, defenderName);
  if (
    attacker.owner !== owner ||
    defender.owner === owner ||
    attacker.armies < 2 ||
    (!adjacent && !navalRange)
  ) {
    if (mountainBlocked) {
      addLog("Mountain range blocks this attack route.");
      showBattleOutcome("Mountains block this land attack.", false);
    } else {
      addLog("Invalid attack order.");
      showBattleOutcome("Invalid attack order.", false);
    }
    playSound("invalid");
    return { valid: false, captured: false };
  }

  const maxCommit = Math.max(1, attacker.armies - 1);
  const maxShipsCommit = maxShipForceFor(attackerName, defenderName);
  const commit = Math.max(1, Math.min(committedArmies, maxCommit));
  const shipCommit = Math.max(0, Math.min(committedShips, maxShipsCommit));
  const waterOnlyRoute = !adjacent && navalRange;
  const requiredShips = waterOnlyRoute ? requiredShipsForNavalTroops(commit) : 0;
  if (waterOnlyRoute && shipCommit < requiredShips) {
    if (mountainBlocked) {
      addLog("Mountains block this land route. Commit ships for a coastal assault.");
      showBattleOutcome("Mountains block this land route. Commit ships.", false);
    } else {
      addLog(`Naval assault requires ${requiredShips} ships for ${commit} armies.`);
      showBattleOutcome(`Need ${requiredShips} ships for ${commit} armies across water (35 troops per 5 ships).`, false);
    }
    playSound("invalid");
    return { valid: false, captured: false };
  }
  const hadFortification = defender.fortified > 0;
  const outcome = runBattleSimulation(commit, defender.armies, shipCommit, hadFortification);
  const attackerLosses = outcome.attackerLosses;
  const defenderLosses = outcome.defenderLosses;
  const attackerRemaining = outcome.attackerRemaining;
  const defenderRemaining = outcome.defenderRemaining;

  const attackerLabel = territoryLabel(attackerName);
  const defenderLabel = territoryLabel(defenderName);
  addLog(`${ownerName(owner)} attacks ${defenderLabel} from ${attackerLabel} with ${commit} armies and ${shipCommit} ships.`);
  if (hadFortification) {
    addLog(`${defenderLabel} fortifications are active (+1 defense die).`);
    defender.fortified = 0;
  }
  attacker.armies = Math.max(1, attacker.armies - attackerLosses);
  defender.armies = defenderRemaining;

  const fromShipsBefore = playerShipsAt(attackerName);
  let shipsLost = 0;
  if (shipCommit > 0 && attackerLosses > 0) {
    shipsLost = Math.min(shipCommit, Math.ceil(attackerLosses / 2));
    state.ships = Math.max(0, state.ships - shipsLost);
    if (shipsLost > 0) addLog(`${shipsLost} ships were lost in the assault.`);
  }
  if (shipCommit > 0) {
    setPlayerShipsAt(attackerName, fromShipsBefore - shipsLost);
  }

  addLog(`${attackerLabel} loses ${attackerLosses}; ${defenderLabel} loses ${defenderLosses}.`);

  let captured = false;
  if (defenderRemaining <= 0) {
    defender.owner = owner;
    defender.fortified = 0;
    const availableToMove = Math.max(1, attacker.armies - 1);
    const desiredTransfer = Math.max(1, attackerRemaining);
    const transfer = Math.min(desiredTransfer, availableToMove);
    attacker.armies -= transfer;
    defender.armies = transfer;
    addLog(`${ownerName(owner)} captured ${defenderLabel} and moved ${transfer} armies.`);
    const survivingShips = Math.max(0, shipCommit - shipsLost);
    if (survivingShips > 0) {
      const movedShips = movePlayerShips(attackerName, defenderName, survivingShips);
      if (movedShips > 0) {
        addLog(`${movedShips} ships moved into ${defenderLabel}.`);
      }
    }
    showBattleOutcome(`Success: ${defenderLabel} captured.`, true, true);
    captured = true;
    playSound("attack-success");
  } else {
    addLog(`Attack on ${defenderLabel} failed.`);
    showBattleOutcome(`Attack failed at ${defenderLabel}.`, false, true);
    playSound("attack-fail");
  }

  state.selection.to = null;
  state.forceMenuHidden = false;
  checkGameOver();
  render();
  return {
    valid: true,
    captured,
    attackerLosses,
    defenderLosses,
    committed: commit,
    shipsCommitted: shipCommit,
    shipsLost
  };
}

async function executePlayerAttack() {
  if (!state.selection.from || !state.selection.to || state.animating || !isLocalTurnOwner() || state.phase !== "attack") {
    return;
  }
  const owner = localHumanOwner();
  const from = state.selection.from;
  const to = state.selection.to;
  const toOwner = state.territories[to]?.owner;
  const force = toOwner === owner
    ? clampNumber(state.attackForce, 0, maxTransferArmiesFor(from))
    : clampNumber(state.attackForce, 1, maxAttackForceFor(from));
  const ships = Math.max(0, Math.min(state.attackShips, maxShipForceFor(from, to)));
  if (toOwner === owner && force < 1 && ships < 1) {
    addLog("Select armies or ships before moving.");
    playSound("invalid");
    render();
    return;
  }
  state.animating = true;
  showMovementCue(from, to, owner, `${force}A/${ships}S`);
  playSound(ships > 0 ? "ship-move" : "land-move");
  render();
  await sleep(420);
  const result = toOwner === owner
    ? resolveFriendlyTransfer(from, to, force, ships)
    : resolveBattle(from, to, force, ships);
  await sleep(240);
  if (result?.valid === false) {
    await sleep(120);
  } else {
    state.selection = { from: null, to: null };
    state.attackForce = 1;
    state.attackShips = 0;
  }
  if (state.outcomeAckRequired) {
    render();
    await waitForBattleOutcomeAcknowledge();
  }
  clearMovementCue();
  state.animating = false;
  render();
}

function candidateAttacks(owner) {
  return Object.entries(state.territories)
    .filter(([, t]) => t.owner === owner && t.armies > 1)
    .flatMap(([name, t]) =>
      TERRITORIES[name]
        .filter((neighbor) =>
          state.territories[neighbor].owner !== owner &&
          isLandRouteAvailable(name, neighbor)
        )
        .map((neighbor) => ({
          from: name,
          to: neighbor,
          strength: t.armies - state.territories[neighbor].armies
        }))
    )
    .sort((a, b) => b.strength - a.strength);
}

function resolveAIAttack(owner, from, to, committedArmies, committedShips, options = {}) {
  const attacker = state.territories[from];
  const defender = state.territories[to];
  const attackerLabel = territoryLabel(from);
  const defenderLabel = territoryLabel(to);
  const showOutcome = options.showOutcome !== false;
  const requireOutcomeAck = options.requireOutcomeAck === true;
  const maxCommit = Math.max(1, attacker.armies - 1);
  const commit = Math.max(1, Math.min(committedArmies, maxCommit));
  const fleet = state.aiShips[owner] || 0;
  const shipCommit = canUseShipsOnRoute(from, to) ? Math.max(0, Math.min(committedShips, fleet)) : 0;
  const hadFortification = defender.fortified > 0;
  const outcome = runBattleSimulation(commit, defender.armies, shipCommit, hadFortification);
  const attackerLosses = outcome.attackerLosses;
  const defenderLosses = outcome.defenderLosses;
  const attackerRemaining = outcome.attackerRemaining;
  const defenderRemaining = outcome.defenderRemaining;

  if (hadFortification) {
    addLog(`${defenderLabel} fortifications hold against the AI assault.`);
    defender.fortified = 0;
  }
  attacker.armies = Math.max(1, attacker.armies - attackerLosses);
  defender.armies = defenderRemaining;
  addLog(`${ownerName(owner)} loses ${attackerLosses}; defender loses ${defenderLosses}.`);

  if (shipCommit > 0) {
    const estimatedLosses = Math.min(shipCommit, Math.ceil(attackerLosses / 2));
    if (estimatedLosses > 0) {
      state.aiShips[owner] = Math.max(0, fleet - estimatedLosses);
    }
  }

  let captured = false;
  let summaryLine = `${ownerName(owner)} failed at ${defenderLabel}.`;
  if (defenderRemaining <= 0) {
    const displacedPlayerShips = isNetworkHumanOwner(defender.owner) ? playerShipsAt(to) : 0;
    defender.owner = owner;
    defender.fortified = 0;
    const availableToMove = Math.max(1, attacker.armies - 1);
    const transfer = Math.min(Math.max(1, attackerRemaining), availableToMove);
    attacker.armies -= transfer;
    defender.armies = transfer;
    if (displacedPlayerShips > 0) {
      setPlayerShipsAt(to, 0);
      state.ships = Math.max(0, state.ships - displacedPlayerShips);
      addLog(`${displacedPlayerShips} player ships were lost with ${defenderLabel}.`);
    }
    summaryLine = `${ownerName(owner)} captured ${defenderLabel}.`;
    addLog(summaryLine);
    if (showOutcome) showBattleOutcome(summaryLine, true, requireOutcomeAck);
    captured = true;
    playSound("attack-success");
  } else {
    if (showOutcome) showBattleOutcome(summaryLine, false, requireOutcomeAck);
    playSound("attack-fail");
  }
  return { captured, summaryLine };
}

async function runAITurn() {
  if (state.gameOver || state.animating) return;

  clearBattleOutcome(true);
  clearMovementCue();
  const aiAttackThreshold = setupDifficultyById(state.setupOptions.difficulty).aiAttackThreshold;
  const aiActionSummary = [];
  state.animating = true;
  checkGameOver();
  if (state.gameOver) {
    state.animating = false;
    render();
    return;
  }
  for (const aiOwner of AI_OWNERS) {
    if (state.gameOver) break;
    if (isNetworkMode() && isNetworkHumanOwner(aiOwner)) continue;
    if (territoryCount(aiOwner) < 1) continue;

    state.turn = aiOwner;
    state.phase = "reinforce";
    state.reinforcementsLeft = reinforcementFor(aiOwner);
    state.selection = { from: null, to: null };
    state.forceMenuHidden = false;
    state.economyPanelOpen = false;
    playSound("turn");
    render();
    await sleep(260);

    const aiTerritories = Object.entries(state.territories)
      .filter(([, t]) => t.owner === aiOwner)
      .map(([name]) => name);
    if (!aiTerritories.length) continue;

    const aiReinforcements = state.reinforcementsLeft;
    for (let i = 0; i < aiReinforcements; i += 1) {
      const pick = aiTerritories[Math.floor(Math.random() * aiTerritories.length)];
      state.territories[pick].armies += 1;
    }
    addLog(`${ownerName(aiOwner)} reinforces ${aiReinforcements} armies.`);
    aiActionSummary.push(`${ownerName(aiOwner)} reinforced ${aiReinforcements} armies.`);
    state.reinforcementsLeft = 0;
    state.phase = "attack";
    render();
    await sleep(300);

    for (let i = 0; i < 3; i += 1) {
      const options = candidateAttacks(aiOwner).filter((o) => o.strength >= aiAttackThreshold);
      if (!options.length) break;

      const preferred = options.slice(0, Math.min(3, options.length));
      const chosen = preferred[Math.floor(Math.random() * preferred.length)];
      const { from, to } = chosen;
      const aiForce = Math.min(6, Math.max(1, state.territories[from].armies - 1));
      const availableShips = state.aiShips[aiOwner] || 0;
      const aiShips = canUseShipsOnRoute(from, to)
        ? Math.min(availableShips, Math.max(0, Math.ceil(aiForce / 3)))
        : 0;
      addLog(`${ownerName(aiOwner)} attacks ${territoryLabel(to)} from ${territoryLabel(from)} with ${aiForce} armies and ${aiShips} ships.`);
      showMovementCue(from, to, aiOwner, `${aiForce}A/${aiShips}S`);
      playSound(aiShips > 0 ? "ship-move" : "land-move");
      render();
      await sleep(380);

      const attackResult = resolveAIAttack(aiOwner, from, to, aiForce, aiShips, {
        showOutcome: false
      });
      if (attackResult?.summaryLine) {
        aiActionSummary.push(attackResult.summaryLine);
      }
      checkGameOver();
      render();
      await sleep(220);

      clearMovementCue();
      render();
      if (state.gameOver) break;
    }
  }

  if (state.gameOver) {
    clearMovementCue();
    state.animating = false;
    render();
    return;
  }

  clearMovementCue();
  advanceCalendar();
  const nextOwner = isNetworkMode() ? firstNetworkHumanOwner() : "player";
  state.turn = nextOwner;
  state.phase = "reinforce";
  state.reinforcementsLeft = reinforcementFor(nextOwner);
  state.selection = { from: null, to: null };
  state.attackForce = 1;
  state.attackShips = 0;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  syncHomeBaseForTurnOwner();
  applyAnnualIncomeIfNeeded();
  autoDeployPlayerReinforcementsIfNeeded();
  addLog(`${ownerName(nextOwner)} turn begins. ${currentTurnActionInstruction()}`);
  playSound(nextOwner === localHumanOwner() ? "ding" : "turn");
  state.animating = false;
  render();

  if (aiActionSummary.length > 0) {
    const headline = aiActionSummary.slice(0, 5);
    const overflow = Math.max(0, aiActionSummary.length - headline.length);
    const summaryText = overflow > 0
      ? `Rival turn summary: ${headline.join(" ")} +${overflow} more actions.`
      : `Rival turn summary: ${headline.join(" ")}`;
    showBattleOutcome(summaryText, true, true);
    render();
    await waitForBattleOutcomeAcknowledge();
  }
}

function beginNextPlayerSeason(nextOwner = "player", options = {}) {
  const advanceSeason = options.advanceSeason !== false;
  clearMovementCue();
  if (advanceSeason) {
    advanceCalendar();
  }
  state.turn = nextOwner;
  state.phase = "reinforce";
  state.reinforcementsLeft = reinforcementFor(nextOwner);
  state.selection = { from: null, to: null };
  state.attackForce = 1;
  state.attackShips = 0;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  syncHomeBaseForTurnOwner();
  if (advanceSeason) {
    applyAnnualIncomeIfNeeded();
  }
  autoDeployPlayerReinforcementsIfNeeded();
  addLog(`${ownerName(nextOwner)} turn begins. ${currentTurnActionInstruction()}`);
  playSound(nextOwner === localHumanOwner() ? "ding" : "turn");
  state.animating = false;
  render();
}

function startAttackPhase() {
  if (state.setupOpen || !isLocalTurnOwner() || state.phase !== "reinforce" || state.reinforcementsLeft > 0 || state.animating || isNetworkInputLocked()) return;
  state.phase = "attack";
  state.selection = { from: null, to: null };
  state.attackShips = 0;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  addLog(`${ownerName(localHumanOwner())} offensive phase started.`);
  playSound("select");
  render();
}

function endPlayerTurn() {
  if (state.setupOpen || !isLocalTurnOwner() || state.gameOver || state.animating || isNetworkInputLocked()) return;
  void (async () => {
    if (isNetworkMode()) {
      const lastHumanTurn = isLastNetworkHumanTurn();
      if (state.multiplayer.network.aiEnabled && lastHumanTurn) {
        await runAITurn();
      } else if (!state.multiplayer.network.aiEnabled && lastHumanTurn) {
        beginNextPlayerSeason(firstNetworkHumanOwner(), { advanceSeason: true });
      } else {
        beginNextPlayerSeason(nextNetworkHumanOwner(), { advanceSeason: false });
      }
    } else {
      await runAITurn();
    }
    if (isPassPlayMode()) {
      const count = multiplayerCommanderCount();
      state.multiplayer.commanderIndex = (state.multiplayer.commanderIndex + 1) % count;
      const nextCommander = currentCommanderNumber();
      addLog(`Pass device to Commander ${nextCommander}.`);
      showBattleOutcome(`Pass device to Commander ${nextCommander}.`, true, true);
      render();
      return;
    }
    if (isNetworkMode()) {
      const sent = await sendNetworkHandoff();
      if (!sent) {
        showBattleOutcome(state.multiplayer.network.lastError || "LAN handoff failed.", false, false);
        render();
        return;
      }
      const activePlayer = networkActivePlayer();
      const activeName = activePlayer ? activePlayer.name : "remote commander";
      setNetworkWaiting(state.multiplayer.network.activePlayerId !== state.multiplayer.network.playerId);
      addLog(`Turn handed off to ${activeName}.`);
      showBattleOutcome(`Turn sent to ${activeName}. Next actions: ${currentTurnActionInstruction()}`, true, false);
      render();
    }
  })();
}

function updateButtons() {
  const playerTurn = isLocalTurnOwner();
  const controlsLocked = state.gameOver || state.animating || state.setupOpen || isNetworkInputLocked();
  startAttackBtn.disabled = !playerTurn || state.phase !== "reinforce" || state.reinforcementsLeft > 0 || controlsLocked;
  attackBtn.disabled =
    !playerTurn ||
    state.phase !== "attack" ||
    !canResolveSelectedOrder() ||
    controlsLocked;
  endTurnBtn.disabled = (!playerTurn || controlsLocked);
  if (confirmBtn) confirmBtn.disabled = endTurnBtn.disabled;
}

function updateMapVisuals() {
  const openingSeason =
    isLocalTurnOwner() &&
    state.phase === "reinforce" &&
    state.year === 1850 &&
    state.seasonIndex === 0;

  Object.keys(territoryEls).forEach((name) => {
    const { polygon, army, shipCount } = territoryEls[name];
    const territory = state.territories[name];
    polygon.classList.remove(...OWNER_STYLE_CLASSES, "selected", "source-flash", "target-flash", "home-base", "fortified");
    const styleClass = ownerStyleClass(territory.owner);
    polygon.classList.add(styleClass);
    if (state.selection.from === name || state.selection.to === name) polygon.classList.add("selected");
    if (movementCue?.from === name) polygon.classList.add("source-flash");
    if (movementCue?.to === name) polygon.classList.add("target-flash");
    if (openingSeason && state.homeBase === name) polygon.classList.add("home-base");
    if (territory.fortified > 0) polygon.classList.add("fortified");
    army.textContent = String(territory.armies);
    if (shipCount) {
      const shipsHere = territoryShipCount(name);
      shipCount.textContent = String(shipsHere);
      shipCount.classList.toggle("empty", shipsHere < 1);
    }
  });

  applyMapCamera();

  if (state.selection.from && state.selection.to && !movementCue) {
    setLineEndpoints(aimLineEl, state.selection.from, state.selection.to);
    aimLineEl.classList.add("active");
  } else {
    aimLineEl.classList.remove("active");
  }

  if (movementCue) {
    setLineEndpoints(moveLineEl, movementCue.from, movementCue.to);
    moveLineEl.classList.remove("player", "ai");
    moveLineEl.classList.add(ownerToneClass(movementCue.owner), "active");
  } else {
    moveLineEl.classList.remove("player", "ai", "active");
  }
}

function statusMessage() {
  if (state.setupOpen) {
    if (state.setupStep === "create") {
      return "Create a game. Choose solo or a multiplayer mode.";
    }
    return "Set map, rules, difficulty, and starting country. Press Start when ready.";
  }
  if (state.gameOver) {
    return territoryCount(localHumanOwner()) > 0
      ? "Victory. The rival empire has fallen."
      : "Defeat. Your empire has fallen.";
  }
  if (isNetworkInputLocked()) {
    const activePlayer = networkActivePlayer();
    const activeName = activePlayer ? activePlayer.name : "another commander";
    const roomLabel = state.multiplayer.network.room || state.networkSetup.room || MULTIPLAYER_DEFAULT_ROOM;
    return `Waiting for ${activeName} in LAN lobby "${roomLabel}". They should: ${currentTurnActionInstruction()}`;
  }
  if (movementCue) {
    const forceText = movementCue.force ? ` with force ${movementCue.force}` : "";
    const fromName = territoryLabel(movementCue.from);
    const toName = territoryLabel(movementCue.to);
    return `${ownerName(movementCue.owner)} moving ${fromName} -> ${toName}${forceText}.`;
  }
  if (isAIOwner(state.turn)) return `${ownerName(state.turn)} is issuing orders.`;
  if (
    state.phase === "reinforce" &&
    state.year === 1850 &&
    state.seasonIndex === 0 &&
    state.reinforcementsLeft > 0 &&
    state.homeBase
  ) {
    const homeLabel = territoryLabel(state.homeBase);
    return `Home base: ${homeLabel}. Deploy ${state.reinforcementsLeft} reinforcements here or nearby.`;
  }
  if (state.phase === "reinforce") {
    if (state.seasonIndex === 0) {
      if (state.reinforcementsLeft > 0) {
        return `Spring budget window open. Deploy ${state.reinforcementsLeft} reinforcements by tapping your territories.`;
      }
      return "Spring budget window open. Begin offensive when ready.";
    }
    if (state.reinforcementsLeft > 0) {
      return `Treasury locked until next Spring. Deploy ${state.reinforcementsLeft} reinforcements by tapping your territories.`;
    }
    return "Treasury locked until next Spring. Begin offensive when ready.";
  }
  if (!state.selection.from) return "Next: Tap one of your territories with armies or docked ships to start.";
  if (state.selection.from && !state.selection.to) return "Next: Tap your region to transfer, or an enemy region to attack (coastal ships can travel farther).";
  if (state.selection.from && state.selection.to) {
    const friendlyTransfer = state.territories[state.selection.to]?.owner === localHumanOwner();
    if (friendlyTransfer) {
      const canUseShips = canUseShipsOnRoute(state.selection.from, state.selection.to);
      const shipsText = canUseShips
        ? `${state.attackShips} ships`
        : "0 ships (land route)";
      return `Next: Move ${state.attackForce} armies and ${shipsText} to ${territoryLabel(state.selection.to)}.`;
    }
    const probability = estimateAttackSuccessProbability(
      state.selection.from,
      state.selection.to,
      state.attackForce,
      state.attackShips
    );
    const chanceText = probability == null ? "--" : `${Math.round(probability * 100)}%`;
    const shipRuleText = canUseShipsOnRoute(state.selection.from, state.selection.to)
      ? `${state.attackShips} ships`
      : "0 ships (land route)";
    return `Next: Resolve battle with ${state.attackForce} armies and ${shipRuleText}. Odds: ${chanceText}.`;
  }
  return "Next: Choose your action.";
}

function render() {
  const fromName = state.selection.from ? territoryLabel(state.selection.from) : "";
  const toName = state.selection.to ? territoryLabel(state.selection.to) : "";
  const friendlyTargetSelected =
    Boolean(state.selection.to) && state.territories[state.selection.to]?.owner === localHumanOwner();

  turnLabel.textContent = isLocalTurnOwner() ? currentCommanderLabel() : ownerName(state.turn);
  phaseLabel.textContent = state.phase[0].toUpperCase() + state.phase.slice(1);
  reinforcementLabel.textContent = String(state.reinforcementsLeft);
  selectionLabel.textContent = state.selection.from
    ? `${fromName}${state.selection.to ? ` -> ${toName}` : ""}`
    : "None";
  dateLabel.textContent = `${SEASONS[state.seasonIndex]} ${state.year}`;
  if (isLocalTurnOwner()) {
    turnPill.textContent = `${currentCommanderLabel()} Regency`;
  } else {
    turnPill.textContent = `${ownerName(state.turn)} Regency`;
  }
  updateMobileTopMenuUI();
  syncDisplayedTreasury();
  treasuryLabel.textContent = state.treasury.toLocaleString();

  if (regionValueLabel) {
    if (state.viewedTerritory) {
      const val = territoryValue(state.viewedTerritory);
      regionValueLabel.textContent = `$${val.toLocaleString()}`;
    } else {
      regionValueLabel.textContent = "--";
    }
  }

  const message = statusMessage();
  statusText.textContent = message;
  ribbonText.textContent = message;
  if (attackBtn) attackBtn.textContent = friendlyTargetSelected ? "Move Forces" : "Resolve Battle";
  if (mobileResolveBtn) mobileResolveBtn.textContent = friendlyTargetSelected ? "Move Forces" : "Resolve Battle";

  updateButtons();
  updateControlBar();
  updateAttackForceUI();
  updateEconomyUI();
  updateActionGuidance();
  updateMobileForcePopup();
  updateMobileNextStepBar();
  updateMapVisuals();
}

function buildMap() {
  worldMapEl.innerHTML = "";
  routeEls = [];

  const defs = svgEl("defs");
  createMapTextureDefs(defs);
  defs.appendChild(createArrowMarker("arrowhead-aim", "#ffe6a5"));
  defs.appendChild(createArrowMarker("arrowhead-player", "#d14b34"));
  defs.appendChild(createArrowMarker("arrowhead-ai", "#5466d2"));
  const mountainClipIds = new Map();
  MOUNTAIN_RANGES.forEach((range) => {
    if (!range.territory || mountainClipIds.has(range.territory)) return;
    const layout = MAP_LAYOUT[range.territory];
    if (!layout) return;
    const clipId = `mountain-clip-${range.territory.toLowerCase().replace(/[^a-z0-9]+/g, "-")}`;
    const territoryClip = svgEl("clipPath", {
      id: clipId,
      clipPathUnits: "userSpaceOnUse"
    });
    territoryClip.appendChild(svgEl("polygon", { points: layout.points }));
    defs.appendChild(territoryClip);
    mountainClipIds.set(range.territory, clipId);
  });

  const waterLayer = svgEl("g", { "aria-hidden": "true" });
  const routesLayer = svgEl("g", { "aria-hidden": "true" });
  const territoryLayer = svgEl("g");
  const mountainLayer = svgEl("g", {
    class: "mountain-layer",
    "aria-hidden": "true"
  });
  const territoryTokenLayer = svgEl("g", { class: "territory-token-layer", "aria-hidden": "true" });
  const territoryLabelLayer = svgEl("g", { class: "territory-label-layer", "aria-hidden": "true" });
  const overlayLayer = svgEl("g", { "aria-hidden": "true" });

  const oceanBase = svgEl("rect", {
    class: "ocean-base",
    x: 0,
    y: 0,
    width: VIEWBOX_WIDTH,
    height: VIEWBOX_HEIGHT
  });
  const oceanWash = svgEl("rect", {
    class: "ocean-wash",
    x: 0,
    y: 0,
    width: VIEWBOX_WIDTH,
    height: VIEWBOX_HEIGHT
  });
  const oceanNoise = svgEl("rect", {
    class: "ocean-noise",
    x: 0,
    y: 0,
    width: VIEWBOX_WIDTH,
    height: VIEWBOX_HEIGHT
  });
  const oceanScratches = svgEl("path", {
    class: "ocean-scratches",
    d: createOceanScratchPath()
  });
  const oceanVignette = svgEl("rect", {
    class: "ocean-vignette",
    x: 0,
    y: 0,
    width: VIEWBOX_WIDTH,
    height: VIEWBOX_HEIGHT
  });
  waterLayer.appendChild(oceanBase);
  waterLayer.appendChild(oceanWash);
  waterLayer.appendChild(oceanNoise);
  waterLayer.appendChild(oceanScratches);
  waterLayer.appendChild(oceanVignette);

  const seen = new Set();
  Object.entries(TERRITORIES).forEach(([name, neighbors]) => {
    neighbors.forEach((neighbor) => {
      const key = routeKey(name, neighbor);
      if (seen.has(key)) return;
      seen.add(key);
      if (MOUNTAIN_BLOCKED_ROUTE_KEYS.has(key)) return;
      const from = MAP_LAYOUT[name].token;
      const to = MAP_LAYOUT[neighbor].token;
      const routeLine = svgEl("line", {
        class: "route",
        x1: from.x,
        y1: from.y,
        x2: to.x,
        y2: to.y
      });
      routesLayer.appendChild(routeLine);
      routeEls.push(routeLine);
    });
  });

  MOUNTAIN_RANGES.forEach((range) => {
    const clipId = mountainClipIds.get(range.territory);
    if (!clipId) return;
    const band = buildMountainBandPath(range);
    const peaks = buildMountainPeakPath(range);
    if (!band) return;
    const bandWidth = Number.isFinite(range.bandWidth) ? range.bandWidth : 7.2;
    const shadowWidth = Math.max(1.5, bandWidth * 1.02);
    const glyphStroke = Math.max(0.5, bandWidth * 0.085);

    const rangeGroup = svgEl("g", {
      class: `mountain-range mountain-range-${range.id}`,
      "clip-path": `url(#${clipId})`
    });
    const shadowPath = svgEl("path", {
      class: "mountain-shadow",
      d: band,
      "stroke-width": shadowWidth.toFixed(2)
    });
    const bandPath = svgEl("path", {
      class: "mountain-band",
      d: band,
      "stroke-width": bandWidth.toFixed(2)
    });
    rangeGroup.appendChild(shadowPath);
    rangeGroup.appendChild(bandPath);
    if (peaks) {
      const peakPath = svgEl("path", {
        class: "mountain-glyphs",
        d: peaks,
        "stroke-width": glyphStroke.toFixed(2)
      });
      rangeGroup.appendChild(peakPath);
    }
    mountainLayer.appendChild(rangeGroup);
  });

  const labelPositions = {};
  Object.entries(MAP_LAYOUT).forEach(([name, layout]) => {
    const polygonPoints = parsePolygonPoints(layout.points);
    const centroid = polygonCentroid(layout.points);
    const fallback = layout.label || layout.token;
    let x = fallback.x;
    let y = fallback.y;
    if (Number.isFinite(centroid?.x) && Number.isFinite(centroid?.y)) {
      x = (centroid.x * 0.62) + (fallback.x * 0.38);
      y = (centroid.y * 0.62) + (fallback.y * 0.38);
    }
    const blended = { x, y };
    if (!isPointInsidePolygon(blended, polygonPoints)) {
      if (isPointInsidePolygon(fallback, polygonPoints)) {
        x = fallback.x;
        y = fallback.y;
      } else if (Number.isFinite(centroid?.x) && Number.isFinite(centroid?.y) && isPointInsidePolygon(centroid, polygonPoints)) {
        x = centroid.x;
        y = centroid.y;
      }
    }
    labelPositions[name] = {
      x: clampNumber(x, 12, VIEWBOX_WIDTH - 12),
      y: clampNumber(y, 12, VIEWBOX_HEIGHT - 12)
    };
  });

  Object.entries(MAP_LAYOUT).forEach(([name, layout]) => {
    const coreRadius = tokenRadiusFor(name);
    const ringRadius = 9.0;
    const shadowRadius = 10.7;
    const pinFillRadius = 7.5;
    let labelX = labelPositions[name]?.x ?? layout.label.x;
    let labelY = labelPositions[name]?.y ?? layout.label.y;
    const localDensity = computeLocalLabelDensityAt(name, labelX, labelY, labelPositions);
    if (labelY < 10) labelY = 10;
    const labelAnchor = "middle";
    const externalLabel = false;
    const labelSize = labelFontSizeFor(name);
    const chipSide = layout.token.x < (VIEWBOX_WIDTH * 0.5) ? 1 : -1;
    const chipWidth = 44;
    const chipHeight = 19;
    const chipOffsetX = 32;
    const chipY = layout.token.y;
    const chipCenterX = layout.token.x + (chipSide * chipOffsetX);

    const terrainGroup = svgEl("g", { "data-territory": name });
    const tokenGroup = svgEl("g");
    const labelGroup = svgEl("g");
    const polygon = svgEl("polygon", { points: layout.points, class: "territory" });
    const textureOverlay = svgEl("polygon", { points: layout.points, class: "territory-texture" });
    const shadeOverlay = svgEl("polygon", { points: layout.points, class: "territory-shade" });
    const labelLine = svgEl("line", {
      class: externalLabel ? "territory-label-line external" : "territory-label-line",
      x1: layout.token.x,
      y1: layout.token.y - (coreRadius * 0.35),
      x2: labelX,
      y2: externalLabel ? (labelY - 3.1) : labelY
    });
    const label = svgEl("text", {
      class: "territory-label",
      x: labelX,
      y: labelY,
      "text-anchor": labelAnchor,
      "font-size": `${labelSize}px`
    });
    label.dataset.baseFont = String(labelSize);
    label.dataset.localDensity = String(localDensity);
    label.dataset.external = externalLabel ? "1" : "0";
    label.style.textAnchor = labelAnchor;
    label.style.fontSize = `${labelSize}px`;
    label.textContent = territoryLabel(name, name);

    const pinShadow = svgEl("circle", {
      class: "army-token",
      cx: layout.token.x + 1,
      cy: layout.token.y + 1,
      r: shadowRadius
    });
    if (!hasCapitalIcon(name)) pinShadow.style.display = "none";

    const armyRing = svgEl("circle", {
      class: "army-ring",
      cx: layout.token.x,
      cy: layout.token.y,
      r: ringRadius
    });
    if (!hasCapitalIcon(name)) armyRing.style.display = "none";

    const armyFill = svgEl("circle", {
      class: "army-fill",
      cx: layout.token.x,
      cy: layout.token.y,
      r: pinFillRadius
    });
    if (!hasCapitalIcon(name)) armyFill.style.display = "none";

    const statsPlate = svgEl("rect", {
      class: "stats-plate",
      x: chipCenterX - (chipWidth / 2),
      y: chipY - (chipHeight / 2),
      width: chipWidth,
      height: chipHeight,
      rx: 3.7,
      ry: 3.7
    });

    const statsDivider = svgEl("line", {
      class: "stats-divider",
      x1: chipCenterX,
      y1: chipY - (chipHeight * 0.42),
      x2: chipCenterX,
      y2: chipY + (chipHeight * 0.42)
    });

    const troopIcon = svgEl("text", {
      class: "troop-icon",
      x: layout.token.x,
      y: layout.token.y
    });
    troopIcon.textContent = "";
    if (!hasCapitalIcon(name)) troopIcon.style.display = "none";

    const army = svgEl("text", {
      class: "army-count",
      x: chipCenterX - 9.5,
      y: chipY
    });
    army.style.fontSize = "13.2px";
    army.style.strokeWidth = "1.0px";
    army.textContent = "1";

    const shipCount = svgEl("text", {
      class: "ship-count",
      x: chipCenterX + 9.5,
      y: chipY
    });
    shipCount.style.fontSize = "13.2px";
    shipCount.style.strokeWidth = "1.0px";
    shipCount.textContent = "0";

    terrainGroup.appendChild(polygon);
    terrainGroup.appendChild(shadeOverlay);
    terrainGroup.appendChild(textureOverlay);
    tokenGroup.appendChild(statsPlate);
    tokenGroup.appendChild(statsDivider);
    tokenGroup.appendChild(army);
    tokenGroup.appendChild(shipCount);
    tokenGroup.appendChild(pinShadow);
    tokenGroup.appendChild(armyRing);
    tokenGroup.appendChild(armyFill);
    tokenGroup.appendChild(troopIcon);
    labelGroup.appendChild(labelLine);
    labelGroup.appendChild(label);
    terrainGroup.addEventListener("click", (event) => {
      if (shouldIgnoreMapClick()) {
        event.preventDefault();
        return;
      }
      select(name);
    });

    territoryLayer.appendChild(terrainGroup);
    territoryTokenLayer.appendChild(tokenGroup);
    territoryLabelLayer.appendChild(labelGroup);
    territoryEls[name] = {
      name,
      polygon,
      army,
      label,
      labelLine,
      troopIcon,
      shipCount,
      statsPlate,
      statsDivider,
      armyFill,
      armyRing,
      pinShadow,
      chipSide,
      labelBaseX: labelX,
      labelBaseY: labelY,
      tokenX: layout.token.x,
      tokenY: layout.token.y
    };
  });

  aimLineEl = svgEl("line", { class: "aim-line", x1: 0, y1: 0, x2: 0, y2: 0 });
  moveLineEl = svgEl("line", { class: "move-line", x1: 0, y1: 0, x2: 0, y2: 0 });
  overlayLayer.appendChild(aimLineEl);
  overlayLayer.appendChild(moveLineEl);

  worldMapEl.appendChild(defs);
  worldMapEl.appendChild(waterLayer);
  worldMapEl.appendChild(routesLayer);
  worldMapEl.appendChild(territoryLayer);
  worldMapEl.appendChild(mountainLayer);
  worldMapEl.appendChild(territoryTokenLayer);
  worldMapEl.appendChild(territoryLabelLayer);
  worldMapEl.appendChild(overlayLayer);
  setupMapInteractions();
}

function initGame(playerCountryId = state.playerCountryId) {
  if (!aimLineEl) buildMap();
  resetMapCamera();

  const names = Object.keys(TERRITORIES);
  const difficultyProfile = setupDifficultyById(state.setupOptions.difficulty);
  const { playerCountry, aiStarts } = buildStartingAssignments(playerCountryId);
  const playerStart = playerCountry.territory;
  state.territories = {};
  names.forEach((name) => {
    state.territories[name] = {
      owner: "neutral",
      armies: 8 + Math.floor(Math.random() * 13),
      fortified: 0
    };
  });
  state.territories[playerStart] = { owner: "player", armies: difficultyProfile.playerStartArmies, fortified: 0 };
  aiStarts.forEach(({ owner, territory }) => {
    state.territories[territory] = { owner, armies: difficultyProfile.aiStartArmies, fortified: 0 };
  });
  const claimedCountryIds = new Set([playerCountry.id, ...aiStarts.map(({ country }) => country.id)]);
  const reserveCapitals = STARTING_COUNTRY_POOL.filter((country) => !claimedCountryIds.has(country.id));
  reserveCapitals.forEach((country, index) => {
    const owner = AI_OWNERS[index % AI_OWNERS.length];
    state.territories[country.territory] = { owner, armies: difficultyProfile.reserveStartArmies, fortified: 0 };
  });

  state.turn = "player";
  state.phase = "reinforce";
  state.reinforcementsLeft = reinforcementFor("player");
  state.attackForce = 1;
  state.attackShips = 0;
  state.selection = { from: null, to: null };
  state.setupOpen = false;
  state.playerCountryId = playerCountry.id;
  state.homeBase = playerStart;
  state.ships = 8;
  state.playerShipLocations = {};
  state.playerShipLocations[playerStart] = state.ships;
  state.aiShips = AI_OWNERS.reduce((acc, owner) => {
    acc[owner] = 4 + Math.floor(Math.random() * 3);
    return acc;
  }, {});
  state.gameOver = false;
  state.seasonIndex = 0;
  state.year = 1850;
  state.lastIncomeYear = 1850;
  state.treasury = STARTING_TREASURY;
  state.treasuryByOwner = { player: STARTING_TREASURY };
  state.firstRound = true;
  state.animating = false;
  state.forceMenuHidden = false;
  state.economyPanelOpen = false;
  state.outcomeAckRequired = false;
  state.outcomeAckWaiters = [];
  attackOddsCacheKey = "";
  attackOddsCacheValue = null;

  if (logEl) logEl.innerHTML = "";
  clearMovementCue();
  clearBattleOutcome(true);
  updateSoundToggle();
  hideCountryPicker();
  renderCountryPickerOptions();
  autoDeployPlayerReinforcementsIfNeeded();
  focusMapOnTerritory(playerStart, isMobileLikeUI() ? 5.1 : 2.85);
  addLog(`Campaign begins. Player starts as ${playerCountry.name} in ${territoryLabel(playerStart)}.`);
  aiStarts.forEach(({ owner, country, territory }) => {
    addLog(`${ownerName(owner)} starts as ${country.name} in ${territoryLabel(territory)}.`);
  });
  if (reserveCapitals.length > 0) {
    const reserveSummary = reserveCapitals
      .map((country, index) => `${territoryLabel(country.territory)} (${ownerName(AI_OWNERS[index % AI_OWNERS.length])})`)
      .join(", ");
    addLog(`Additional capitals occupied at start: ${reserveSummary}.`);
  }
  addLog("All unowned territories begin with 8-20 neutral armies.");
  addLog("Mountain ranges block direct land travel on key borders; use coastal ship routes where available.");
  addLog("Budget rule: spend treasury only during Spring reinforcement; new revenue arrives each new year.");
  addLog("Attack phase: tap your own region to transfer or enemy to attack; coastal routes can extend range when ships are committed.");
  if (isMobileLikeUI()) {
    addLog("Map controls: drag and pinch to move and zoom.");
  } else {
    addLog("Map controls: drag to move, pinch or +/- to zoom, and use View My Capital to recenter.");
  }
  addLog("Mobile: use the top Next Step card and bottom shop bar without opening menus.");
  render();
}

startAttackBtn.addEventListener("click", startAttackPhase);
attackBtn.addEventListener("click", () => {
  void executePlayerAttack();
});
endTurnBtn.addEventListener("click", endPlayerTurn);
if (confirmBtn) confirmBtn.addEventListener("click", endPlayerTurn);
function openNewCampaignPicker() {
  shutdownNetworkSession();
  showCountryPicker(state.playerCountryId);
}

async function handleToggleSound() {
  await unlockAudio();
  audioState.enabled = !audioState.enabled;
  if (audioState.enabled) {
    startBackgroundMusic();
  } else {
    stopBackgroundMusic();
  }
  updateSoundToggle();
  if (audioState.enabled) playSound("select");
}

async function handleSoundTest() {
  await unlockAudio();
  if (audioState.enabled) {
    playSound("test");
  }
}

if (startScreenBackBtn) {
  startScreenBackBtn.addEventListener("click", () => {
    if (state.setupStep === "options") {
      state.setupStep = "create";
      playSound("select");
      renderSetupWizard();
      render();
      return;
    }
    if (state.multiplayer.network.active) {
      shutdownNetworkSession();
    }
    hideCountryPicker();
    render();
  });
}

if (startScreenNextBtn) {
  startScreenNextBtn.addEventListener("click", async () => {
    await unlockAudio();
    if (state.setupStep === "create") {
      state.setupStep = "options";
      playSound("select");
      renderSetupWizard();
      render();
      return;
    }
    try {
      await launchCampaignFromSetup();
    } catch (error) {
      const message = error instanceof Error && error.message
        ? error.message
        : "Unexpected setup error while starting lobby.";
      setNetworkSetupError(message, true);
      renderSetupWizard();
      render();
    }
  });
}

newGameBtn.addEventListener("click", openNewCampaignPicker);
soundToggleBtn.addEventListener("click", () => {
  void handleToggleSound();
});
soundTestBtn.addEventListener("click", () => {
  void handleSoundTest();
});
if (mobileMenuBtn) {
  mobileMenuBtn.addEventListener("click", () => {
    setMobileTopMenuOpen(true);
  });
}
if (mobileMenuCloseBtn) {
  mobileMenuCloseBtn.addEventListener("click", () => {
    setMobileTopMenuOpen(false);
  });
}
if (mobileTopMenuEl) {
  mobileTopMenuEl.addEventListener("click", (event) => {
    if (event.target === mobileTopMenuEl) {
      setMobileTopMenuOpen(false);
    }
  });
}
document.addEventListener("keydown", (event) => {
  if (event.key === "Escape" && mobileTopMenuOpen) {
    setMobileTopMenuOpen(false);
  }
});
if (mobileMenuHomeBtn) {
  mobileMenuHomeBtn.addEventListener("click", () => {
    setMobileTopMenuOpen(false);
    openNewCampaignPicker();
  });
}
if (mobileMenuSfxBtn) {
  mobileMenuSfxBtn.addEventListener("click", () => {
    void handleToggleSound();
  });
}
if (mobileMenuTestBtn) {
  mobileMenuTestBtn.addEventListener("click", () => {
    void handleSoundTest();
  });
}
if (mobileMenuSaveBtn) {
  mobileMenuSaveBtn.addEventListener("click", () => {
    const result = saveGameToStorage();
    if (result.ok) {
      showBattleOutcome("Game saved.", true, false);
      return;
    }
    showBattleOutcome(result.message, false, false);
  });
}
if (mobileMenuLoadBtn) {
  mobileMenuLoadBtn.addEventListener("click", () => {
    const result = loadGameFromStorage();
    if (result.ok) {
      setMobileTopMenuOpen(false);
      showBattleOutcome(`Loaded save from ${formatSavedTimestamp(result.savedAt)}.`, true, false);
      return;
    }
    showBattleOutcome(result.message, false, false);
  });
}
if (ordersPanel && closePanelBtn) {
  closePanelBtn.addEventListener("click", () => {
    ordersPanel.dataset.userToggled = "1";
    const collapsed = ordersPanel.classList.toggle("collapsed");
    closePanelBtn.textContent = collapsed ? ">" : "X";
  });
}
if (buyArmiesBtn) buyArmiesBtn.addEventListener("click", buyArmiesBundle);
if (buyShipsBtn) buyShipsBtn.addEventListener("click", buyShipsBundle);
if (fortifyBtn) fortifyBtn.addEventListener("click", fortifyTerritory);
if (economyToggleBtn) {
  economyToggleBtn.addEventListener("click", () => {
    if (!canIssueOrders() || !canSpendTreasuryNow()) return;
    state.economyPanelOpen = !state.economyPanelOpen;
    playSound("select");
    render();
  });
}
if (mobileBuyArmiesBtn) mobileBuyArmiesBtn.addEventListener("click", buyArmiesBundle);
if (mobileBuyShipsBtn) mobileBuyShipsBtn.addEventListener("click", buyShipsBundle);
if (mobileFortifyBtn) mobileFortifyBtn.addEventListener("click", fortifyTerritory);
if (mobileForceCloseBtn) {
  mobileForceCloseBtn.addEventListener("click", () => {
    state.forceMenuHidden = true;
    render();
  });
}
if (mobileForceOpenBtn) {
  mobileForceOpenBtn.addEventListener("click", () => {
    state.forceMenuHidden = false;
    render();
  });
}
if (mobileNextBtn) {
  mobileNextBtn.addEventListener("click", () => {
    const action = mobileNextBtn.dataset.action;
    if (action === "begin-offensive") {
      startAttackPhase();
      return;
    }
    if (action === "resolve-battle") {
      void executePlayerAttack();
      return;
    }
    if (action === "focus-home") {
      const focusName = state.selection.from || state.homeBase || firstPlayerTerritoryName();
      if (focusName) focusMapOnTerritory(focusName);
      return;
    }
  });
}
if (mobileEndBtn) {
  mobileEndBtn.addEventListener("click", () => {
    endPlayerTurn();
  });
}
document.addEventListener("pointerdown", (event) => {
  if (tryAcknowledgeBattleOutcome(event)) return;
}, true);

function applyAttackForceFromValue(rawValue) {
  const next = Number.parseInt(rawValue, 10);
  if (!Number.isNaN(next)) {
    const sliderMin = Number.parseInt(armySendSlider?.min || "0", 10);
    const minForce = Number.isNaN(sliderMin) ? 0 : sliderMin;
    state.attackForce = Math.max(minForce, next);
    render();
  }
}

function applyShipForceFromValue(rawValue) {
  const next = Number.parseInt(rawValue, 10);
  if (!Number.isNaN(next)) {
    state.attackShips = Math.max(0, next);
    render();
  }
}

armySendSlider.addEventListener("input", () => {
  applyAttackForceFromValue(armySendSlider.value);
});
if (shipSendSlider) {
  shipSendSlider.addEventListener("input", () => {
    applyShipForceFromValue(shipSendSlider.value);
  });
}
if (mobileArmySendSlider) {
  mobileArmySendSlider.addEventListener("input", () => {
    applyAttackForceFromValue(mobileArmySendSlider.value);
  });
}
if (mobileShipSendSlider) {
  mobileShipSendSlider.addEventListener("input", () => {
    applyShipForceFromValue(mobileShipSendSlider.value);
  });
}
if (mobileResolveBtn) {
  mobileResolveBtn.addEventListener("click", () => {
    void executePlayerAttack();
  });
}
const unlockOnce = () => {
  void unlockAudio();
};
document.addEventListener("pointerdown", unlockOnce, { once: true });
document.addEventListener("touchstart", unlockOnce, { once: true });
document.addEventListener("mousedown", unlockOnce, { once: true });

if (ordersPanel && closePanelBtn && isMobileLikeUI()) {
  ordersPanel.classList.add("collapsed");
  closePanelBtn.textContent = ">";
}

window.addEventListener("beforeunload", () => {
  shutdownNetworkSession();
});

initGame(state.playerCountryId);
showCountryPicker(state.playerCountryId);
